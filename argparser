#!/bin/bash

# Author: Simon Brandt
# E-Mail: simon.brandt@uni-greifswald.de
# Last Modification: 2025-03-17

# TODO: Consider using the Bash 5.3 form "${ printf ... ; }" for command
#       substitutions instead of "$(printf ...)" or nonlocal variables,
#       additionally speeding up the argparser.
# TODO: Support mutually exclusive argument groups.

# Usage: Source this script with `source argparser -- "$@"` inside the
# script whose arguments need to be parsed.  If ${ARGPARSER_READ_ARGS}
# is set to true (the default), the arguments will be parsed upon
# sourcing.  If ${ARGPARSER_SET_ARGS} is set to true (the default), the
# arguments will also be set to variables upon sourcing, else, the
# associative array which ${ARGPARSER_ARG_ARRAY_NAME} points to needs to
# be accessed.  Refer to the README.md for details.

# Purpose: Parse a script's arguments, giving proper error and warning
# messages for wrongly set arguments, assigning the values to the
# respective variables, as well as creating and printing a help, usage,
# and version message.  Refer to the README.md for details.

########################################################################

# Define the argparser functions to check that the argparser is run by
# Bash 4.0 or higher, and execute the former immediately, such that the
# rest of the script doesn't get parsed (which would create errors since
# it's written in Bash, not POSIX compliantly).
argparser_check_shell() {
    # Check that the current shell is a Bash instance.  Else, print an
    # error message.
    #
    # In order to have the function interpretable by shells other than
    # Bash, all commands are written in a POSIX-conformant form.

    # shellcheck disable=SC2292  # Intentional POSIX conformance.
    if [ -z "${BASH}" ]; then
        printf '%s: ' "$0"
        printf 'Error: The argument parsing requires Bash as active shell.\n'
        exit 1
    fi
}
argparser_check_shell

function argparser_check_bash_version() {
    # Check that version of the current Bash instance is at least 4.0.
    # Else, print an error message.
    #
    # Environment:
    # ARGPARSER_CHECK_ENV_VARS (read-only)
    # ARGPARSER_ERROR_EXIT_CODE
    # ARGPARSER_ERROR_STYLE
    # ARGPARSER_USE_STYLES_IN_FILES

    # Define the local variable.
    local error_message

    # Check Bash's version.
    if (( "${BASH_VERSINFO[0]}" < 4 )); then
        error_message="Error: For argument parsing, Bash 4.0 or higher is "
        error_message+="mandatory."

        if [[ ! -v "ARGPARSER_CHECK_ENV_VARS" \
            || "${ARGPARSER_CHECK_ENV_VARS}" != false ]]
        then
            ARGPARSER_ARG_DELIMITER_2=","
            ARGPARSER_ERROR_EXIT_CODE=1
            ARGPARSER_ERROR_STYLE="red,bold,reverse"
            ARGPARSER_USE_STYLES_IN_FILES=false
        fi
        argparser_print_error_or_warning_message "error" false true \
            "${error_message}"
    fi
}

# Define the argparser functions used for general tests.
function argparser_in_array() {
    # Check if an element occurs in an array.
    #
    # Arguments:
    # - $1: the element to search for
    # - $@: the array to search through
    #
    # Return value:
    # - 0, if the element exists in the array
    # - 1, else

    # Define the local variables.
    local element
    local query

    # Read the query element and shift the arguments such that only the
    # array to search through remains.
    query="$1"
    shift

    # Iterate through the array and compare each element to the query.
    # Return 0 on success, else 1.
    for element in "$@"; do
        if [[ "${element}" == "${query}" ]]; then
            return 0
        fi
    done

    return 1
}

function argparser_is_variable_bool() {
    # Check if a variable's value is a boolean.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Return value:
    # - 0, if the variable's value is a boolean
    # - 1, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == true || "${var}" == false ]]; then
        return 0
    else
        return 1
    fi
}

function argparser_is_variable_char() {
    # Check if a variable's value is a (printable) character.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Return value:
    # - 0, if the variable's value is a character
    # - 1, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == [[:print:]] ]]; then
        return 0
    else
        return 1
    fi
}

function argparser_is_variable_identifier() {
    # Check if a variable's value is usable as Bash variable identifier.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Return value:
    # - 0, if the variable's value is usable as identifier
    # - 1, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == [[:alpha:]_]+([[:word:]]) ]]; then
        return 0
    else
        return 1
    fi
}

function argparser_is_variable_int() {
    # Check if a variable's value is an integer.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Return value:
    # - 0, if the variable's value is an integer
    # - 1, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == ?([+-])+([[:digit:]]) ]]; then
        return 0
    else
        return 1
    fi
}

function argparser_is_variable_uint() {
    # Check if a variable's value is an unsigned integer.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Return value:
    # - 0, if the variable's value is an unsigned integer
    # - 1, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == +([[:digit:]]) ]]; then
        return 0
    else
        return 1
    fi
}

function argparser_check_color_or_style() {
    # Check if the specified colors and/or styles are implemented for
    # argparser_colorize.
    #
    # Arguments:
    # - $1: the colors and/or styles to use as comma-separated list
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    #
    # Return value:
    # - 0, if all colors and/or styles are implemented
    # - 1, else

    # Define the local variables.
    local request
    local requests
    local -a styles

    # Read the argument.
    requests="$1"

    # Define the array of implemented colors and styles.
    # shellcheck disable=SC2190  # Indexed, not associative array.
    styles=(
        black
        red
        green
        yellow
        blue
        magenta
        cyan
        white
        normal
        bold
        faint
        italic
        underline
        double
        overline
        crossed-out
        blink
        reverse
    )

    # Split the requested color and/or style on commas and print any.
    # Then, print the string and reset the color and style.  If a
    # non-existing color or style is requested, abort the script with
    # an error message.
    IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a requests <<< "${requests}"
    for request in "${requests[@]}"; do
        if ! argparser_in_array "${request}" "${styles[@]}"; then
            return 1
        fi
    done

    return 0
}

function argparser_check_file() {
    # Check if a file exists, is a regular file, is readable, and has a
    # size greater than 0 bytes.
    #
    # Arguments:
    # - $1: the file to check
    #
    # Nonlocals:
    # - file_attributes: a bit mask with four bits set to 0 (true) if
    #   the file exists (first bit), is a regular file (second bit), is
    #   readable (third bit), and/or has a size greater than 0 bytes
    #   (fourth bit), else set to 1 (false)

    # Define the local variable.
    local file

    # Read the argument.
    file="$1"

    # Check the variable's value.
    if [[ -e "${file}" ]]; then
        file_attributes="0"
    else
        file_attributes="1"
    fi

    if [[ -f "${file}" ]]; then
        file_attributes+="0"
    else
        file_attributes+="1"
    fi

    if [[ -r "${file}" ]]; then
        file_attributes+="0"
    else
        file_attributes+="1"
    fi

    if [[ -s "${file}" ]]; then
        file_attributes+="0"
    else
        file_attributes+="1"
    fi
}

# Define the general argparser util functions.
function argparser_trim() {
    # Trim leading an trailing space characters from a string.
    #
    # Arguments:
    # - $1: the string to trim
    #
    # Nonlocals:
    # - trimmed_string: the trimmed string

    # TODO: Instead of a nonlocal ${trimmed_string}, give output via
    # command substitution using the Bash 5.3 form "${ printf ... ; }".

    # Define the local variable.
    local string

    # Read the argument.
    string="$1"

    # Trim the string and set the nonlocal ${trimmed_string} to it.
    string="${string##+( )}"
    string="${string%%+( )}"
    trimmed_string="${string}"
}

function argparser_fold() {
    # Limit the width of a help message's column to max_col_width by
    # inserting line breaks.
    #
    # Arguments:
    # - $1: the line in the column in which to insert line breaks
    # - $2: the maximum width a column may have
    # - $3: the maximum width a column has yet
    #
    # Nonlocals:
    # - joined_words: the line with introduced line breaks
    # - largest_col_width: the width of the widest line part

    # Define the local variables.
    local col_width
    local len_joined_words
    local len_word
    local line
    local max_col_width
    local word
    local words

    # Read the arguments.
    line="$1"
    max_col_width="$2"
    largest_col_width="$3"

    # Split the column element word by word (on whitespace), such that
    # line breaks aren't inserted into entire words.
    joined_words=""
    col_width=0
    read -r -a words <<< "${line}"

    for word in "${words[@]}"; do
        len_word="${#word}"
        len_joined_words="${#joined_words}"
        if (( len_word > max_col_width && len_joined_words == 0 )); then
            # As the word is too long, print the word and introduce a
            # line break.  Then, reset the column width.
            joined_words+="${word}"
            joined_words+=$'\n'
            col_width=0
        elif (( col_width + len_word > max_col_width )); then
            # As the line with the word appended would be too long,
            # introduce a line break and print the word.  Then, set the
            # column width.
            joined_words+=$'\n'
            joined_words+="${word}"
            col_width="${len_word}"
        elif (( len_joined_words == 0 )); then
            # For the first word, add the word only.  Increase the
            # column width by the word's length.
            joined_words="${word}"
            (( col_width += len_word ))
        else
            # For any other word, add the word and a leading space
            # character, else, the words would be concatenated without
            # separation (the splitting removed any whitespace).
            # Increase the column width appropriately.
            joined_words+=" ${word}"
            (( col_width += len_word + 1 ))
        fi

        # If the current line is wider than the previous ones, set the
        # largest_col_width correspondingly.  Later, this value is used
        # to determine the amount of whitespace between the columns'
        # elements.
        if (( col_width > largest_col_width )); then
            largest_col_width="${col_width}"
        fi
    done
}

function argparser_count() {
    # Count the number of occurences of an element in an array.
    #
    # Arguments:
    # - $1: the element to count
    # - $@: the array where to count the element
    #
    # Nonlocals:
    # - count: the count of the element

    # Define the local variables.
    local element
    local query

    # Read the query element and shift the arguments such that only the
    # array to search through remains.
    query="$1"
    shift

    # Count the number of occurences.
    count=0
    for element in "$@"; do
        if [[ "${element}" == "${query}" ]]; then
            (( count++ ))
        fi
    done
}

function argparser_uniq() {
    # Filter adjacent duplicate entries from an array.
    #
    # Arguments:
    # - $@: the array to filter
    #
    # Output:
    # - the filtered array as string, concatenated and terminated with
    #   null characters

    # Define the local variables.
    local array
    local element
    local prev_element

    # Read the arguments.
    array=("$@")

    # Filter the array and output it.
    prev_element=""
    for element in "${array[@]}"; do
        if [[ "${element}" != "${prev_element}" ]]; then
            printf '%s\0' "${element}"
        fi
        prev_element="${element}"
    done
}

function argparser_quicksort() {
    # Sort an array using the recursive Quicksort algorithm with Tony
    # Hoare's partition scheme.
    #
    # Arguments:
    # - $1: the left boundary of the array bucket
    # - $2: the right boundary of the array bucket
    #
    # Nonlocals:
    # - array: the array to sort

    # Define the local variables.
    local i
    local j
    local left
    local pivot
    local pivot_point
    local right
    local swap

    # Read the arguments.
    left="$1"
    right="$2"

    # Sort the array by Quicksort.
    if (( left < right )); then
        # Set the start indices for the current bucket.  Take the
        # leftmost element as pivot.
        (( i = "${left}" - 1 ))
        (( j = "${right}" + 1 ))
        pivot="${array[left]}"

        while :; do
            # Traverse the array from the left, until a larger element
            # than the pivot has been found.
            (( i++ ))
            while [[ "${array[i]}" < "${pivot}" ]]; do
                (( i++ ))
            done

            # Traverse the array from the right, until a smaller element
            # than the pivot has been found.
            (( j-- ))
            while [[ "${array[j]}" > "${pivot}" ]]; do
                (( j-- ))
            done

            # If the indices have crossed each other, return.
            if (( i >= j )); then
                pivot_point="${j}"
                break
            fi

            # Swap the elements at the current indices.
            swap="${array[i]}"
            array[i]="${array[j]}"
            array[j]="${swap}"
        done

        # Recursively call the Quicksort algorithm to sort the buckets
        # individually.
        argparser_quicksort "${left}" "${pivot_point}"
        argparser_quicksort "$(( pivot_point + 1 ))" "${right}"
    fi
}

function argparser_sort() {
    # Sort an array, internally using the Quicksort algorithm.
    #
    # Arguments:
    # - $1: whether to reverse-sort the array
    # - $@: the array to sort
    #
    # Output:
    # - the sorted array as string, concatenated and terminated with
    #   null characters

    # Define the local variables.
    local array
    local i
    local reverse

    # Read the arguments.
    reverse="$1"
    shift
    array=("$@")

    # Sort the array and output it, possibly after reversing it.
    argparser_quicksort 0 "$(( "${#array[@]}" - 1 ))"
    if [[ "${reverse}" == true ]]; then
        for (( i = "${#array[@]}" - 1; i >= 0; i-- )); do
            printf '%s\0' "${array[i]}"
        done
    else
        printf '%s\0' "${array[@]}"
    fi
}

function argparser_colorize() {
    # Colorize and format the string using ANSI escape sequences.
    #
    # Arguments:
    # - $1: the colors and/or styles to use as comma-separated list
    # - $2: the string to colorize
    # - $3: the file descriptor to write to (1 or 2)
    # - $4: whether to print the colorized string
    #
    # Nonlocals:
    # - style: the color and/or style to colorize the string (if $4 is
    #   false)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_USE_STYLES_IN_FILES (read-only)
    #
    # Output:
    # - the colorized string (if $4 is true)

    # Define the local variables.
    local file_descriptor
    local print_string
    local request
    local requests
    local string
    local -A styles

    # Read the arguments.
    requests="$1"
    string="$2"
    file_descriptor="$3"
    print_string="$4"

    # Define the associative array with colors and styles, and their
    # corresponding Select Graphic Rendition (SGR) ANSI escape sequence
    # codes.
    styles=(
        [black]=30
        [red]=31
        [green]=32
        [yellow]=33
        [blue]=34
        [magenta]=35
        [cyan]=36
        [white]=37
        [normal]=22
        [bold]=1
        [faint]=2
        [italic]=3
        [underline]=4
        [double]=21
        [overline]=53
        [crossed-out]=9
        [blink]=5
        [reverse]=7
    )

    # Split the requested color and/or style on
    # ${ARGPARSER_ARG_DELIMITER_2} characters and replace it with the
    # corresponding escape sequence, if writing to a terminal or the
    # escape sequences shall be included in the file.  The test assumes
    # that argparser_colorize is never run through command substitution,
    # else [[ -t ${file_descriptor} ]] would always be false, i.e., it
    # would impossible to tell if the final STDOUT/STDERR goes to a
    # terminal.
    style=""
    if [[ "${ARGPARSER_USE_STYLES_IN_FILES}" == true \
        || -t "${file_descriptor}" ]]
    then
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a requests \
            <<< "${requests}"
        for request in "${requests[@]}"; do
            style+="\e[${styles[${request}]}m"
        done
    fi

    # Possibly, print the colorized string and reset the color/style.
    if [[ "${print_string}" == true ]]; then
        # shellcheck disable=SC2059  # Escape sequence in variable.
        printf "${style}"
        printf "%s" "${string}"

        if [[ "${ARGPARSER_USE_STYLES_IN_FILES}" == true \
            || -t "${file_descriptor}" ]]
        then
            printf '\e[0m'
        fi
    fi
}

# Define the argparser functions for reading the configuration and
# setting and checking the environment variables.
function argparser_set_internal_vars() {
    # Check that no "environment" variable for internal usage by the
    # argparser is set, then set them.
    #
    # Environment:
    # ARGPARSER_ARGS
    # ARGPARSER_CHECK_ENV_VARS (read-only)
    # ARGPARSER_DICTIONARY
    # ARGPARSER_ERROR_EXIT_CODE
    # ARGPARSER_ERROR_STYLE
    # ARGPARSER_SCRIPT_ARGS
    # ARGPARSER_USE_STYLES_IN_FILES
    # ARGPARSER_VERSION

    # Define the local variables.
    local error_message
    local -a error_messages

    # Check that ${ARGPARSER_ARGS}, ${ARGPARSER_DICTIONARY},
    # ${ARGPARSER_SCRIPT_ARGS}, and ${ARGPARSER_VERSION} are unset, then
    # declare or set them.
    error_messages=( )
    if [[ -v "ARGPARSER_ARGS" ]]; then
        error_message="Error: ARGPARSER_ARGS is an internal variable and must "
        error_message+="not be set."
        error_messages+=("${error_message}")
    else
        declare -g -a ARGPARSER_ARGS
    fi

    if [[ -v "ARGPARSER_DICTIONARY" ]]; then
        error_message="Error: ARGPARSER_DICTIONARY is an internal variable "
        error_message+="and must not be set."
        error_messages+=("${error_message}")
    else
        declare -g -A ARGPARSER_DICTIONARY
    fi

    if [[ -v "ARGPARSER_SCRIPT_ARGS" ]]; then
        error_message="Error: ARGPARSER_SCRIPT_ARGS is an internal variable "
        error_message+="and must not be set."
        error_messages+=("${error_message}")
    else
        declare -g -a ARGPARSER_SCRIPT_ARGS
    fi

    if [[ -v "ARGPARSER_VERSION" ]]; then
        error_message="Error: ARGPARSER_VERSION is an internal variable and "
        error_message+="must not be set.  Did you mean "
        error_message+="\"ARGPARSER_SCRIPT_VERSION\"?"
        error_messages+=("${error_message}")
    else
        ARGPARSER_VERSION=0.1.0
    fi

    # Output an error message for those internal environment variables
    # that have been previously set.
    if (( "${#error_messages[@]}" > 0 )); then
        if [[ ! -v "ARGPARSER_CHECK_ENV_VARS" \
            || "${ARGPARSER_CHECK_ENV_VARS}" != false ]]
        then
            ARGPARSER_ARG_DELIMITER_2=","
            ARGPARSER_ERROR_EXIT_CODE=1
            ARGPARSER_ERROR_STYLE="red,bold,reverse"
            ARGPARSER_USE_STYLES_IN_FILES=false
        fi
        argparser_print_error_or_warning_message "error" false true \
            "${error_messages[@]}"
    fi
}

function argparser_read_configuration() {
    # Read the configuration from the configuration file into the
    # environment variables.
    #
    # Environment:
    # ARGPARSER_ADD_HELP
    # ARGPARSER_ADD_USAGE
    # ARGPARSER_ADD_VERSION
    # ARGPARSER_ALLOW_OPTION_ABBREVIATION
    # ARGPARSER_ALLOW_OPTION_MERGING
    # ARGPARSER_ARG_ARRAY_NAME
    # ARGPARSER_ARG_DEF_FILE
    # ARGPARSER_ARG_DEF_FILE_HAS_HEADER
    # ARGPARSER_ARG_DEF_HAS_HEADER
    # ARGPARSER_ARG_DELIMITER_1
    # ARGPARSER_ARG_DELIMITER_2
    # ARGPARSER_CHECK_ARG_DEFINITION
    # ARGPARSER_CHECK_ENV_VARS
    # ARGPARSER_CONFIGURATION_FILE (read-only)
    # ARGPARSER_COUNT_FLAGS
    # ARGPARSER_ERROR_EXIT_CODE
    # ARGPARSER_ERROR_STYLE
    # ARGPARSER_HELP_EXIT_CODE
    # ARGPARSER_HELP_FILE
    # ARGPARSER_HELP_FILE_INCLUDE_CHAR
    # ARGPARSER_HELP_FILE_KEEP_COMMENTS
    # ARGPARSER_HELP_STYLE
    # ARGPARSER_LANGUAGE
    # ARGPARSER_MAX_COL_WIDTH_1
    # ARGPARSER_MAX_COL_WIDTH_2
    # ARGPARSER_MAX_COL_WIDTH_3
    # ARGPARSER_POSITIONAL_ARG_GROUP
    # ARGPARSER_READ_ARGS
    # ARGPARSER_SCRIPT_NAME
    # ARGPARSER_SCRIPT_VERSION
    # ARGPARSER_SCRIPT_VERSION_EXIT_CODE
    # ARGPARSER_SCRIPT_VERSION_STYLE
    # ARGPARSER_SET_ARGS
    # ARGPARSER_SET_ARRAYS
    # ARGPARSER_SILENCE_ERRORS
    # ARGPARSER_SILENCE_WARNINGS
    # ARGPARSER_TRANSLATION_FILE
    # ARGPARSER_UNSET_ARGS
    # ARGPARSER_UNSET_ENV_VARS
    # ARGPARSER_UNSET_FUNCTIONS
    # ARGPARSER_USAGE_EXIT_CODE
    # ARGPARSER_USAGE_FILE
    # ARGPARSER_USAGE_FILE_INCLUDE_CHAR
    # ARGPARSER_USAGE_FILE_KEEP_COMMENTS
    # ARGPARSER_USAGE_MESSAGE_OPTION_TYPE
    # ARGPARSER_USAGE_MESSAGE_ORIENTATION
    # ARGPARSER_USAGE_STYLE
    # ARGPARSER_USE_LONG_OPTIONS
    # ARGPARSER_USE_SHORT_OPTIONS
    # ARGPARSER_USE_STYLES_IN_FILES
    # ARGPARSER_WARNING_STYLE

    # Define the local variables.
    local error_message
    local -a error_messages
    local file_attributes
    local is_extglob_set
    local line
    local -a lines
    local value
    local var

    # Locally disable errexit and enable extglob.
    local -
    set +o errexit
    is_extglob_set="$(shopt -p extglob)"
    shopt -s extglob

    # Check if the configuration file exists and is readable.  Else,
    # output an error message and exit.  Since at this point of
    # invokation, the environment variables aren't checked, yet, set the
    # needed ones to default values, if ${ARGPARSER_CHECK_ENV_VARS}
    # isn't set to false (and by this, the checking hasn't been
    # explicitly disabled).
    argparser_check_file "${ARGPARSER_CONFIGURATION_FILE}"
    if [[ "${file_attributes}" != "0000" ]]; then
        error_message="Error: The environment variable \"%s\" is set to "
        error_message+="\"%s\", but the referenced file "
        case "${file_attributes}" in
            0001) error_message+="is empty." ;;
            0010) error_message+="is not readable." ;;
            0011) error_message+="is not readable and empty." ;;
            0100) error_message+="is not a regular file." ;;
            0101) error_message+="is not a regular file and empty." ;;
            0110)
                error_message+="is not a regular file and not readable."
                ;;
            0111)
                error_message+="is not a regular file, not readable, and "
                error_message+="empty."
                ;;
            1111) error_message+="does not exist." ;;
        esac
        error_message="${error_message/"%s"/"ARGPARSER_CONFIGURATION_FILE"}"
        error_message="${error_message/"%s"/${ARGPARSER_CONFIGURATION_FILE}}"

        if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
            ARGPARSER_ARG_DELIMITER_2=","
            ARGPARSER_ERROR_EXIT_CODE=1
            ARGPARSER_ERROR_STYLE="red,bold,reverse"
        fi
        argparser_print_error_or_warning_message "error" false true \
            "${error_message}"
    fi

    # Read the configuration file.
    mapfile -t lines < "${ARGPARSER_CONFIGURATION_FILE}"
    error_messages=( )

    for line in "${lines[@]}"; do
        if [[ -z "${line}" || "${line}" == \#* ]]; then
            # Ignore the empty or commented line.
            continue
        elif [[ "${line}" == *( )"args"*( )=* ]]; then
            # Output an error message when the line sets
            # ${ARGPARSER_ARGS}.
            error_message="Error: In the configuration file \"%s\", the line "
            error_message+="\"%s\" sets ARGPARSER_ARGS, which is an "
            error_message+="internal variable and must not be set."

            for var in "${ARGPARSER_CONFIGURATION_FILE}" "${line}"; do
                error_message="${error_message/"%s"/${var}}"
            done
            error_messages+=("${error_message}")
        elif [[ "${line}" == *( )"dictionary"*( )=* ]]; then
            # Output an error message when the line sets
            # ${ARGPARSER_DICTIONARY}.
            error_message="Error: In the configuration file \"%s\", the line "
            error_message+="\"%s\" sets ARGPARSER_DICTIONARY, which is an "
            error_message+="internal variable and must not be set."

            for var in "${ARGPARSER_CONFIGURATION_FILE}" "${line}"; do
                error_message="${error_message/"%s"/${var}}"
            done
            error_messages+=("${error_message}")
        elif [[ "${line}" == *( )"script-args"*( )=* ]]; then
            # Output an error message when the line sets
            # ${ARGPARSER_SCRIPT_ARGS}.
            error_message="Error: In the configuration file \"%s\", the line "
            error_message+="\"%s\" sets ARGPARSER_SCRIPT_ARGS, which is an "
            error_message+="internal variable and must not be set."

            for var in "${ARGPARSER_CONFIGURATION_FILE}" "${line}"; do
                error_message="${error_message/"%s"/${var}}"
            done
            error_messages+=("${error_message}")
        elif [[ "${line}" == *( )"version"*( )=* ]]; then
            # Output an error message when the line sets
            # ${ARGPARSER_VERSION}.
            error_message="Error: In the configuration file \"%s\", the line "
            error_message+="\"%s\" sets ARGPARSER_VERSION, which is an "
            error_message+="internal variable and must not be set."

            for var in "${ARGPARSER_CONFIGURATION_FILE}" "${line}"; do
                error_message="${error_message/"%s"/${var}}"
            done
            error_messages+=("${error_message}")
        elif [[ "${line}" =~ = ]]; then
            # Set the variable name as shortest part before an equals
            # sign ("="), strip leading and trailing spaces, replace
            # hyphens and spaces by underscores, capitalize the variable
            # name, and prepend the string "ARGPARSER_".  Then, extract
            # the value as longest part after the equals sign and strip
            # leading and trailing spaces and a double quote each.
            var="${line%%=*}"
            var="${var##+( )}"
            var="${var%%+( )}"
            var="${var//-/_}"
            var="${var// /_}"
            var="ARGPARSER_${var^^}"

            value="${line#*=}"
            value="${value##+( )}"
            value="${value%%+( )}"
            value="${value#\"}"
            value="${value%\"}"

            # Set the environment variable, as long as it isn't already
            # set by the calling script or environment to prevent
            # overriding it.  For ${ARGPARSER_SCRIPT_NAME}, set the
            # value to the basename of the script's $0 if an empty
            # string is given.
            if [[ ! -v "${var}" ]]; then
                if [[ "${var}" == "ARGPARSER_SCRIPT_NAME" && -z "${value}" ]]
                then
                    value="${0##*/}"
                fi
                declare -g "${var}"="${value}"
            fi
        else
            # Output an error message when the line doesn't contain an
            # equals sign ("=").
            error_message="Error: In the configuration file \"%s\", the line "
            error_message+="\"%s\" doesn't contain an equals sign (\"=\"), "
            error_message+="nor is it empty or commented."

            for var in "${ARGPARSER_CONFIGURATION_FILE}" "${line}"; do
                error_message="${error_message/"%s"/${var}}"
            done
            error_messages+=("${error_message}")
        fi
    done

    # Depending on the value of ${is_extglob_set}, which uses shopt's
    # feature of storing the extglob state in a format reusable as
    # input, possibly disable extglob.
    eval "${is_extglob_set}"

    # Sort, filter, colorize, and print all error messages, then exit,
    # as the environment variables should be correctly read.
    if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
        ARGPARSER_ARG_DELIMITER_2=","
        ARGPARSER_ERROR_EXIT_CODE=1
        ARGPARSER_ERROR_STYLE="red,bold,reverse"
    fi
    argparser_print_error_or_warning_message "error" true true \
        "${error_messages[@]}"
}

function argparser_set_env_vars() {
    # Set the argparser environment variables, as long as they aren't
    # already set by the calling script or environment to prevent
    # overriding them.
    #
    # Arguments:
    # - $@: the command line upon sourcing the argparser
    #
    # Environment:
    # ARGPARSER_ADD_HELP
    # ARGPARSER_ADD_USAGE
    # ARGPARSER_ADD_VERSION
    # ARGPARSER_ALLOW_OPTION_ABBREVIATION
    # ARGPARSER_ALLOW_OPTION_MERGING
    # ARGPARSER_ARG_ARRAY_NAME
    # ARGPARSER_ARG_DEF_FILE
    # ARGPARSER_ARG_DEF_FILE_HAS_HEADER
    # ARGPARSER_ARG_DEF_HAS_HEADER
    # ARGPARSER_ARG_DELIMITER_1
    # ARGPARSER_ARG_DELIMITER_2
    # ARGPARSER_ARGS
    # ARGPARSER_CHECK_ARG_DEFINITION
    # ARGPARSER_CHECK_ENV_VARS
    # ARGPARSER_CONFIGURATION_FILE
    # ARGPARSER_COUNT_FLAGS
    # ARGPARSER_ERROR_EXIT_CODE
    # ARGPARSER_ERROR_STYLE
    # ARGPARSER_HELP_EXIT_CODE
    # ARGPARSER_HELP_FILE
    # ARGPARSER_HELP_FILE_INCLUDE_CHAR
    # ARGPARSER_HELP_FILE_KEEP_COMMENTS
    # ARGPARSER_HELP_STYLE
    # ARGPARSER_LANGUAGE
    # ARGPARSER_MAX_COL_WIDTH_1
    # ARGPARSER_MAX_COL_WIDTH_2
    # ARGPARSER_MAX_COL_WIDTH_3
    # ARGPARSER_POSITIONAL_ARG_GROUP
    # ARGPARSER_READ_ARGS
    # ARGPARSER_SCRIPT_ARGS
    # ARGPARSER_SCRIPT_NAME
    # ARGPARSER_SCRIPT_VERSION
    # ARGPARSER_SCRIPT_VERSION_EXIT_CODE
    # ARGPARSER_SCRIPT_VERSION_STYLE
    # ARGPARSER_SET_ARGS
    # ARGPARSER_SET_ARRAYS
    # ARGPARSER_SILENCE_ERRORS
    # ARGPARSER_SILENCE_WARNINGS
    # ARGPARSER_TRANSLATION_FILE
    # ARGPARSER_UNSET_ARGS
    # ARGPARSER_UNSET_ENV_VARS
    # ARGPARSER_UNSET_FUNCTIONS
    # ARGPARSER_USAGE_EXIT_CODE
    # ARGPARSER_USAGE_FILE
    # ARGPARSER_USAGE_FILE_INCLUDE_CHAR
    # ARGPARSER_USAGE_FILE_KEEP_COMMENTS
    # ARGPARSER_USAGE_MESSAGE_OPTION_TYPE
    # ARGPARSER_USAGE_MESSAGE_ORIENTATION
    # ARGPARSER_USAGE_STYLE
    # ARGPARSER_USE_LONG_OPTIONS
    # ARGPARSER_USE_SHORT_OPTIONS
    # ARGPARSER_USE_STYLES_IN_FILES
    # ARGPARSER_VERSION (read-only)
    # ARGPARSER_WARNING_STYLE

    # Define the local variables.
    local arg
    local arg_key
    local -a args
    local value

    # As the argparser can be sourced with command-line arguments,
    # separate them from the script's command line.  Any argument until
    # the first "--" is seen as argument to the argparser.  Lastly,
    # shift also the "--" and set ${ARGPARSER_SCRIPT_ARGS} to the
    # remainder of the command line.
    # In order to show the need for the script's command line in the
    # argparser's help and usage message, ${ARGPARSER_SCRIPT_ARGS} is
    # added to the argparser's arguments definition as mandatory
    # positional argument.  Since using its actual value would mean that
    # upon parsing, a "++" in the script's arguments would be
    # interpreted as sign to re-evaluate the arguments as keyword
    # arguments for the argparser (and not for the script), set the
    # string "argparser" as dummy value for the positional argument.  As
    # only keyword arguments are set as environment variables, below,
    # the actual value of ${ARGPARSER_SCRIPT_ARGS} won't be overridden
    # and kept as the script's command line.
    args=( )

    # shellcheck disable=SC2190  # Indexed, not associative array.
    while (( "$#" > 0 )) && [[ -n "$1" && "$1" != "--" ]]; do
        args+=("$1")
        shift
    done
    if (( "$#" > 0 )) && [[ -n "$1" && "$1" == "--" ]]; then
        shift
    fi
    ARGPARSER_SCRIPT_ARGS=("$@")
    # shellcheck disable=SC2190  # Indexed, not associative array.
    args+=("--" "argparser")

    # Set all non-internal environment variables by reading the
    # argparser's command line given upon sourcing the argparser, using
    # the argparser itself with default values for all environment
    # variables (which are yet to be set).
    ARGPARSER_ARGS=(
        "id                                  |short_opts |long_opts                 |val_names    |defaults             |choices    |type |arg_no |arg_group |notes |help                                                                                                    "
        "ARGPARSER_ADD_HELP                  |-          |add-help                  |-            |true                 |-          |bool |0      |Options   |-     |add -h, --help as flags to call the help message                                                        "
        "ARGPARSER_ADD_USAGE                 |-          |add-usage                 |-            |true                 |-          |bool |0      |Options   |-     |add -u, --usage as flags to call the usage message                                                      "
        "ARGPARSER_ADD_VERSION               |-          |add-version               |-            |true                 |-          |bool |0      |Options   |-     |add -V, --version as flags to call the version message                                                  "
        "ARGPARSER_ALLOW_OPTION_ABBREVIATION |-          |allow-option-abbreviation |-            |false                |-          |bool |0      |Options   |-     |allow the user to give long option names in abbreviated form                                            "
        "ARGPARSER_ALLOW_OPTION_MERGING      |-          |allow-option-merging      |-            |false                |-          |bool |0      |Options   |-     |allow the user to give short option names in merged (concatenated) form                                 "
        "ARGPARSER_ARG_ARRAY_NAME            |-          |arg-array-name            |NAME         |args                 |-          |str  |1      |Options   |-     |the indexed array for the raw arguments and the associative array for the parsed arguments              "
        "ARGPARSER_ARG_DEF_FILE              |-          |arg-def-file              |FILE         |''                   |-          |str  |1      |Options   |-     |the path to a file holding the definition of the arguments                                              "
        "ARGPARSER_ARG_DEF_FILE_HAS_HEADER   |-          |arg-def-file-has-header   |-            |true                 |-          |bool |0      |Options   |-     |whether the arguments definition file has a header explaining the columns                               "
        "ARGPARSER_ARG_DEF_HAS_HEADER        |-          |arg-def-has-header        |-            |true                 |-          |bool |0      |Options   |-     |whether the arguments definition in the script has a header explaining the columns                      "
        "ARGPARSER_ARG_DELIMITER_1           |-          |arg-delimiter-1           |CHAR         |:                    |-          |char |1      |Options   |-     |the primary delimiter that separates the fields in the arguments definition                             "
        "ARGPARSER_ARG_DELIMITER_2           |-          |arg-delimiter-2           |CHAR         |,                    |-          |char |1      |Options   |-     |the secondary delimiter that separates the elements of sequences in the arguments definition            "
        "ARGPARSER_CHECK_ARG_DEFINITION      |-          |check-arg-definition      |-            |false                |-          |bool |0      |Options   |-     |check if the arguments definition is consistent                                                         "
        "ARGPARSER_CHECK_ENV_VARS            |-          |check-env-vars            |-            |false                |-          |bool |0      |Options   |-     |check if the argparser environment variables accord to their definition                                 "
        "ARGPARSER_CONFIGURATION_FILE        |-          |configuration-file        |FILE         |''                   |-          |str  |1      |Options   |-     |the path to a file holding the argparser configuration                                                  "
        "ARGPARSER_COUNT_FLAGS               |-          |count-flags               |-            |false                |-          |bool |0      |Options   |-     |count flags instead of setting them to true or false based on the last prefix used on the command line  "
        "ARGPARSER_ERROR_EXIT_CODE           |-          |error-exit-code           |INT          |1                    |-          |int  |1      |Options   |-     |the exit code when errors occurred upon parsing                                                         "
        "ARGPARSER_ERROR_STYLE               |-          |error-style               |STYLE        |red,bold,reverse     |-          |str  |+      |Options   |-     |the color and style specification for error messages                                                    "
        "ARGPARSER_HELP_EXIT_CODE            |-          |help-exit-code            |INT          |0                    |-          |int  |1      |Options   |-     |the exit code for help messages                                                                         "
        "ARGPARSER_HELP_FILE                 |-          |help-file                 |FILE         |''                   |-          |str  |1      |Options   |-     |the path to a file holding the extended help message                                                    "
        "ARGPARSER_HELP_FILE_INCLUDE_CHAR    |-          |help-file-include-char    |CHAR         |@                    |-          |char |1      |Options   |-     |the character that introduces an include directive in an ARGPARSER_HELP_FILE                            "
        "ARGPARSER_HELP_FILE_KEEP_COMMENTS   |-          |help-file-keep-comments   |-            |false                |-          |bool |0      |Options   |-     |keep commented lines in the help file                                                                   "
        "ARGPARSER_HELP_STYLE                |-          |help-style                |STYLE        |italic               |-          |str  |+      |Options   |-     |the color and style specification for help messages                                                     "
        "ARGPARSER_LANGUAGE                  |-          |language                  |-            |en                   |-          |str  |1      |Options   |-     |the language in which to localize the help and usage messages                                           "
        "ARGPARSER_MAX_COL_WIDTH_1           |-          |max-col-width-1           |INT          |5                    |-          |uint |1      |Options   |-     |the maximum column width of the first column in the help message                                        "
        "ARGPARSER_MAX_COL_WIDTH_2           |-          |max-col-width-2           |INT          |33                   |-          |uint |1      |Options   |-     |the maximum column width of the second column in the help message                                       "
        "ARGPARSER_MAX_COL_WIDTH_3           |-          |max-col-width-3           |INT          |39                   |-          |uint |1      |Options   |-     |the maximum column width of the third column in the help message                                        "
        "ARGPARSER_POSITIONAL_ARG_GROUP      |-          |positional-arg-group      |NAME         |Positional arguments |-          |str  |1      |Options   |-     |the name of the argument group holding all positional arguments                                         "
        "ARGPARSER_READ_ARGS                 |-          |read-args                 |-            |true                 |-          |bool |0      |Options   |-     |read the arguments and parse them to ARGPARSER_ARG_ARRAY_NAME                                           "
        "ARGPARSER_SCRIPT_ARGS               |-          |-                         |COMMAND LINE |-                    |-          |str  |+      |Options   |-     |the indexed array in which the argparser stores the script's command line upon parsing its own arguments"
        "ARGPARSER_SCRIPT_NAME               |-          |script-name               |NAME         |''                   |-          |str  |1      |Options   |-     |the script's name for the help, usage, version, error, and warning messages                             "
        "ARGPARSER_SCRIPT_VERSION            |-          |script-version            |-            |1.0.0                |-          |str  |1      |Options   |-     |the script's version number for the version message                                                     "
        "ARGPARSER_SCRIPT_VERSION_EXIT_CODE  |-          |script-version-exit-code  |INT          |0                    |-          |int  |1      |Options   |-     |the exit code for version messages                                                                      "
        "ARGPARSER_SCRIPT_VERSION_STYLE      |-          |script-version-style      |STYLE        |bold                 |-          |str  |+      |Options   |-     |the color and style specification for version messages                                                  "
        "ARGPARSER_SET_ARGS                  |-          |set-args                  |-            |true                 |-          |bool |0      |Options   |-     |set the arguments from ARGPARSER_ARG_ARRAY_NAME as variables in the script's scope                      "
        "ARGPARSER_SET_ARRAYS                |-          |set-arrays                |-            |true                 |-          |bool |0      |Options   |-     |set arguments intended to have multiple values as indexed array                                         "
        "ARGPARSER_SILENCE_ERRORS            |-          |silence-errors            |-            |false                |-          |bool |0      |Options   |-     |silence the emission (output) of error messages                                                         "
        "ARGPARSER_SILENCE_WARNINGS          |-          |silence-warnings          |-            |false                |-          |bool |0      |Options   |-     |silence the emission (output) of warning messages                                                       "
        "ARGPARSER_TRANSLATION_FILE          |-          |translation-file          |FILE         |''                   |-          |str  |1      |Options   |-     |the path to a simplified YAML file holding the translation to ARGPARSER_LANGUAGE                        "
        "ARGPARSER_UNSET_ARGS                |-          |unset-args                |-            |true                 |-          |bool |0      |Options   |-     |unset (remove) all command-line arguments given to the script                                           "
        "ARGPARSER_UNSET_ENV_VARS            |-          |unset-env-vars            |-            |true                 |-          |bool |0      |Options   |-     |unset (remove) the argparser environment variables from the environment                                 "
        "ARGPARSER_UNSET_FUNCTIONS           |-          |unset-functions           |-            |true                 |-          |bool |0      |Options   |-     |unset (remove) the argparser functions from the environment                                             "
        "ARGPARSER_USAGE_EXIT_CODE           |-          |usage-exit-code           |INT          |0                    |-          |int  |1      |Options   |-     |the exit code for usage messages                                                                        "
        "ARGPARSER_USAGE_FILE                |-          |usage-file                |FILE         |''                   |-          |str  |1      |Options   |-     |the path to a file holding the extended usage message                                                   "
        "ARGPARSER_USAGE_FILE_INCLUDE_CHAR   |-          |usage-file-include-char   |CHAR         |@                    |-          |char |1      |Options   |-     |the character that introduces an include directive in an ARGPARSER_USAGE_FILE                           "
        "ARGPARSER_USAGE_FILE_KEEP_COMMENTS  |-          |usage-file-keep-comments  |-            |false                |-          |bool |0      |Options   |-     |keep commented lines in the usage file                                                                  "
        "ARGPARSER_USAGE_MESSAGE_OPTION_TYPE |-          |usage-message-option-type |-            |short                |long,short |str  |1      |Options   |-     |use short or long option names in usage messages                                                        "
        "ARGPARSER_USAGE_MESSAGE_ORIENTATION |-          |usage-message-orientation |-            |row                  |row,column |str  |1      |Options   |-     |output the positional and keyword arguments in usage messages in a row or in a column                   "
        "ARGPARSER_USAGE_STYLE               |-          |usage-style               |STYLE        |italic               |-          |str  |+      |Options   |-     |the color and style specification for usage messages                                                    "
        "ARGPARSER_USE_LONG_OPTIONS          |-          |use-long-options          |-            |true                 |-          |bool |0      |Options   |-     |use the long options for parsing                                                                        "
        "ARGPARSER_USE_SHORT_OPTIONS         |-          |use-short-options         |-            |true                 |-          |bool |0      |Options   |-     |use the short options for parsing                                                                       "
        "ARGPARSER_USE_STYLES_IN_FILES       |-          |use-styles-in-files       |-            |false                |-          |bool |0      |Options   |-     |use the colors and styles when STDOUT/STDERR is not a terminal                                          "
        "ARGPARSER_WARNING_STYLE             |-          |warning-style             |STYLE        |red,bold             |-          |str  |+      |Options   |-     |the color and style specification for warning messages                                                  "
    )

    # # shellcheck source=argparser
    ARGPARSER_ADD_HELP=true \
        ARGPARSER_ADD_USAGE=true \
        ARGPARSER_ADD_VERSION=true \
        ARGPARSER_ALLOW_OPTION_ABBREVIATION=false \
        ARGPARSER_ALLOW_OPTION_MERGING=false \
        ARGPARSER_ARG_ARRAY_NAME="ARGPARSER_ARGS" \
        ARGPARSER_ARG_DEF_FILE="" \
        ARGPARSER_ARG_DEF_FILE_HAS_HEADER=true \
        ARGPARSER_ARG_DEF_HAS_HEADER=true \
        ARGPARSER_ARG_DELIMITER_1="|" \
        ARGPARSER_ARG_DELIMITER_2="," \
        ARGPARSER_CHECK_ARG_DEFINITION=false \
        ARGPARSER_CHECK_ENV_VARS=false \
        ARGPARSER_CONFIGURATION_FILE="" \
        ARGPARSER_COUNT_FLAGS=false \
        ARGPARSER_ERROR_EXIT_CODE=1 \
        ARGPARSER_ERROR_STYLE="red,bold,reverse" \
        ARGPARSER_HELP_EXIT_CODE=0 \
        ARGPARSER_HELP_FILE="" \
        ARGPARSER_HELP_FILE_INCLUDE_CHAR="@" \
        ARGPARSER_HELP_FILE_KEEP_COMMENTS=false \
        ARGPARSER_HELP_STYLE="italic" \
        ARGPARSER_LANGUAGE="en" \
        ARGPARSER_MAX_COL_WIDTH_1=5 \
        ARGPARSER_MAX_COL_WIDTH_2=33 \
        ARGPARSER_MAX_COL_WIDTH_3=39 \
        ARGPARSER_POSITIONAL_ARG_GROUP="Positional arguments" \
        ARGPARSER_READ_ARGS=true \
        ARGPARSER_SCRIPT_NAME="${BASH_SOURCE[0]##*/}" \
        ARGPARSER_SCRIPT_VERSION="${ARGPARSER_VERSION}" \
        ARGPARSER_SCRIPT_VERSION_EXIT_CODE=0 \
        ARGPARSER_SCRIPT_VERSION_STYLE="bold" \
        ARGPARSER_SET_ARGS=false \
        ARGPARSER_SET_ARRAYS=false \
        ARGPARSER_SILENCE_ERRORS=false \
        ARGPARSER_SILENCE_WARNINGS=false \
        ARGPARSER_TRANSLATION_FILE="" \
        ARGPARSER_UNSET_ARGS=true \
        ARGPARSER_UNSET_ENV_VARS=false \
        ARGPARSER_UNSET_FUNCTIONS=false \
        ARGPARSER_USAGE_EXIT_CODE=0 \
        ARGPARSER_USAGE_FILE="" \
        ARGPARSER_USAGE_FILE_INCLUDE_CHAR="@" \
        ARGPARSER_USAGE_FILE_KEEP_COMMENTS=false \
        ARGPARSER_USAGE_MESSAGE_OPTION_TYPE="long" \
        ARGPARSER_USAGE_MESSAGE_ORIENTATION="column" \
        ARGPARSER_USAGE_STYLE="italic" \
        ARGPARSER_USE_LONG_OPTIONS=true \
        ARGPARSER_USE_SHORT_OPTIONS=false \
        ARGPARSER_USE_STYLES_IN_FILES=false \
        ARGPARSER_WARNING_STYLE="red,bold" \
        source "${BASH_SOURCE[0]}" "${args[@]}"

    # Set the environment variables that aren't set yet as global
    # variables.  For all environment variables that weren't given by
    # neither a config file, nor as an environment variable assignment,
    # nor as a command-line parameter to the argparser, use the default
    # value the argparser has assigned.  If the environment variable has
    # been given before, check if it was also given on the command line,
    # then override the previous value, else, keep the previous value.
    # By this, the command-line parameters have a higher importance than
    # environment variables. For those environment variables whose
    # default is given as "''" (two single quotes), set the value to the
    # empty string.  For ${ARGPARSER_SCRIPT_NAME}, set the value to the
    # basename of the script's $0, if an empty string is given.
    for arg_key in "${!ARGPARSER_ARGS[@]}"; do
        if [[ -v "${arg_key}" ]]; then
            # The environment variable has already been set.  Override
            # it if it was also given on the command line.
            for arg in "${args[@]}"; do
                # Set the variable name as shortest part before an
                # equals sign ("="), strip the leading hyphens, replace
                # inner hyphens by underscores, capitalize the variable
                # name, and prepend the string "ARGPARSER_".
                arg="${arg%%=*}"
                arg="${arg#--}"
                arg="${arg//-/_}"
                arg="ARGPARSER_${arg^^}"

                # If the command-line argument is the current
                # environment variable, override its value with the one
                # given on the command line, which was parsed by the
                # argparser.
                if [[ "${arg}" == "${arg_key}" ]]; then
                    value="${ARGPARSER_ARGS[${arg_key}]}"
                    if [[ "${value}" == "''" ]]; then
                        if [[ "${arg_key}" == "ARGPARSER_SCRIPT_NAME" ]]; then
                            value="${0##*/}"
                        else
                            value=""
                        fi
                    fi
                    declare -g "${arg_key}"="${value}"
                    break
                fi
            done
        else
            # The environment variable is yet unset, so set it to the
            # value the argparser has set upon parsing, i.e., either the
            # value from the command line, or, if absent, the default
            # value.
            value="${ARGPARSER_ARGS[${arg_key}]}"
            if [[ "${value}" == "''" ]]; then
                if [[ "${arg_key}" == "ARGPARSER_SCRIPT_NAME" ]]; then
                    value="${0##*/}"
                else
                    value=""
                fi
            fi
            declare -g "${arg_key}"="${value}"
        fi
    done
}

function argparser_check_env_vars() {
    # Check if the argparser envirnoment variables accord to their
    # definition.  This should always be true for production scripts,
    # but maybe not while testing, and also not if the user is allowed
    # to set the variables himself.
    #
    # The following environment variables are unchecked:
    # - ARGPARSER_ARGS (auto-set)
    # - ARGPARSER_DICTIONARY (checked earlier / auto-set)
    # - ARGPARSER_LANGUAGE (arbitrary value)
    # - ARGPARSER_POSITIONAL_ARG_GROUP (arbitrary value)
    # - ARGPARSER_SCRIPT_ARGS (auto-set)
    # - ARGPARSER_SCRIPT_NAME (arbitrary value)
    # - ARGPARSER_SCRIPT_VERSION (arbitrary value)
    # - ARGPARSER_VERSION (auto-set)
    #
    # The following environment variables are only checked for mutual
    # exclusivity with other environment variables:
    # - ARGPARSER_CONFIGURATION_FILE (checked earlier)
    # - ARGPARSER_TRANSLATION_FILE (checked earlier)
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    # - ARGPARSER_ALLOW_OPTION_ABBREVIATION (read-only)
    # - ARGPARSER_ALLOW_OPTION_MERGING (read-only)
    # - ARGPARSER_ARG_ARRAY_NAME (read-only)
    # - ARGPARSER_ARG_DEF_FILE (read-only)
    # - ARGPARSER_ARG_DEF_FILE_HAS_HEADER (read-only)
    # - ARGPARSER_ARG_DEF_HAS_HEADER (read-only)
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_CHECK_ARG_DEFINITION (read-only)
    # - ARGPARSER_CHECK_ENV_VARS (read-only)
    # - ARGPARSER_CONFIGURATION_FILE (read-only)
    # - ARGPARSER_COUNT_FLAGS (read-only)
    # - ARGPARSER_ERROR_EXIT_CODE
    # - ARGPARSER_ERROR_STYLE
    # - ARGPARSER_HELP_EXIT_CODE (read-only)
    # - ARGPARSER_HELP_FILE (read-only)
    # - ARGPARSER_HELP_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_HELP_FILE_KEEP_COMMENTS (read-only)
    # - ARGPARSER_HELP_STYLE (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_1 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_2 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_3 (read-only)
    # - ARGPARSER_READ_ARGS (read-only)
    # - ARGPARSER_SCRIPT_VERSION_EXIT_CODE (read-only)
    # - ARGPARSER_SCRIPT_VERSION_STYLE (read-only)
    # - ARGPARSER_SET_ARGS (read-only)
    # - ARGPARSER_SET_ARRAYS (read-only)
    # - ARGPARSER_SILENCE_ERRORS (read-only)
    # - ARGPARSER_SILENCE_WARNINGS (read-only)
    # - ARGPARSER_TRANSLATION_FILE (read-only)
    # - ARGPARSER_UNSET_ARGS (read-only)
    # - ARGPARSER_UNSET_ENV_VARS (read-only)
    # - ARGPARSER_UNSET_FUNCTIONS (read-only)
    # - ARGPARSER_USAGE_EXIT_CODE (read-only)
    # - ARGPARSER_USAGE_FILE (read-only)
    # - ARGPARSER_USAGE_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_USAGE_FILE_KEEP_COMMENTS (read-only)
    # - ARGPARSER_USAGE_MESSAGE_OPTION_TYPE (read-only)
    # - ARGPARSER_USAGE_MESSAGE_ORIENTATION (read-only)
    # - ARGPARSER_USAGE_STYLE (read-only)
    # - ARGPARSER_USE_LONG_OPTIONS (read-only)
    # - ARGPARSER_USE_SHORT_OPTIONS (read-only)
    # - ARGPARSER_USE_STYLES_IN_FILES (read-only)
    # - ARGPARSER_WARNING_STYLE (read-only)

    # Define the local variables.
    local error_message
    local -a error_messages
    local file_attributes
    local i
    local translation
    local var
    local var_1
    local var_2
    local -a vars

    # Check if all environment variables expected to be booleans are
    # true or false.  Else, output an error message.
    error_messages=( )
    vars=(
        ARGPARSER_ADD_HELP
        ARGPARSER_ADD_USAGE
        ARGPARSER_ADD_VERSION
        ARGPARSER_ALLOW_OPTION_ABBREVIATION
        ARGPARSER_ALLOW_OPTION_MERGING
        ARGPARSER_ARG_DEF_FILE_HAS_HEADER
        ARGPARSER_ARG_DEF_HAS_HEADER
        ARGPARSER_CHECK_ARG_DEFINITION
        ARGPARSER_CHECK_ENV_VARS
        ARGPARSER_COUNT_FLAGS
        ARGPARSER_HELP_FILE_KEEP_COMMENTS
        ARGPARSER_READ_ARGS
        ARGPARSER_SET_ARGS
        ARGPARSER_SET_ARRAYS
        ARGPARSER_SILENCE_ERRORS
        ARGPARSER_SILENCE_WARNINGS
        ARGPARSER_UNSET_ARGS
        ARGPARSER_UNSET_ENV_VARS
        ARGPARSER_UNSET_FUNCTIONS
        ARGPARSER_USAGE_FILE_KEEP_COMMENTS
        ARGPARSER_USE_LONG_OPTIONS
        ARGPARSER_USE_SHORT_OPTIONS
        ARGPARSER_USE_STYLES_IN_FILES
    )
    for var in "${vars[@]}"; do
        if ! argparser_is_variable_bool "${!var}"; then
            error_message="Error: The environment variable \"%s\" is set to "
            error_message+="\"%s\", but must be a boolean, i.e., true or "
            error_message+="false."

            argparser_translate "Error env var bool" "${error_message}" \
                "${var}" "${!var}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables expected to be characters are
    # one-character strings.  Else, output an error message.
    vars=(
        ARGPARSER_ARG_DELIMITER_1
        ARGPARSER_ARG_DELIMITER_2
        ARGPARSER_HELP_FILE_INCLUDE_CHAR
        ARGPARSER_USAGE_FILE_INCLUDE_CHAR
    )
    for var in "${vars[@]}"; do
        if ! argparser_is_variable_char "${!var}"; then
            error_message="Error: The environment variable \"%s\" is set to "
            error_message+="\"%s\", but must be a character, i.e., a string "
            error_message+="comprising one printable ASCII character."

            argparser_translate "Error env var char" "${error_message}" \
                "${var}" "${!var}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables to be used as Bash variable
    # identifiers start with a letter or underscore and contain only
    # letters, digits, and underscores.  Else, output an error message.
    vars=(
        ARGPARSER_ARG_ARRAY_NAME
    )
    for var in "${vars[@]}"; do
        if ! argparser_is_variable_identifier "${!var}"; then
            error_message="Error: The environment variable \"%s\" is set to "
            error_message+="\"%s\", but designed to be used as Bash variable "
            error_message+="identifier, i.e., its value must start with a "
            error_message+="letter or underscore and contain only letters, "
            error_message+="digits, and underscores."

            argparser_translate "Error env var identifier" "${error_message}" \
                "${var}" "${!var}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables expected to be integers are
    # only digits, possibly with a leading sign.  Else, output an error
    # message.
    vars=(
        ARGPARSER_ERROR_EXIT_CODE
        ARGPARSER_HELP_EXIT_CODE
        ARGPARSER_SCRIPT_VERSION_EXIT_CODE
        ARGPARSER_USAGE_EXIT_CODE
    )
    for var in "${vars[@]}"; do
        if ! argparser_is_variable_int "${!var}"; then
            error_message="Error: The environment variable \"%s\" is set to "
            error_message+="\"%s\", but must be an integer, i.e., comprise "
            error_message+="only digits and possibly a leading sign."

            argparser_translate "Error env var int" "${error_message}" \
                "${var}" "${!var}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables expected to be unsigned
    # integers are only digits.  Else, output an error message.
    vars=(
        ARGPARSER_MAX_COL_WIDTH_1
        ARGPARSER_MAX_COL_WIDTH_2
        ARGPARSER_MAX_COL_WIDTH_3
    )
    for var in "${vars[@]}"; do
        if ! argparser_is_variable_uint "${!var}"; then
            error_message="Error: The environment variable \"%s\" is set to "
            error_message+="\"%s\", but must be an unsigned integer, i.e., "
            error_message+="comprise only digits and no sign."

            argparser_translate "Error env var uint" "${error_message}" \
                "${var}" "${!var}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables expected to point to files have
    # the referenced file existing, readable, and with a size greater
    # than 0 bytes.  Else, output an error message.
    vars=(
        ARGPARSER_ARG_DEF_FILE
        ARGPARSER_HELP_FILE
        ARGPARSER_USAGE_FILE
    )
    for var in "${vars[@]}"; do
        argparser_check_file "${!var}"
        if [[ -n "${!var}" && "${file_attributes}" != "0000" ]]; then
            error_message="Error: The environment variable \"%s\" is set to "
            error_message+="\"%s\", but the referenced file "
            case "${file_attributes}" in
                0001) error_message+="is empty." ;;
                0010) error_message+="is not readable." ;;
                0011) error_message+="is not readable and empty." ;;
                0100) error_message+="is not a regular file." ;;
                0101) error_message+="is not a regular file and empty." ;;
                0110)
                    error_message+="is not a regular file and not readable."
                    ;;
                0111)
                    error_message+="is not a regular file, not readable, and "
                    error_message+="empty."
                    ;;
                1111) error_message+="does not exist." ;;
            esac

            argparser_translate "Error env var file ${file_attributes}" \
                "${error_message}" "${var}" "${!var}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables with a limited set of allowed
    # values have their values lying in them.  Else, output an error
    # message.
    # First, check if all environment variables for styles only have
    # values supported by argparser_colorize.
    vars=(
        ARGPARSER_ERROR_STYLE
        ARGPARSER_HELP_STYLE
        ARGPARSER_SCRIPT_VERSION_STYLE
        ARGPARSER_USAGE_STYLE
        ARGPARSER_WARNING_STYLE
    )
    for var in "${vars[@]}"; do
        if ! argparser_check_color_or_style "${!var}"; then
            error_message="Error: The environment variable \"%s\" is set to "
            error_message+="\"%s\", but the values must lie in {black, red, "
            error_message+="green, yellow, blue, magenta, cyan, white} for "
            error_message+="colors and in {normal, bold, faint, italic, "
            error_message+="underline, double, overline, crossed-out, blink, "
            error_message+="reverse} for styles."

            argparser_translate "Error env var styles" "${error_message}" \
                "${var}" "${!var}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi
    done

    # Then, check the option type for usage messages.
    if [[ "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" != "long" \
        && "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" != "short" ]]
    then
        error_message="Error: The environment variable "
        error_message+="\"ARGPARSER_USAGE_MESSAGE_OPTION_TYPE\" must be "
        error_message+="either set to \"long\" or \"short\", but is \"%s\"."

        argparser_translate "Error env var option type" "${error_message}" \
            "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}"
        error_message="${translation}"
        error_messages+=("${error_message}")
    fi

    # Then, check the orientation for usage messages.
    if [[ "${ARGPARSER_USAGE_MESSAGE_ORIENTATION}" != "row" \
        && "${ARGPARSER_USAGE_MESSAGE_ORIENTATION}" != "column" ]]
    then
        error_message="Error: The environment variable "
        error_message+="\"ARGPARSER_USAGE_MESSAGE_ORIENTATION\" must be "
        error_message+="either set to \"row\" or \"column\", but is \"%s\"."

        argparser_translate "Error env var orientation" "${error_message}" \
            "${ARGPARSER_USAGE_MESSAGE_ORIENTATION}"
        error_message="${translation}"
        error_messages+=("${error_message}")
    fi

    # Check the environment variables with mutually exclusive values.
    # First, check that the argument definition delimiters are
    # different.
    if [[ "${ARGPARSER_ARG_DELIMITER_1}" == "${ARGPARSER_ARG_DELIMITER_2}" ]]
    then
        error_message="Error: The environment variables "
        error_message+="\"ARGPARSER_ARG_DELIMITER_1\" and "
        error_message+="\"ARGPARSER_ARG_DELIMITER_2\" must have different "
        error_message+="values."

        argparser_translate "Error env var delimiters" "${error_message}"
        error_message="${translation}"
        error_messages+=("${error_message}")
    fi

    # Then, check that the preference for short/long options doesn't
    # collide with them being ignored.
    if [[ "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" == "short" \
        && "${ARGPARSER_USE_SHORT_OPTIONS}" == false ]]
    then
        error_message="Error: The environment variable "
        error_message+="\"ARGPARSER_USAGE_MESSAGE_OPTION_TYPE\" requests the "
        error_message+="usage of short option names, but "
        error_message+="\"ARGPARSER_USE_SHORT_OPTIONS\" turns them off."

        argparser_translate "Error env var short options" "${error_message}"
        error_message="${translation}"
        error_messages+=("${error_message}")
    fi

    if [[ "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" == "long" \
        && "${ARGPARSER_USE_LONG_OPTIONS}" == false ]]
    then
        error_message="Error: The environment variable "
        error_message+="\"ARGPARSER_USAGE_MESSAGE_OPTION_TYPE\" requests the "
        error_message+="usage of long option names, but "
        error_message+="\"ARGPARSER_USE_LONG_OPTIONS\" turns them off."

        argparser_translate "Error env var long options" "${error_message}"
        error_message="${translation}"
        error_messages+=("${error_message}")
    fi

    # Then, check that the arguments definition file, the configuration
    # file, the help file, the translation file, and the usage file are
    # different from each other, if given.
    vars=(
        ARGPARSER_ARG_DEF_FILE
        ARGPARSER_CONFIGURATION_FILE
        ARGPARSER_HELP_FILE
        ARGPARSER_TRANSLATION_FILE
        ARGPARSER_USAGE_FILE
    )
    for i in "${!vars[@]}"; do
        var_1="${vars[i]}"
        for var_2 in "${vars[@]:$((i + 1))}"; do
            if [[ -n "${!var_1}" && "${!var_1}" == "${!var_2}" ]]; then
                error_message="Error: The environment variables \"%s\" and "
                error_message+="\"%s\" point to the same file."

                argparser_translate "Error env var files" "${error_message}" \
                    "${var_1}" "${var_2}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        done
    done

    # If there are error messages, sort, colorize, and print them, then
    # exit, as parsing the arguments with a faulty environment variable
    # configuration might be impossible.  If ${ARGPARSER_ERROR_STYLE} is
    # among the faulty variables, the error messages cannot be properly
    # colorized.  Thus, set the style to its default value.  The same
    # holds true for ${ARGPARSER_ERROR_EXIT_CODE}.
    for error_message in "${error_messages[@]}"; do
        if [[ "${error_message}" == *"ARGPARSER_ERROR_EXIT_CODE"* ]]; then
            ARGPARSER_ERROR_EXIT_CODE=1
        elif [[ "${error_message}" == *"ARGPARSER_ERROR_STYLE"* ]]; then
            ARGPARSER_ERROR_STYLE="red,bold,reverse"
        fi
    done

    argparser_print_error_or_warning_message "error" false true \
        "${error_messages[@]}"
}

# Define the argparser functions for reading the translation and
# translating strings.
function argparser_read_translation() {
    # Read the translation of the auto-generated text for help and usage
    # messages from the YAML file into an associative array.
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2
    # - ARGPARSER_CHECK_ENV_VARS
    # - ARGPARSER_DICTIONARY
    # - ARGPARSER_ERROR_EXIT_CODE
    # - ARGPARSER_ERROR_STYLE
    # - ARGPARSER_LANGUAGE (read-only)
    # - ARGPARSER_TRANSLATION_FILE (read-only)

    # Define the local variables.
    local error_message
    local -a error_messages
    local file_attributes
    local group
    local is_continued
    local language
    local line
    local -a lines
    local translation

    # Check if the translation file exists and is readable.  Else,
    # output an error message and exit.  Since at this point of
    # invokation, the environment variables aren't checked, yet, set the
    # needed ones to default values, if ${ARGPARSER_CHECK_ENV_VARS}
    # isn't set to false (and by this, the checking hasn't been
    # explicitly disabled).
    argparser_check_file "${ARGPARSER_TRANSLATION_FILE}"
    if [[ "${file_attributes}" != "0000" ]]; then
        error_message="Error: The environment variable \"%s\" is set to "
        error_message+="\"%s\", but the referenced file "
        case "${file_attributes}" in
            0001) error_message+="is empty." ;;
            0010) error_message+="is not readable." ;;
            0011) error_message+="is not readable and empty." ;;
            0100) error_message+="is not a regular file." ;;
            0101) error_message+="is not a regular file and empty." ;;
            0110)
                error_message+="is not a regular file and not readable."
                ;;
            0111)
                error_message+="is not a regular file, not readable, and "
                error_message+="empty."
                ;;
            1111) error_message+="does not exist." ;;
        esac
        error_message="${error_message/"%s"/"ARGPARSER_TRANSLATION_FILE"}"
        error_message="${error_message/"%s"/${ARGPARSER_TRANSLATION_FILE}}"

        if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
            ARGPARSER_ARG_DELIMITER_2=","
            ARGPARSER_ERROR_EXIT_CODE=1
            ARGPARSER_ERROR_STYLE="red,bold,reverse"
        fi
        argparser_print_error_or_warning_message "error" false true \
            "${error_message}"
    fi

    # Read the translation file.
    mapfile -t lines < "${ARGPARSER_TRANSLATION_FILE}"
    group=""
    language=""
    translation=""
    is_continued=false
    error_messages=( )

    for line in "${lines[@]}"; do
        if [[ -z "${line}" || "${line}" == \#* ]]; then
            # Ignore the empty or commented line.
            continue
        elif [[ "${line}" == "---" || "${line}" == "..." ]]; then
            # Ignore the start or end of a YAML block.
            continue
        elif [[ "${line}" == "  ${ARGPARSER_LANGUAGE}: >" ]]; then
            # The line starts the translation to the desired language.
            language="${ARGPARSER_LANGUAGE}"
            translation=""
            is_continued=true
        elif [[ "${line}" == "  ${ARGPARSER_LANGUAGE}: "* ]]; then
            # The line contains the translation to the desired language.
            language="${ARGPARSER_LANGUAGE}"
            translation="${line#*: }"
        elif [[ "${line}" == "  "*": >" ]]; then
            # The line start the translation to another language, which
            # can be ignored, along all following lines until the start
            # of a new YAML key.
            language="${line#* }"
            language="${language%:*}"
            is_continued=true
        elif [[ "${line}" == "  "*([^ ])": "* ]]; then
            # The line contains the translation to another language,
            # which can be ignored.
            language="${line#* }"
            language="${language%:*}"
        elif [[ "${line}" == "    "* \
            && "${language}" == "${ARGPARSER_LANGUAGE}" \
            && "${is_continued}" == true ]]
        then
            # The line continues the translation from the previous line.
            if [[ -z "${translation}" ]]; then
                translation="${line#    }"
            else
                translation+=" ${line#    }"
            fi
        elif [[ "${line}" == "    "* && "${is_continued}" == true ]]; then
            # The line continues the translation to another language,
            # from the previous line, which can be ignored.
            continue
        elif [[ "${line}" == *:  && "${line::1}" != " " ]]; then
            # The line starts a new group of translations.  Save the
            # previous translation under the previous group name, then
            # extract the new one.
            if [[ -n "${group}" ]]; then
                ARGPARSER_DICTIONARY[${group}]="${translation}"
            fi
            group="${line%:}"
            translation=""
            is_continued=false
        else
            # The line uses a YAML feature not supported by the
            # argparser, thus, output an error message.
            error_message="Error: The YAML line \"%s\" could not be "
            error_message+="recognized."

            argparser_translate "Error YAML" "${error_message}" "${line}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi
    done

    # Add the last group to the dictionary.
    if [[ -n "${group}" ]]; then
        ARGPARSER_DICTIONARY[${group}]="${translation}"
    fi

    # Sort, filter, colorize, and print all error messages.
    if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
        ARGPARSER_ARG_DELIMITER_2=","
        ARGPARSER_ERROR_EXIT_CODE=1
        ARGPARSER_ERROR_STYLE="red,bold,reverse"
    fi
    argparser_print_error_or_warning_message "error" true false \
        "${error_messages[@]}"
}

function argparser_translate() {
    # Translate the given string.
    #
    # Arguments:
    # - $1: the key (identifier) of the string in the dictionary
    # - $2: the string to use as fallback if no translation file is
    #       given or the key does not exist
    # - $@: the variable names to use for interpolation of "%s" format
    #       specifiers in the string
    #
    # Nonlocals:
    # - translation: the translated string
    #
    # Environment:
    # - ARGPARSER_DICTIONARY (read-only)
    # - ARGPARSER_TRANSLATION_FILE (read-only)

    # Define the local variables.
    local key
    local string
    local var
    local -a vars

    # Read the arguments.
    key="$1"
    string="$2"
    shift 2
    vars=("$@")

    # If an ${ARGPARSER_TRANSLATION_FILE} was given (and thus the
    # translation was requested), translate the string by fetching its
    # translation from the associative array ${ARGPARSER_DICTIONARY}.
    # Else, output the untranslated string.  If the key or string does
    # not exist in ${ARGPARSER_DICTIONARY}, output a warning message and
    # the untranslated string.  Translate the warning message only if
    # the key is not the one required for translation, else, an infinite
    # loop would arise by trying to fetch the inexistent translation
    # over and over.
    if [[ -n "${ARGPARSER_TRANSLATION_FILE}" ]]; then
        if ! argparser_in_array "${key}" "${!ARGPARSER_DICTIONARY[@]}"; then
            warning_message="Warning: In the translation file \"%s\", the "
            warning_message+="identifier \"%s\" is missing.  For convenience, "
            warning_message+="the untranslated string is used, instead."

            if [[ "${key}" == "Warning no identifier" ]]; then
                for var in "${ARGPARSER_TRANSLATION_FILE}" "${key}"; do
                    warning_message="${warning_message/"%s"/${var}}"
                done
            else
                argparser_translate "Warning no identifier" \
                    "${warning_message}" "${ARGPARSER_TRANSLATION_FILE}" \
                        "${key}"
                warning_message="${translation}"
            fi

            if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
                ARGPARSER_ARG_DELIMITER_2=","
                ARGPARSER_ERROR_EXIT_CODE=1
                ARGPARSER_ERROR_STYLE="red,bold,reverse"
            fi
            argparser_print_error_or_warning_message "warning" false false \
                "${warning_message}"
        elif [[ -z "${ARGPARSER_DICTIONARY[${key}]}" ]]; then
            warning_message="Warning: In the translation file \"%s\", the "
            warning_message+="translation to \"%s\" for the identifier \"%s\" "
            warning_message+="is missing.  For convenience, the untranslated "
            warning_message+="string is used, instead."

            if [[ "${key}" == "Warning no translation" ]]; then
                for var in "${ARGPARSER_TRANSLATION_FILE}" \
                    "${ARGPARSER_LANGUAGE}" "${key}"
                do
                    warning_message="${warning_message/"%s"/${var}}"
                done
            else
                argparser_translate "Warning no translation" \
                    "${warning_message}" "${ARGPARSER_TRANSLATION_FILE}" \
                    "${ARGPARSER_LANGUAGE}" "${key}"
                warning_message="${translation}"
            fi

            if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
                ARGPARSER_ARG_DELIMITER_2=","
                ARGPARSER_ERROR_EXIT_CODE=1
                ARGPARSER_ERROR_STYLE="red,bold,reverse"
            fi
            argparser_print_error_or_warning_message "warning" false false \
                "${warning_message}"
        else
            string="${ARGPARSER_DICTIONARY[${key}]}"
        fi
    fi

    # Replace the format specifiers in the string and assign
    # ${translation} to it.
    for var in "${vars[@]}"; do
        string="${string/"%s"/${var}}"
    done
    translation="${string}"
}

# Define the argparser functions for reading, parsing, and checking the
# arguments definition.
function argparser_read_args_definition() {
    # Read the arguments definition from the script and arguments
    # definition file, if provided.
    #
    # Arguments:
    # - $@: the arguments known to the script
    #
    # Nonlocals:
    # - messages: the parsed arguments definition as message or an error
    #   message, starting with "File: ", "Script: ", or "Error: "
    #   (translated), as indexed array
    #
    # Environment:
    # - ARGPARSER_ARG_DEF_FILE (read-only)
    # - ARGPARSER_ARG_DEF_FILE_HAS_HEADER (read-only)
    # - ARGPARSER_ARG_DEF_HAS_HEADER (read-only)
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)

    # Define the local variables.
    local arg
    local arg_key
    local -a args
    local def_pattern
    local error_message
    local header
    local i
    local key_pattern
    local line
    local lines
    local translation
    local trimmed_string

    # Read the arguments.
    # shellcheck disable=SC2190  # Indexed, not associative array.
    args=("$@")

    # Define the pattern how the arguments definition's keys look like,
    # as well as the pattern of the entire definition.  For the default
    # value of ${ARGPARSER_ARG_DELIMITER_1}, a colon, the definition
    # pattern describes alternating sequences of eleven non-colons,
    # i.e., "+([^:])", and ten colons, i.e., ":", in Bash's extglob
    # syntax. In PCRE syntax, the non-colon pattern would be written as
    # "[^:]+".  The key pattern only consists of one non-colon pattern.
    # This reflects the structure of the arguments definition
    # irrespective of the order of the columns.
    key_pattern="+([^${ARGPARSER_ARG_DELIMITER_1}])"
    def_pattern="${key_pattern}"
    for (( i = 0; i < 10; i++ )); do
        def_pattern+="${ARGPARSER_ARG_DELIMITER_1}${key_pattern}"
    done

    # Read and output the header for a possible arguments definition in
    # the script. If none is given or the first line does not match the
    # columnar argparser syntax matched by the definition pattern, then
    # assume a default header and re-read the arguments, leaving the
    # zeroth element, interpreted as header in the loop below, empty.

    # shellcheck disable=SC2053  # Intentional pattern matching.
    # shellcheck disable=SC2190  # Indexed, not associative array.
    if [[ "${ARGPARSER_ARG_DEF_HAS_HEADER}" == false \
        || "${args[0]}" != ${def_pattern} ]]
    then
        args=( )
        args[0]="id:short_opts:long_opts:val_names:defaults:choices:type:"
        args[0]+="arg_no:arg_group:notes:help"
        for arg in "$@"; do
            args+=("${arg}")
        done
    fi
    header="${args[0]}"
    messages+=("Script: ${header}")

    # If ${ARGPARSER_ARG_DEF_FILE} isn't set to the empty string, read
    # the arguments definition file and output the header.  Again, if
    # none is given, assume a default header.
    if [[ -n "${ARGPARSER_ARG_DEF_FILE}" ]]; then
        if [[ "${ARGPARSER_ARG_DEF_FILE_HAS_HEADER}" == true ]]; then
            mapfile -t lines < "${ARGPARSER_ARG_DEF_FILE}"
        else
            mapfile -t -O 1 lines < "${ARGPARSER_ARG_DEF_FILE}"
            lines[0]="id:short_opts:long_opts:val_names:defaults:choices:type:"
            lines[0]+="arg_no:arg_group:notes:help"
        fi
        header="${lines[0]}"
        messages+=("File: ${header}")
    fi

    # Get the definition for each argument (excluding the header as
    # zeroth element in ${args}).  These arguments may either be defined
    # in the script, where they're given in the columnar argparser
    # syntax, or in a separate arguments definition file, so they're
    # only given as their key.  If the structure differs, output an
    # error message.
    for arg in "${args[@]:1}"; do
        # shellcheck disable=SC2053  # Intentional pattern matching.
        if [[ "${arg}" == ${def_pattern} ]]; then
            # The argument matches the entire definition pattern.
            # Output its definition.
            messages+=("Script: ${arg}")
        elif [[ "${arg}" == ${key_pattern} && -n "${ARGPARSER_ARG_DEF_FILE}" ]]
        then
            # The argument matches the key pattern and an arguments
            # definition file is given. Iterate over all arguments
            # definition lines from the file. When the argument key in
            # one line matches the given key and the line matches the
            # definition pattern, output the key and definition, then
            # continue the outer loop (with index 2).  If the inner loop
            # doesn't get aborted by the continuation, it means that no
            # fitting argument definition has been found.  Thus, output
            # an error message.
            for line in "${lines[@]:1}"; do
                arg_key="${line%%"${ARGPARSER_ARG_DELIMITER_1}"*}"
                argparser_trim "${arg_key}"
                arg_key="${trimmed_string}"

                if [[ "${arg_key}" == "${arg}" ]]; then
                    if [[ "${line}" == ${def_pattern} ]]; then
                        messages+=("File: ${line}")
                        continue 2
                    else
                        error_message="Error: Invalid argument definition for "
                        error_message+="\"%s\"."

                        argparser_translate "Error wrong arg def" \
                            "${error_message}" "${arg}"
                        error_message="${translation}"
                        messages+=("${error_message}")
                        continue 2
                    fi
                fi
            done
            error_message="Error: No argument definition for \"%s\"."
            argparser_translate "Error no arg def" "${error_message}" "${arg}"
            error_message="${translation}"
            messages+=("${error_message}")
        else
            # The argument doesn't match any pattern and is thus deemed
            # invalid, so output an error message.
            error_message="Error: Invalid argument definition for \"%s\"."
            argparser_translate "Error wrong arg def" "${error_message}" \
                "${arg}"
            error_message="${translation}"
            messages+=("${error_message}")
        fi
    done
}

function argparser_parse_args_definition() {
    # Parse the arguments definition into an associative array per CSV
    # column.
    #
    # Arguments:
    # - $1: the origin of the arguments definition ("script" or "file")
    # - $@: the indexed array holding the arguments definition, the
    #       first line of which being the header
    #
    # Nonlocals:
    # - all_arg_groups: the associative array holding the argument
    #   groups
    # - all_arg_numbers: the associative array holding the argument
    #   numbers
    # - all_choice_values: the associative array holding the choice
    #   values
    # - all_default_values: the associative array holding the default
    #   values
    # - all_help_texts: the associative array holding the help texts
    # - all_long_options: the associative array holding the long option
    #   names
    # - all_notes: the associative array holding the notes
    # - all_positional_args: the indexed array holding the positional
    #   argument names
    # - all_short_options: the associative array holding the short
    #   option names
    # - all_types: the associative array holding the argument types
    # - all_value_names: the associative array holding the value names
    #
    # Environment:
    # - ARGPARSER_ARG_DEF_FILE (read-only)
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_SCRIPT_NAME (read-only)

    # Define the local variables.
    local arg_group
    local arg_key
    local arg_number
    local -a args_definition
    local choice_values
    local column_index
    local default_values
    local definition_type
    local error_message
    local -a error_messages
    local field
    local -A fields
    local -a header
    local help_text
    local i
    local -a line
    local long_options
    local notes
    local short_options
    local translation
    local trimmed_string
    local type
    local value_names

    # Read the arguments.
    definition_type="$1"
    shift
    args_definition=("$@")

    # Read the first line (the header) of ${args_definition} to get the
    # column indices for the fields.  Strip leading and trailing spaces.
    IFS="${ARGPARSER_ARG_DELIMITER_1}" read -r -a header \
        <<< "${args_definition[0]}"
    for column_index in "${!header[@]}"; do
        argparser_trim "${header[column_index]}"
        header[column_index]="${trimmed_string}"
    done

    # Get the column indices of all fields known to the current
    # argparser version.
    fields=(
        [id]=""
        [short_opts]=""
        [long_opts]=""
        [val_names]=""
        [defaults]=""
        [choices]=""
        [type]=""
        [arg_no]=""
        [arg_group]=""
        [notes]=""
        [help]=""
    )

    for field in "${!fields[@]}"; do
        for column_index in "${!header[@]}"; do
            if [[ "${header[column_index]}" == "${field}" ]]; then
                fields[${field}]="${column_index}"
            fi
        done
    done

    # If any column isn't given, output an error message.
    error_messages=( )
    for field in "${!fields[@]}"; do
        column_index="${fields[${field}]}"
        if [[ -z "${column_index}" ]]; then
            if [[ "${definition_type}" == "script" ]]; then
                error_message="Error: In the arguments definition in \"%s\", "
                error_message+="the column \"%s\" is missing."

                argparser_translate "Error arg def field" "${error_message}" \
                    "${ARGPARSER_SCRIPT_NAME}" "${field}"
                error_message="${translation}"
            elif [[ "${definition_type}" == "file" ]]; then
                error_message="Error: In the arguments definition file "
                error_message+="\"%s\", the column \"%s\" is missing."

                argparser_translate "Error arg def file field" \
                    "${error_message}" "${ARGPARSER_ARG_DEF_FILE}" "${field}"
                error_message="${translation}"
            fi
            error_messages+=("${error_message}")
        fi
    done

    # If there are error messages, sort, colorize, and print them, then
    # exit.
    argparser_print_error_or_warning_message "error" false true \
        "${error_messages[@]}"

    # Read all lines of the arguments definition and save the fields in
    # an associative array per column, using the argument identifier as
    # key and the definition in the field as value.  If neither a short
    # nor a long option name is given, interpret the argument as
    # positional and add it to the respective indexed array.  If only
    # short or long option names shall be accepted, set the respective
    # other value to a hyphen, indicating absence of an option name.
    # Skip arguments that have no short or long option name, if only the
    # other one is accepted, since these can never be given.
    for line in "${args_definition[@]:1}"; do
        IFS="${ARGPARSER_ARG_DELIMITER_1}" read -r -a line <<< "${line}"
        argparser_trim "${line[${fields["id"]}]}"
        arg_key="${trimmed_string}"

        argparser_trim "${line[${fields["short_opts"]}]}"
        short_options="${trimmed_string}"

        argparser_trim "${line[${fields["long_opts"]}]}"
        long_options="${trimmed_string}"

        if [[ "${short_options}" == "-" && "${long_options}" == "-" ]]; then
            all_positional_args+=("${arg_key}")
        elif [[ "${ARGPARSER_USE_LONG_OPTIONS}" == true \
            && "${ARGPARSER_USE_SHORT_OPTIONS}" == true ]]
        then
            all_short_options[${arg_key}]="${short_options}"
            all_long_options[${arg_key}]="${long_options}"
        elif [[ "${short_options}" != "-" \
            && "${ARGPARSER_USE_SHORT_OPTIONS}" == true ]]
        then
            all_short_options[${arg_key}]="${short_options}"
            all_long_options[${arg_key}]="-"
        elif [[ "${long_options}" != "-" \
            && "${ARGPARSER_USE_LONG_OPTIONS}" == true ]]
        then
            all_short_options[${arg_key}]="-"
            all_long_options[${arg_key}]="${long_options}"
        else
            continue
        fi

        argparser_trim "${line[${fields["val_names"]}]}"
        value_names="${trimmed_string}"
        all_value_names[${arg_key}]="${value_names}"

        argparser_trim "${line[${fields["defaults"]}]}"
        default_values="${trimmed_string}"
        all_default_values[${arg_key}]="${default_values}"

        argparser_trim "${line[${fields["choices"]}]}"
        choice_values="${trimmed_string}"
        all_choice_values[${arg_key}]="${choice_values}"

        argparser_trim "${line[${fields["type"]}]}"
        type="${trimmed_string}"
        all_types[${arg_key}]="${type}"

        argparser_trim "${line[${fields["arg_no"]}]}"
        arg_number="${trimmed_string}"
        all_arg_numbers[${arg_key}]="${arg_number}"

        argparser_trim "${line[${fields["arg_group"]}]}"
        arg_group="${trimmed_string}"
        all_arg_groups[${arg_key}]="${arg_group}"

        argparser_trim "${line[${fields["notes"]}]}"
        notes="${trimmed_string}"
        all_notes[${arg_key}]="${notes}"

        argparser_trim "${line[${fields["help"]}]}"
        help_text="${trimmed_string}"
        all_help_texts[${arg_key}]="${help_text}"
    done
}

function argparser_check_args_definition_names() {
    # Check if the script's arguments' definition is consistent
    # regarding the short and long option names.  This should always be
    # true for production scripts, but maybe not while testing.
    #
    # Nonlocals:
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - error_messages: the error messages, starting with "Error: "
    #   (translated), as indexed array
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_USE_LONG_OPTIONS (read-only)
    # - ARGPARSER_USE_SHORT_OPTIONS (read-only)

    # Define the local variables.
    local arg_key
    local -a arg_keys
    local count
    local -A checked_long_options
    local -A checked_short_options
    local error_message
    local long_option
    local -a long_options
    local short_option
    local -a short_options
    local translation

    # Get and sort all argument keys (identifiers), such that the
    # following loop is performed in alphabetical order of the
    # arguments, such that the error messages for duplicate option names
    # refer to the lexicographically earlier argument.
    mapfile -d "" -t arg_keys \
        < <(argparser_sort false "${!all_short_options[@]}")

    # Check that no short or long option is given twice for the same
    # argument or among multiples.
    for arg_key in "${arg_keys[@]}"; do
        # Read the argument's definition.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
            <<< "${all_short_options[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
            <<< "${all_long_options[${arg_key}]}"

        # If more than one short option name is given, check if any is a
        # hyphen, which must only once be used as placeholder for
        # missing short options.  Then, check if any short option name
        # is longer than one character, and if it is given multiple
        # times in the current argument's definition or across all yet
        # investigated arguments' definitions.  If only one short option
        # name is given, the hyphen is a legit value, so don't check
        # this.
        if (( "${#short_options[@]}" > 1 )) \
            && argparser_in_array "-" "${short_options[@]}"
        then
            # Check if a hyphen is included in the short option names.
            error_message="Error: The argument with the identifier \"%s\" has "
            error_message+="a placeholder \"-\" given as one of the %s short "
            error_message+="option names, instead of a legit name."

            argparser_translate "Error arg def short name hyphen" \
                "${error_message}" "${arg_key}" "${#short_options[@]}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi

        for short_option in "${short_options[@]}"; do
            if [[ "${ARGPARSER_ADD_HELP}" == true \
                && "${ARGPARSER_USE_SHORT_OPTIONS}" == true \
                && "${short_option}" == "h" ]]
            then
                # Check if a short option name uses the reserved flag
                # for the help message.
                error_message="Error: The argument with the identifier "
                error_message+="\"%s\" has the short option -h defined, which "
                error_message+="is reserved for invoking the help message."

                argparser_translate "Error arg def short name help" \
                    "${error_message}" "${arg_key}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${ARGPARSER_ADD_USAGE}" == true \
                && "${ARGPARSER_USE_SHORT_OPTIONS}" == true \
                && "${short_option}" == "u" ]]
            then
                # Check if a short option name uses the reserved flag
                # for the usage message.
                error_message="Error: The argument with the identifier "
                error_message+="\"%s\" has the short option -u defined, which "
                error_message+="is reserved for invoking the usage message."

                argparser_translate "Error arg def short name usage" \
                    "${error_message}" "${arg_key}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${ARGPARSER_ADD_VERSION}" == true \
                && "${ARGPARSER_USE_SHORT_OPTIONS}" == true \
                && "${short_option}" == "V" ]]
            then
                # Check if a short option name uses the reserved flag
                # for the version message.
                error_message="Error: The argument with the identifier "
                error_message+="\"%s\" has the short option -V defined, which "
                error_message+="is reserved for invoking the version message."

                argparser_translate "Error arg def short name version" \
                    "${error_message}" "${arg_key}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${short_option}" != "-" ]]; then
                # Check if a short option name is more than one
                # character long.
                if (( "${#short_option}" > 1 )); then
                    error_message="Error: The argument with the identifier "
                    error_message+="\"%s\" has the short option \"-%s\" "
                    error_message+="defined with more than 1 character length."

                    argparser_translate "Error arg def short name length" \
                        "${error_message}" "${arg_key}" "${short_option}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi

                # Check if the short option name is given multiple times
                # in the current argument's definition.
                argparser_count "${short_option}" "${short_options[@]}"
                if (( count > 1 )); then
                    error_message="Error: The argument with the identifier "
                    error_message+="\"%s\" has the short option \"-%s\" given "
                    error_message+="%s times."

                    argparser_translate \
                        "Error arg def short name inner duplication" \
                        "${error_message}" "${arg_key}" "${short_option}" \
                        "${count}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi

                # Check if the short option name is already given in
                # another argument's definition.
                if argparser_in_array "${short_option}" \
                    "${!checked_short_options[@]}" \
                    && [[ "${checked_short_options[${short_option}]}" != \
                        "${arg_key}" ]]
                then
                    error_message="Error: The argument with the identifier "
                    error_message+="\"%s\" has the short option \"-%s\" "
                    error_message+="given, but that is already in use by "
                    error_message+="\"%s\"."

                    argparser_translate \
                        "Error arg def short name outer duplication" \
                        "${error_message}" "${arg_key}" "${short_option}" \
                        "${checked_short_options[${short_option}]}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi

                # Add the short option name to the associative array of
                # all short option names.
                checked_short_options[${short_option}]="${arg_key}"
            fi
        done

        # Perform the same tests for the long option names for having a
        # hyphen among the long option names or if any long option name
        # is shorter than two characters, and if it is given multiple
        # times in the current argument's definition or across all yet
        # investigated arguments' definitions.
        if (( "${#long_options[@]}" > 1 )) \
            && argparser_in_array "-" "${long_options[@]}"
        then
            # Check if a hyphen is included in the long option names.
            error_message="Error: The argument with the identifier \"%s\" has "
            error_message+="a placeholder \"-\" given as one of the %s long "
            error_message+="option names, instead of a legit name."

            argparser_translate "Error arg def long name hyphen" \
                "${error_message}" "${arg_key}" "${#long_options[@]}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi

        for long_option in "${long_options[@]}"; do
            if [[ "${ARGPARSER_ADD_HELP}" == true \
                && "${ARGPARSER_USE_LONG_OPTIONS}" == true \
                && "${long_option}" == "help" ]]
            then
                # Check if a long option name uses the reserved flag for
                # the help message.
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has the long option --help defined, which is "
                error_message+="reserved for invoking the help message."

                argparser_translate "Error arg def long name help" \
                    "${error_message}" "${arg_key}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${ARGPARSER_ADD_USAGE}" == true \
                && "${ARGPARSER_USE_LONG_OPTIONS}" == true \
                && "${long_option}" == "usage" ]]
            then
                # Check if a long option name uses the reserved flag for
                # the usage message.
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has the long option --usage defined, which is "
                error_message+="reserved for invoking the usage message."

                argparser_translate "Error arg def long name usage" \
                    "${error_message}" "${arg_key}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${ARGPARSER_ADD_VERSION}" == true \
                && "${ARGPARSER_USE_LONG_OPTIONS}" == true \
                && "${long_option}" == "version" ]]
            then
                # Check if a long option name uses the reserved flag for
                # the version message.
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has the long option --version defined, which "
                error_message+="is reserved for invoking the version message."

                argparser_translate "Error arg def long name version" \
                    "${error_message}" "${arg_key}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${long_option}" != "-" ]]; then
                # Check if a long option name is less than two
                # characters long.
                if (( "${#long_option}" < 2 )); then
                    error_message="Error: The argument with the identifier "
                    error_message+="\"%s\" has the long option \"--%s\" "
                    error_message+="defined with less than 2 characters "
                    error_message+="length."

                    argparser_translate "Error arg def long name length" \
                        "${error_message}" "${arg_key}" "${long_option}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi

                # Check if the long option name is given multiple times
                # in the current argument's definition.
                argparser_count "${long_option}" "${long_options[@]}"
                if (( count > 1 )); then
                    error_message="Error: The argument with the identifier "
                    error_message+="\"%s\" has the long option \"--%s\" given "
                    error_message+="%s times."

                    argparser_translate \
                        "Error arg def long name inner duplication" \
                        "${error_message}" "${arg_key}" "${long_option}" \
                        "${count}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi

                # Check if the long option name is already given in
                # another argument's definition.
                if argparser_in_array "${long_option}" \
                    "${!checked_long_options[@]}" \
                    && [[ "${checked_long_options[${long_option}]}" != \
                        "${arg_key}" ]]
                then
                    error_message="Error: The argument with the identifier "
                    error_message+="\"%s\" has the long option \"--%s\" "
                    error_message+="given, but that is already in use by "
                    error_message+="\"%s\"."

                    argparser_translate \
                        "Error arg def long name outer duplication" \
                        "${error_message}" "${arg_key}" "${long_option}" \
                        "${checked_long_options[${long_option}]}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi

                # Add the long option name to the associative array of
                # all long option names.
                checked_long_options[${long_option}]="${arg_key}"
            fi
        done
    done
}

function argparser_check_args_definition_positional_values() {
    # Check if the script's arguments' definition is consistent
    # regarding the default and choice values, as well as the number of
    # arguments for positional arguments.  This should always be true
    # for production scripts, but maybe not while testing.
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_choice_values: the associative array holding the choice
    #   values (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_notes: the associative array holding the notes (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    # - all_types: the associative array holding the argument types
    #   (read-only)
    # - error_messages: the error messages, starting with "Error: "
    #   (translated), as indexed array
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)

    # Define the local variables.
    local arg_key
    local arg_number
    local choice_value
    local -a choice_values
    local default_value
    local -a default_values
    local error_message
    local infinite_arg_number_arg
    local note
    local -a notes
    local optional_arg
    local translation
    local type

    # Check the consistency of all positional arguments.
    infinite_arg_number_arg=""
    optional_arg=""
    for arg_key in "${all_positional_args[@]}"; do
        # Read the argument's definition.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a default_values \
            <<< "${all_default_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values \
            <<< "${all_choice_values[${arg_key}]}"
        type="${all_types[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a notes \
            <<< "${all_notes[${arg_key}]}"

        # Check if the number of default values equals the number of
        # required values.  Else, output an error message.
        if [[ "${arg_number}" != "+" \
            && "${default_values[0]}" != "-" \
            && "${#default_values[@]}" != "${arg_number}" ]]
        then
            if [[ "${arg_number}" == 1 ]]; then
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" requires 1 value, but has "
                error_message+="%s given as default."

                argparser_translate "Error arg def pos default 1" \
                    "${error_message}" "${arg_key}" "${#default_values[@]}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            else
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" requires %s values, but has "
                error_message+="%s given as default."

                argparser_translate "Error arg def pos default 2" \
                    "${error_message}" "${arg_key}" "${arg_number}" \
                    "${#default_values[@]}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        fi

        # Check if the default values accord to the choice values, i.e.,
        # if each default value lies within the array of choice values.
        # Else, output an error message.
        if [[ "${choice_values[0]}" != "-" ]]; then
            for default_value in "${default_values[@]}"; do
                if [[ "${default_value}" != "-" ]] \
                    && ! argparser_in_array "${default_value}" \
                        "${choice_values[@]}"
                then
                    choice_value="${choice_values[0]}"
                    for (( i = 1; i < "${#choice_values[@]}"; i++ )); do
                        choice_value+="${ARGPARSER_ARG_DELIMITER_2}"
                        choice_value+="${choice_values[i]}"
                    done

                    default_value="${default_values[0]}"
                    for (( i = 1; i < "${#default_values[@]}"; i++ )); do
                        default_value+="${ARGPARSER_ARG_DELIMITER_2}"
                        default_value+="${default_values[i]}"
                    done

                    error_message="Error: The positional argument with the "
                    error_message+="identifier \"%s\" accepts only the choice "
                    error_message+="values {%s}, but has {%s} given as "
                    error_message+="default."

                    argparser_translate "Error arg def pos choice" \
                        "${error_message}" "${arg_key}" "${choice_value}" \
                        "${default_value}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                    break
                fi
            done
        fi

        # Check the number of arguments with default values.
        if [[ "${default_values[0]}" != "-" ]]; then
            # Check that no two positional arguments are optional, which
            # would be impossible to parse.
            if [[ -n "${optional_arg}" ]]; then
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" is optional, as is \"%s\", "
                error_message+="which renders parsing impossible."

                argparser_translate "Error arg def pos optionals" \
                    "${error_message}" "${arg_key}" "${optional_arg}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            else
                optional_arg="${arg_key}"
            fi

            # Likewise, check that there is no positional argument
            # accepting an infinite number of values along the optional
            # one, which would also be impossible to parse.
            if [[ -n "${infinite_arg_number_arg}" ]]; then
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" is optional, while \"%s\" "
                error_message+="accepts an infinite number of values, which "
                error_message+="renders parsing impossible."

                argparser_translate "Error arg def pos optional infinite" \
                    "${error_message}" "${arg_key}" \
                    "${infinite_arg_number_arg}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        fi

        # Check the number of arguments.
        if [[ "${arg_number}" == 0 ]]; then
            # Since positional arguments can't be flags, output an error
            # message.
            error_message="Error: The positional argument with the identifier "
            error_message+="\"%s\" accepts 0 arguments and thus can never be "
            error_message+="given on the command line."

            argparser_translate "Error arg def pos flag" "${error_message}" \
                "${arg_key}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        elif [[ "${arg_number}" == "+" ]]; then
            # Check that no two positional arguments accept an infinite
            # number of values, which would be impossible to parse.
            if [[ -n "${infinite_arg_number_arg}" ]]; then
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" accepts an infinite number "
                error_message+="of values, as does \"%s\", which renders "
                error_message+="parsing impossible."

                argparser_translate "Error arg def pos infinites" \
                    "${error_message}" "${arg_key}" \
                    "${infinite_arg_number_arg}"
                error_messages+=("${error_message}")
            else
                infinite_arg_number_arg="${arg_key}"
            fi

            # Likewise, check that there is no optional positional
            # argument along the one accepting an infinite number of
            # values, which would also be impossible to parse.
            if [[ -n "${optional_arg}" ]]; then
                if [[ "${optional_arg}" == "${arg_key}" ]]; then
                    # The argument being both optional and accepting an
                    # infinite number of values is the same (the current
                    # one), which is not supported.
                    error_message="Error: The positional argument with the "
                    error_message+="identifier \"%s\" accepts an infinite "
                    error_message+="number of values, while being optional, "
                    error_message+="which is not supported."

                    argparser_translate \
                        "Error arg def pos infinite optional 1" \
                        "${error_message}" "${arg_key}"
                    error_message="${translation}"
                else
                    # Both arguments are different, which is impossible
                    # to parse.
                    error_message="Error: The positional argument with the "
                    error_message+="identifier \"%s\" accepts an infinite "
                    error_message+="number of values, while \"%s\" is "
                    error_message+="optional, which renders parsing "
                    error_message+="impossible."

                    argparser_translate \
                        "Error arg def pos infinite optional 2" \
                        "${error_message}" "${arg_key}" "${optional_arg}"
                    error_message="${translation}"
                fi
                error_messages+=("${error_message}")
            fi
        fi

        # Check the data type.
        if ! argparser_in_array "${type}" "-" "bool" "char" "int" "str" "uint"
        then
            error_message="Error: The positional argument with the identifier "
            error_message+="\"%s\" has \"%s\" given as data type, but only "
            error_message+="\"bool\", \"char\", \"int\", \"str\", and "
            error_message+="\"uint\" are supported."

            argparser_translate "Error arg def pos type" "${error_message}" \
                "${arg_key}" "${type}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi

        # Check if the choice values accord to the type.
        for choice_value in "${choice_values[@]}"; do
            if [[ "${choice_value}" == "-" || "${type}" == "-" ]]; then
                # No choice value or type is given, so abort the loop.
                break
            elif [[ "${type}" == "bool" ]] \
                && ! argparser_is_variable_bool "${choice_value}"
            then
                # Check if the choice value is a boolean.
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" has \"%s\" given as choice "
                error_message+="value, which must be a boolean, i.e., true or "
                error_message+="false."

                argparser_translate "Error arg def pos bool" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${type}" == "char" ]] \
                && ! argparser_is_variable_char "${choice_value}"
            then
                # Check if the choice value is a character.
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" has \"%s\" given as choice "
                error_message+="value, which must be a character, i.e., a "
                error_message+="string comprising one printable ASCII "
                error_message+="character."

                argparser_translate "Error arg def pos char" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${type}" == "int" ]] \
                && ! argparser_is_variable_int "${choice_value}"
            then
                # Check if the choice value is an integer.
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" has \"%s\" given as choice "
                error_message+="value, which must be an integer, i.e., "
                error_message+="comprise only digits and possibly a leading "
                error_message+="sign."

                argparser_translate "Error arg def pos int" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${type}" == "uint" ]] \
                && ! argparser_is_variable_uint "${choice_value}"
            then
                # Check if the choice value is an unsigned integer.
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" has \"%s\" given as choice "
                error_message+="value, which must be an unsigned integer, "
                error_message+="i.e., comprise only digits and no sign."

                argparser_translate "Error arg def pos uint" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        done

        # Check the notes.
        for note in "${notes[@]}"; do
            if ! argparser_in_array "${note}" "-" "deprecated"; then
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" has \"%s\" given as note, "
                error_message+="but only \"deprecated\" is supported."

                argparser_translate "Error arg def pos note" \
                    "${error_message}" "${arg_key}" "${note}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        done
    done
}

function argparser_check_args_definition_option_values() {
    # Check if the script's arguments' definition is consistent
    # regarding the default and choice values, as well as the number of
    # arguments for options (keyword arguments).  This should always be
    # true for production scripts, but maybe not while testing.
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_choice_values: the associative array holding the choice
    #   values (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_notes: the associative array holding the notes (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - all_types: the associative array holding the argument types
    #   (read-only)
    # - error_messages: the error messages, starting with "Error: "
    #   (translated), as indexed array
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)

    # Define the local variables.
    local arg_key
    local arg_number
    local choice_value
    local -a choice_values
    local default_value
    local -a default_values
    local error_message
    local note
    local -a notes
    local translation
    local type

    # Check the consistency of all keyword arguments.
    for arg_key in "${!all_short_options[@]}"; do
        # Read the argument's definition.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a default_values \
            <<< "${all_default_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values \
            <<< "${all_choice_values[${arg_key}]}"
        type="${all_types[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a notes \
            <<< "${all_notes[${arg_key}]}"

        # Check if the default value for flags is either true or false.
        if [[ "${arg_number}" == 0 \
            && "${default_values[0]}" != true \
            && "${default_values[0]}" != false ]]
        then
            default_value="${default_values[0]}"
            for (( i = 1; i < "${#default_values[@]}"; i++ )); do
                default_value+="${ARGPARSER_ARG_DELIMITER_2}"
                default_value+="${default_values[i]}"
            done

            error_message="Error: The argument with the identifier \"%s\" "
            error_message+="must be true or false, but has {%s} given as "
            error_message+="default."

            argparser_translate "Error arg def option flag" \
                "${error_message}" "${arg_key}" "${default_value}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi

        # Check if the number of default values equals the number of
        # required values.  Else, output an error message.  Ignore flags
        # as long as they have the only default value of true or false,
        # but a number of required values of 0.
        if [[ "${arg_number}" != "+" \
            && "${arg_number}" != 0 \
            && "${default_values[0]}" != "-" \
            && "${#default_values[@]}" != "${arg_number}" ]]
        then
            if [[ "${arg_number}" == 1 ]]; then
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="requires 1 value, but has %s given as default."

                argparser_translate "Error arg def option default 1" \
                    "${error_message}" "${arg_key}" "${#default_values[@]}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            else
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="requires %s values, but has %s given as "
                error_message+="default."

                argparser_translate "Error arg def option default 2" \
                    "${error_message}" "${arg_key}" "${arg_number}" \
                    "${#default_values[@]}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        fi

        # Check if the default values accord to the choice values, i.e.,
        # if each default value lies within the array of choice values.
        # Else, output an error message.
        if [[ "${choice_values[0]}" != "-" ]]; then
            # Check that flags have no choice values.
            if [[ "${arg_number}" == 0 ]]; then
                choice_value="${choice_values[0]}"
                for (( i = 1; i < "${#choice_values[@]}"; i++ )); do
                    choice_value+="${ARGPARSER_ARG_DELIMITER_2}"
                    choice_value+="${choice_values[i]}"
                done

                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="accepts no choice values, but has {%s} given."

                argparser_translate "Error arg def option choice flag" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi

            # Check the default values.
            for default_value in "${default_values[@]}"; do
                if [[ "${default_value}" != "-" ]] \
                    && ! argparser_in_array "${default_value}" \
                        "${choice_values[@]}"
                then
                    choice_value="${choice_values[0]}"
                    for (( i = 1; i < "${#choice_values[@]}"; i++ )); do
                        choice_value+="${ARGPARSER_ARG_DELIMITER_2}"
                        choice_value+="${choice_values[i]}"
                    done

                    default_value="${default_values[0]}"
                    for (( i = 1; i < "${#default_values[@]}"; i++ )); do
                        default_value+="${ARGPARSER_ARG_DELIMITER_2}"
                        default_value+="${default_values[i]}"
                    done

                    error_message="Error: The argument with the identifier "
                    error_message+="\"%s\" accepts only the choice values "
                    error_message+="{%s}, but has {%s} given as default."

                    argparser_translate "Error arg def option choice" \
                        "${error_message}" "${arg_key}" "${choice_value}" \
                        "${default_value}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                    break
                fi
            done
        fi

        # Check the data type.
        if ! argparser_in_array "${type}" "-" "bool" "char" "int" "str" "uint"
        then
            error_message="Error: The argument with the identifier \"%s\" has "
            error_message+="\"%s\" given as data type, but only \"bool\", "
            error_message+="\"char\", \"int\", \"str\", and \"uint\" are "
            error_message+="supported."

            argparser_translate "Error arg def option type" \
                "${error_message}" "${arg_key}" "${type}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi

        # Check if the choice values accord to the type.
        for choice_value in "${choice_values[@]}"; do
            if [[ "${choice_value}" == "-" || "${type}" == "-" ]]; then
                # No choice value or type is given, so abort the loop.
                break
            elif [[ "${type}" == "bool" ]] \
                && ! argparser_is_variable_bool "${choice_value}"
            then
                # Check if the choice value is a boolean.
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has \"%s\" given as choice value, which must "
                error_message+="be a boolean, i.e., true or false."

                argparser_translate "Error arg def option bool" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${type}" == "char" ]] \
                && ! argparser_is_variable_char "${choice_value}"
            then
                # Check if the choice value is a character.
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has \"%s\" given as choice value, which must "
                error_message+="be a character, i.e., a string comprising one "
                error_message+="printable ASCII character."

                argparser_translate "Error arg def option char" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${type}" == "int" ]] \
                && ! argparser_is_variable_int "${choice_value}"
            then
                # Check if the choice value is an integer.
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has \"%s\" given as choice value, which must "
                error_message+="be an integer, i.e., comprise only digits and "
                error_message+="possibly a leading sign."

                argparser_translate "Error arg def option int" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${type}" == "uint" ]] \
                && ! argparser_is_variable_uint "${choice_value}"
            then
                # Check if the choice value is an unsigned integer.
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has \"%s\" given as choice value, which must "
                error_message+="be an unsigned integer, i.e., comprise only "
                error_message+="digits and no sign."

                argparser_translate "Error arg def option uint" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        done

        # Check the notes.
        for note in "${notes[@]}"; do
            if ! argparser_in_array "${note}" "-" "deprecated"; then
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has \"%s\" given as note, but only "
                error_message+="\"deprecated\" is supported."

                argparser_translate "Error arg def option note" \
                    "${error_message}" "${arg_key}" "${note}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        done
    done
}

# Define the argparser functions for the argument parsing.
function argparser_get_arg_key() {
    # Get the argument identifier (key) for a given short or long option
    # name.
    #
    # Arguments:
    # - $1: whether the option is expected to be a short or long option
    #   ("short" or "long")
    # - $2: the option name
    #
    # Nonlocals:
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - arg_key: the argument identifier, if the key exists, or the
    #   empty string, else (when the option name is erroneous)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)

    # Define the local variables.
    local long_option
    local -a long_options
    local mode
    local option_name
    local short_option
    local -a short_options

    # Read the arguments.
    mode="$1"
    option_name="$2"

    # Get the argument identifier.
    if [[ "${mode}" == "short" ]]; then
        for arg_key in "${!all_short_options[@]}"; do
            # Read the argument's definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
                <<< "${all_short_options[${arg_key}]}"

            # Ignore arguments without a short option name.
            if [[ "${short_options[0]}" == "-" ]]; then
                continue
            fi

            # Check the short options.
            for short_option in "${short_options[@]}"; do
                if [[ "${option_name}" == "${short_option}" ]]; then
                    return
                fi
            done
        done
    else
        for arg_key in "${!all_long_options[@]}"; do
            # Read the argument's definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
                <<< "${all_long_options[${arg_key}]}"

            # Ignore arguments without a long option name.
            if [[ "${long_options[0]}" == "-" ]]; then
                continue
            fi

            # Check the long options.
            for long_option in "${long_options[@]}"; do
                if [[ "${option_name}" == "${long_option}" ]]; then
                    return
                fi
            done
        done
    fi

    arg_key=""
}

function argparser_get_option_names() {
    # Concatenate the name of all short and long options.
    #
    # Arguments:
    # - $1: the argument's name (key)
    # - $2: the order of the options ("short-long" or "long-short")
    #
    # Nonlocals:
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - all_value_names: the associative array holding the value names
    #   (read-only)
    # - option_names: the name of all short and long options as
    #   comma-separated string
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)

    # Define the local variables.
    local arg_key
    local long_option_names
    local -a long_options
    local order
    local short_option_names
    local -a short_options
    local value_names

    # Read the arguments.
    arg_key="$1"
    order="$2"

    # Read the argument's definition.  As positional arguments aren't
    # included in ${all_short_options} and ${all_long_options}, assign
    # them the default value of a hyphen, indicating absence.  For the
    # option name below, use the value name, of which positional
    # arguments can only have one (thus using a string, not an array).
    if argparser_in_array "${arg_key}" "${!all_short_options[@]}"; then
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
            <<< "${all_short_options[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
            <<< "${all_long_options[${arg_key}]}"
    else
        short_options=("-")
        long_options=("-")
        value_names="${all_value_names[${arg_key}]}"
    fi

    # Concatenate the name of all short and long options.
    printf -v short_option_names -- '-%s,' "${short_options[@]}"
    printf -v long_option_names -- '--%s,' "${long_options[@]}"
    if [[ "${short_options[0]}" != "-" && "${long_options[0]}" != "-" ]]; then
        if [[ "${order}" == "short-long" ]]; then
            option_names="${short_option_names}${long_option_names%,}"
        elif [[ "${order}" == "long-short" ]]; then
            option_names="${long_option_names}${short_option_names%,}"
        fi
    elif [[ "${short_options[0]}" != "-" ]]; then
        option_names="${short_option_names%,}"
    elif [[ "${long_options[0]}" != "-" ]]; then
        option_names="${long_option_names%,}"
    else
        option_names="${value_names}"
    fi
}

function argparser_parse_arg() {
    # Parse an argument given to the script.
    #
    # Arguments:
    # - $1: the argument to parse
    #
    # Nonlocals:
    # - is_positional_only: whether the positional arguments delimiter
    #   "--" has already been set and has not been unset by "++"
    #   (read-only)
    # - messages: the parsed argument as message or an error message,
    #   starting with "Help", "Usage", "Version", "Logo",
    #   "Positional_Start", "Positional_End", "Error: " (translated),
    #   "Argument: ", "Prefix: ", or "Value: ", as indexed array
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    # - ARGPARSER_USE_LONG_OPTIONS (read-only)
    # - ARGPARSER_USE_SHORT_OPTIONS (read-only)

    # Define the local variables.
    local error_message
    local given_arg
    local translation

    # Read the argument.
    given_arg="$1"

    # Output the argument, split into option names and values, or an
    # error message.  In the latter case, output also the given
    # argument, such that values following the unknown argument are
    # assigned to this argument, not the last known one that got parsed.
    if [[ "${given_arg}" != "++"* \
        && ("${given_arg}" != [-+]* || "${is_positional_only}" == true) ]]
    then
        # The argument doesn't start with a hyphen ("-") or plus sign
        # ("+"), so deem it a value to a previous keyword argument or a
        # positional argument.  Likewise, if the positional arguments
        # delimiter "--" has already been set and has neither been unset
        # by "++" nor the current argument is this "++", then deem any
        # value a positional argument.
        messages+=("Value: ${given_arg}")
    elif [[ "${given_arg}" == "--" ]]; then
        # The argument is the positional arguments delimiter "--".
        messages+=("Positional_Start")
    elif [[ "${given_arg}" == "--="* ]]; then
        # The argument is the positional arguments delimiter "--", but
        # followed by an illegal equals sign ("=").
        error_message="Error: The special option \"--\" takes no value."
        argparser_translate "Error arg double hyphen" "${error_message}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    elif [[ "${given_arg}" == "++" ]]; then
        # The argument is the positional arguments delimiter "++".
        messages+=("Positional_End")
    elif [[ "${given_arg}" == "++="* ]]; then
        # The argument is the positional arguments delimiter "++", but
        # followed by an illegal equals sign ("=").
        error_message="Error: The special option \"++\" takes no value."
        argparser_translate "Error arg double plus" "${error_message}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    elif [[ "${ARGPARSER_ADD_HELP}" == true \
        && "${ARGPARSER_USE_LONG_OPTIONS}" == true \
        && "${given_arg}" == "--help" ]]
    then
        # The argument is for the help message, using the long option
        # name.
        messages+=("Help")
    elif [[ "${ARGPARSER_ADD_HELP}" == true \
        && "${ARGPARSER_USE_SHORT_OPTIONS}" == true \
        && "${given_arg}" == "-h" ]]
    then
        # The argument is for the help message, using the short option
        # name.
        messages+=("Help")
    elif [[ "${ARGPARSER_ADD_HELP}" == true \
        && "${ARGPARSER_USE_LONG_OPTIONS}" == true \
        && "${ARGPARSER_USE_SHORT_OPTIONS}" == true \
        && ( "${given_arg}" == "-h="* || "${given_arg}" == "--help="*) ]]
    then
        # The argument is for the help message, but followed by an
        # illegal equals sign ("="), using the short or long option
        # name.
        error_message="Error: The option \"-h,--help\" takes no value."
        argparser_translate "Error arg help 1" "${error_message}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    elif [[ "${ARGPARSER_ADD_HELP}" == true \
        && "${ARGPARSER_USE_LONG_OPTIONS}" == true \
        && "${given_arg}" == "--help="* ]]
    then
        # The argument is for the help message, but followed by an
        # illegal equals sign ("="), using the long option name.
        error_message="Error: The option \"--help\" takes no value."
        argparser_translate "Error arg help 2" "${error_message}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    elif [[ "${ARGPARSER_ADD_HELP}" == true \
        && "${ARGPARSER_USE_SHORT_OPTIONS}" == true \
        && "${given_arg}" == "-h="* ]]
    then
        # The argument is for the help message, but followed by an
        # illegal equals sign ("="), using the short option name.
        error_message="Error: The option \"-h\" takes no value."
        argparser_translate "Error arg help 3" "${error_message}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    elif [[ "${ARGPARSER_ADD_USAGE}" == true \
        && "${ARGPARSER_USE_LONG_OPTIONS}" == true \
        && "${given_arg}" == "--usage" ]]
    then
        # The argument is for the usage message, using the long option
        # name.
        messages+=("Usage")
    elif [[ "${ARGPARSER_ADD_USAGE}" == true \
        && "${ARGPARSER_USE_SHORT_OPTIONS}" == true \
        && "${given_arg}" == "-u" ]]
    then
        # The argument is for the usage message, using the short option
        # name.
        messages+=("Usage")
    elif [[ "${ARGPARSER_ADD_USAGE}" == true \
        && "${ARGPARSER_USE_LONG_OPTIONS}" == true \
        && "${ARGPARSER_USE_SHORT_OPTIONS}" == true \
        && ( "${given_arg}" == "-u="* || "${given_arg}" == "--usage="*) ]]
    then
        # The argument is for the usage message, but followed by an
        # illegal equals sign ("="), using the short or long option
        # name.
        error_message="Error: The option \"-u,--usage\" takes no value."
        argparser_translate "Error arg usage 1" "${error_message}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    elif [[ "${ARGPARSER_ADD_USAGE}" == true \
        && "${ARGPARSER_USE_LONG_OPTIONS}" == true \
        && "${given_arg}" == "--usage="* ]]
    then
        # The argument is for the usage message, but followed by an
        # illegal equals sign ("="), using the long option name.
        error_message="Error: The option \"--usage\" takes no value."
        argparser_translate "Error arg usage 2" "${error_message}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    elif [[ "${ARGPARSER_ADD_USAGE}" == true \
        && "${ARGPARSER_USE_SHORT_OPTIONS}" == true \
        && "${given_arg}" == "-u="* ]]
    then
        # The argument is for the usage message, but followed by an
        # illegal equals sign ("="), using the short option name.
        error_message="Error: The option \"-u\" takes no value."
        argparser_translate "Error arg usage 3" "${error_message}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    elif [[ "${ARGPARSER_ADD_VERSION}" == true \
        && "${ARGPARSER_USE_LONG_OPTIONS}" == true \
        && "${given_arg}" == "--version" ]]
    then
        # The argument is for the version message, using the long option
        # name.
        messages+=("Version")
    elif [[ "${ARGPARSER_ADD_VERSION}" == true \
        && "${ARGPARSER_USE_SHORT_OPTIONS}" == true \
        && "${given_arg}" == "-V" ]]
    then
        # The argument is for the version message, using the short
        # option name.
        messages+=("Version")
    elif [[ "${ARGPARSER_ADD_VERSION}" == true \
        && "${ARGPARSER_USE_LONG_OPTIONS}" == true \
        && "${ARGPARSER_USE_SHORT_OPTIONS}" == true \
        && ( "${given_arg}" == "-V="* || "${given_arg}" == "--version="*) ]]
    then
        # The argument is for the version message, but followed by an
        # illegal equals sign ("="), using the short or long option
        # name.
        error_message="Error: The option \"-V,--version\" takes no value."
        argparser_translate "Error arg version 1" "${error_message}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    elif [[ "${ARGPARSER_ADD_VERSION}" == true \
        && "${ARGPARSER_USE_LONG_OPTIONS}" == true \
        && "${given_arg}" == "--version="* ]]
    then
        # The argument is for the version message, but followed by an
        # illegal equals sign ("="), using the long option name.
        error_message="Error: The option \"--version\" takes no value."
        argparser_translate "Error arg version 2" "${error_message}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    elif [[ "${ARGPARSER_ADD_VERSION}" == true \
        && "${ARGPARSER_USE_SHORT_OPTIONS}" == true \
        && "${given_arg}" == "-V="* ]]
    then
        # The argument is for the version message, but followed by an
        # illegal equals sign ("="), using the short option name.
        error_message="Error: The option \"-V\" takes no value."
        argparser_translate "Error arg version 3" "${error_message}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    elif [[ "${given_arg}" == "--argparser" \
        && "${BASH_SOURCE[0]}" == "${BASH_SOURCE[-1]}" ]]
    then
        # The argument is the magic string for the argparser, which was
        # directly called and not run from another script.  Since the
        # argparser accepts only long options by design, no test for
        # ${ARGPARSER_USE_LONG_OPTIONS} is necessary.
        messages+=("Logo")
    elif [[ "${ARGPARSER_USE_LONG_OPTIONS}" == true \
        && ("${given_arg::2}" == "--" || "${given_arg::2}" == "++") ]]
    then
        # The argument is a long option, so check whether the given
        # argument is defined.
        argparser_parse_long_option "${given_arg}"
    elif [[ "${ARGPARSER_USE_SHORT_OPTIONS}" == true \
        && "${given_arg::2}" == [-+][!-+] ]]
    then
        # The argument is a short option, so check whether the given
        # argument is defined.
        argparser_parse_short_option "${given_arg}"
    else
        # The argument hasn't been matched by any condition, so deem it
        # unknown.  This is true if the prefix is neither "--", "++", a
        # single "-" nor a single "+", but e.g. "+-" or "-+".  This is
        # also true if the argument is a short option, but only long
        # options shall be accepted, or vice versa.
        error_message="Error: The argument \"%s\" is unknown."
        argparser_translate "Error arg unknown" "${error_message}" \
            "${given_arg%%=*}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    fi
}

function argparser_parse_long_option() {
    # Parse a long-option argument given to the script.
    #
    # Arguments:
    # - $1: the argument to parse
    #
    # Nonlocals:
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - messages: the parsed argument as message or an error message,
    #   starting with "Error: " (translated), "Argument: ", "Prefix: ",
    #   or "Value: ", as indexed array
    #
    # Environment:
    # - ARGPARSER_ALLOW_OPTION_ABBREVIATION (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)

    # Define the local variables.
    local abbr_long_option
    local -A abbr_long_options
    local arg_key
    local count
    local error_message
    local given_arg
    local long_option
    local -a long_options
    local option_name
    local prefix
    local translation
    local value
    local -a values

    # Read the argument.
    given_arg="$1"

    # Get the prefix, option name, and possibly values for the given
    # argument.
    prefix="${given_arg::1}"
    option_name="${given_arg:2}"
    if [[ "${given_arg}" =~ "=" ]]; then
        option_name="${option_name%%=*}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a values \
            <<< "${given_arg#*=}"
    else
        values=("")
    fi
    argparser_get_arg_key "long" "${option_name}"

    # Output the argument, split into the option name and values, or an
    # error message.  In the latter case, output also the given
    # argument, such that values following the unknown argument are
    # assigned to this argument, not the last known one that got parsed.
    if [[ "${ARGPARSER_ALLOW_OPTION_ABBREVIATION}" == true \
        && -z "${arg_key}" ]]
    then
        # Check if the argument is an abbreviated long option, since no
        # argument identifier for the entire option name has been found.
        for arg_key in "${!all_long_options[@]}"; do
            # Read the argument's definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
                <<< "${all_long_options[${arg_key}]}"

            # Abbreviate the long option names by shortening them to the
            # length of the given option name and add them to the
            # associative array.  Ignore arguments without long option
            # name.
            for long_option in "${long_options[@]}"; do
                if [[ "${long_option}" == "-" ]]; then
                    break
                fi
                abbr_long_options[${arg_key}]="${long_option::${#option_name}}"
            done
        done

        # Count the number of matches of the argument among the
        # abbreviated long option names. If it matches once, output the
        # argument identifier and possibly the values following the
        # equals sign ("=").  If multiple or no option names are
        # matched, output an error message, instead.
        argparser_count "${option_name}" "${abbr_long_options[@]}"
        if (( count == 1 )); then
            # Get the argument identifier for the abbreviated argument.
            for arg_key in "${!abbr_long_options[@]}"; do
                abbr_long_option="${abbr_long_options[${arg_key}]}"
                if [[ "${option_name}" == "${abbr_long_option}"* ]]; then
                    break
                fi
            done

            if [[ -n "${values[0]}" ]]; then
                # Output the argument identifier, the prefix, and the
                # values.
                messages+=("Argument: ${arg_key}")
                messages+=("Prefix: ${prefix}")
                for value in "${values[@]}"; do
                    messages+=("Value: ${value}")
                done
            else
                # Output the argument identifier and the prefix.
                messages+=("Argument: ${arg_key}")
                messages+=("Prefix: ${prefix}")
            fi
        elif (( count > 1 )); then
            # Since multiple option names have been found in the
            # definition, output an error message and the argument.
            error_message="Error: The long option \"%s\" matches multiple "
            error_message+="long options."

            argparser_translate "Error long option match" "${error_message}" \
                "${given_arg%%=*}"
            error_message="${translation}"
            messages+=("${error_message}")
            messages+=("Argument: ${given_arg}")
        else
            # Since the argument hasn't been found in the definition,
            # output an error message and the argument.
            error_message="Error: The long option \"%s\" is unknown."
            argparser_translate "Error long option unknown" \
                "${error_message}" "${given_arg%%=*}"
            error_message="${translation}"
            messages+=("${error_message}")
            messages+=("Argument: ${given_arg}")
        fi
    else
        if [[ -n "${arg_key}" ]]; then
            if [[ -n "${values[0]}" ]]; then
                # Output the argument identifier, the prefix, and the
                # values.
                messages+=("Argument: ${arg_key}")
                messages+=("Prefix: ${prefix}")
                for value in "${values[@]}"; do
                    messages+=("Value: ${value}")
                done
            else
                # Output the argument identifier and the prefix.
                messages+=("Argument: ${arg_key}")
                messages+=("Prefix: ${prefix}")
            fi
        else
            # Since the argument hasn't been found in the definition,
            # output an error message and the argument.
            error_message="Error: The long option \"%s\" is unknown."
            argparser_translate "Error long option unknown" \
                "${error_message}" "${given_arg%%=*}"
            error_message="${translation}"
            messages+=("${error_message}")
            messages+=("Argument: ${given_arg}")
        fi
    fi
}

function argparser_parse_short_option() {
    # Parse a short-option argument given to the script.
    #
    # Arguments:
    # - $1: the argument to parse
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - messages: the parsed argument as message or an error message,
    #   starting with "Error: " (translated), "Argument: ", "Prefix: ",
    #   or "Value: ", as indexed array
    #
    # Environment:
    # - ARGPARSER_ALLOW_OPTION_MERGING (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)

    # Define the local variables.
    local arg_key
    local arg_number
    local char
    local given_arg
    local i
    local option_name
    local prefix
    local translation
    local value
    local -a values

    # Read the argument.
    given_arg="$1"

    # Get the prefix, option name, and possibly values for the given
    # argument.
    prefix="${given_arg::1}"
    option_name="${given_arg:1}"
    if [[ "${given_arg}" =~ "=" ]]; then
        option_name="${option_name%%=*}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a values \
            <<< "${given_arg#*=}"
    else
        values=("")
    fi
    argparser_get_arg_key "short" "${option_name}"

    # Get the argument identifier for the given (and perhaps merged)
    # argument and output it, possibly along with the values following
    # the equals sign ("=").
    if [[ "${ARGPARSER_ALLOW_OPTION_MERGING}" == true ]]; then
        # Split the combined short option name, which may end in a
        # merged value, after any character.
        for (( i = 0; i < "${#option_name}"; i++ )); do
            char="${option_name:i:1}"
            argparser_get_arg_key "short" "${char}"
            if [[ -z "${arg_key}" ]]; then
                # Since the argument hasn't been found in the
                # definition, output an error message and the argument.
                error_message="Error: The short option \"%s%s\" is unknown."
                argparser_translate "Error short option merge" \
                    "${error_message}" "${prefix}" "${char}"
                error_message="${translation}"
                messages+=("${error_message}")
                messages+=("Argument: ${given_arg}")
                return
            fi

            # Output the argument identifier and the prefix for the
            # short option name character.
            messages+=("Argument: ${arg_key}")
            messages+=("Prefix: ${prefix}")

            # Get the number of required arguments to judge whether the
            # following character is an argument to the current option
            # or another option (i.e., the current option is a flag).
            # If there is no following character, the value must have
            # been given as next whitespace-delimited argument, thus
            # don't output anything.
            arg_number="${all_arg_numbers[${arg_key}]}"
            if [[ "${arg_number}" != 0 ]] && (( i < "${#option_name}" - 1 ))
            then
                # Output the value, which is the argument's rest.
                messages+=("Value: ${option_name:i+1}")
                return
            fi
        done

        if [[ -n "${values[0]}" ]]; then
            # Output the values, which are given after an equals sign
            # ("=").
            for value in "${values[@]}"; do
                messages+=("Value: ${value}")
            done
        fi
    else
        if [[ -n "${arg_key}" ]]; then
            if [[ -n "${values[0]}" ]]; then
                # Output the argument identifier, the prefix, and the
                # values.
                messages+=("Argument: ${arg_key}")
                messages+=("Prefix: ${prefix}")
                for value in "${values[@]}"; do
                    messages+=("Value: ${value}")
                done
            else
                # Output the argument identifier and the prefix.
                messages+=("Argument: ${arg_key}")
                messages+=("Prefix: ${prefix}")
            fi
        else
            # Since the argument hasn't been found in the definition,
            # output an error message and the argument.
            error_message="Error: The short option \"%s\" is unknown."
            argparser_translate "Error short option unknown" \
                "${error_message}" "${given_arg%%=*}"
            error_message="${translation}"
            messages+=("${error_message}")
            messages+=("Argument: ${given_arg}")
        fi
    fi
}

function argparser_parse_positional_args() {
    # Parse all positional arguments given to the script.
    #
    # Arguments:
    # - $@: the arguments to parse
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    # - messages: the parsed argument as message or an error message,
    #   starting with "Error: " (translated), "Argument: ", or
    #   "Value: ", as indexed array
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)

    # Define the local variables.
    local arg_key
    local arg_number
    local args_count
    local default_args_count
    local -a default_values
    local error_message
    local given_arg
    local -a given_args
    local i
    local index
    local required_args_count
    local translation
    local -a values

    # Read the arguments and split the values on
    # ${ARGPARSER_ARG_DELIMITER_2} characters.
    values=( )
    for given_arg in "$@"; do
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a given_args \
            <<< "${given_arg}"
        values+=("${given_args[@]}")
    done

    # Count the defined positional arguments with default values and
    # those without.
    default_args_count=0
    required_args_count=0
    for arg_key in "${all_positional_args[@]}"; do
        # Read the argument's definition.
        default_values="${all_default_values[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # For the counting, consider an infinite number of values as 1,
        # i.e., the minimum number that can be given.
        if [[ "${arg_number}" == "+" ]]; then
            arg_number=1
        fi

        # Increment the respective count.
        if [[ "${default_values}" == "-" ]]; then
            (( required_args_count += arg_number ))
        else
            (( default_args_count += arg_number ))
        fi
    done

    # Based on the number of given, default, and required positional
    # arguments, judge whether values for arguments with default values
    # are given.  Since there cannot be arguments with an infinite
    # number of values defined when there are arguments with default
    # values defined, a higher number of given values than required
    # means that either some values for arguments with default values
    # are given (then, their count exceeds zero), or that an argument
    # accepting an infinite number of values is given as last once
    # (then, the count of default arguments is zero).  This allows to
    # distinguish these two cases.
    args_count="${#values[@]}"
    if (( args_count > required_args_count && default_args_count > 0 )); then
        # There are arguments having default values given.  Get the
        # argument identifiers for all given arguments and output them,
        # along with the values.
        index=0
        for arg_key in "${all_positional_args[@]}"; do
            # Read the argument's definition.
            arg_number="${all_arg_numbers[${arg_key}]}"

            # Output as many given arguments as requested.
            messages+=("Argument: ${arg_key}")
            for (( i = index; i < arg_number + index && i < args_count; i++ ))
            do
                messages+=("Value: ${values[i]}")
            done
            (( index += arg_number ))
        done
    else
        # There are no arguments having default values given.  Get the
        # argument identifiers for all given arguments and output them,
        # along with the values.
        index=0
        for arg_key in "${all_positional_args[@]}"; do
            # Read the argument's definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a default_values \
                <<< "${all_default_values[${arg_key}]}"
            arg_number="${all_arg_numbers[${arg_key}]}"

            # Skip the defined arguments having default values, but
            # aren't given.
            if [[ "${default_values[0]}" != "-" ]]; then
                continue
            fi

            # If the positional argument accepts an infinite number of
            # values, output all remaining given arguments, else, only
            # as many as requested.
            messages+=("Argument: ${arg_key}")
            if [[ "${arg_number}" == "+" ]]; then
                for (( i = index; i < args_count; i++ )); do
                    messages+=("Value: ${values[i]}")
                done
                index="${args_count}"

                break
            else
                for (( i = index; i < arg_number + index && i < args_count; \
                    i++ ))
                do
                    messages+=("Value: ${values[i]}")
                done
                (( index += arg_number ))
            fi
        done
    fi

    # If there are positional arguments remaining that haven't been
    # consumed by a defined argument, output an error message.
    if (( index < args_count )); then
        if (( index == 1 )); then
            error_message="Error: 1 positional argument is required, but %s "
            error_message+="are given."

            argparser_translate "Error pos arg count 1" "${error_message}" \
                "${args_count}"
            error_message="${translation}"
        else
            error_message="Error: %s positional arguments are required, but "
            error_message+="%s are given."

            argparser_translate "Error pos arg count 2" "${error_message}" \
                "${index}" "${args_count}"
            error_message="${translation}"
        fi
        messages+=("${error_message}")
    fi
}

function argparser_check_arg_values() {
    # Check if a script's argument accords to its definition.
    #
    # Arguments:
    # - $1: the argument's name (key)
    # - $2: the argument's prefixes ("-", "+", or "")
    # - $3: the argument's values
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_choice_values: the associative array holding the choice
    #   values (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_notes: the associative array holding the notes (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    # - all_types: the associative array holding the argument types
    #   (read-only)
    # - messages: the parsed argument as message or an error or warning
    #   message, starting with "Error: " (translated), "Warning: "
    #   (translated), or "Value: ", as indexed array
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_COUNT_FLAGS (read-only)

    # Define the local variables.
    local arg_key
    local arg_number
    local choice_value
    local -a choice_values
    local count
    local count_hyphen
    local count_plus
    local default_value
    local -a default_values
    local error_message
    local i
    local note
    local -a notes
    local option_names
    local prefix
    local -a prefixes
    local translation
    local type
    local value
    local -a values
    local warning_message

    # Read the arguments.  Since positional arguments have no prefix,
    # use an empty array as default value, such that testing on its
    # value is possible, below.
    arg_key="$1"
    if argparser_in_array "${arg_key}" "${all_positional_args[@]}"; then
        prefixes=( )
    else
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a prefixes <<< "$2"
    fi

    if [[ "${arg_key}" == "ARGPARSER_ARG_DELIMITER_2" ]]; then
        if [[ -n "$3" ]]; then
            values=("$3")
        else
            values=( )
        fi

        # Read the argument's definition.
        default_values=("${all_default_values[${arg_key}]}")
        choice_values=("${all_choice_values[${arg_key}]}")
        type="${all_types[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"
        notes=("${all_notes[${arg_key}]}")
    else
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a values <<< "$3"

        # Read the argument's definition.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a default_values \
            <<< "${all_default_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values \
            <<< "${all_choice_values[${arg_key}]}"
        type="${all_types[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a notes \
            <<< "${all_notes[${arg_key}]}"
    fi

    # Concatenate the name of all short and long options for the error
    # and warning messages.
    argparser_get_option_names "${arg_key}" "short-long"

    # If a "+" prefix is given and the argument is no flag, output an
    # error message.
    for prefix in "${prefixes[@]}"; do
        if [[ "${prefix}" == "+" && "${arg_number}" != 0 ]]; then
            error_message="Error: The option \"%s\" is no flag and thus "
            error_message+="cannot be given with a \"+\" prefix."

            argparser_translate "Error arg no flag" "${error_message}" \
                "${option_names}"
            error_message="${translation}"
            messages+=("${error_message}")
            return
        fi
    done

    # Check if the correct number of values is given.  If an argument
    # hadn't been given, both its value and prefix are empty, but if it
    # was given without value the prefix is non-empty, allowing to
    # distinguish both cases.
    if (( "${#values[@]}" == 0 && "${#prefixes[@]}" == 0 )); then
        if [[ "${default_values[0]}" == "-" ]]; then
            # The argument is not given, but must have been since it
            # doesn't have a default value.  Hence, output an error
            # message.
            error_message="Error: The argument \"%s\" is mandatory, but not "
            error_message+="given."

            argparser_translate "Error mandatory arg" "${error_message}" \
                "${option_names}"
            error_message="${translation}"
            messages+=("${error_message}")
            return
        elif [[ "${ARGPARSER_COUNT_FLAGS}" == true && "${arg_number}" == 0 ]]
        then
            # The argument is not given, but a flag with a default value
            # of "true" or "false".  Since the flags shall be counted,
            # set the value to 1 for "true" and to -1 for "false", which
            # are the same values as would be when the flags would be
            # given with a hyphen ("-", true) or plus sign ("+", false).
            if [[ "${default_values[0]}" == true ]]; then
                values=(1)
            else
                values=(-1)
            fi
        else
            # The argument is not given, but it has default values.
            # Hence, read them.  This is required for optional
            # arguments, which don't need to be set.
            values=("${default_values[@]}")
        fi
    else
        if [[ "${arg_number}" != "+" && "${#values[@]}" != "${arg_number}" ]] \
            || [[ "${arg_number}" == "+" && "${#values[@]}" == 0 ]]
        then
            # If the number of values doesn't equal the number of
            # required values, check if some default values are given.
            if [[ "${default_values[0]}" == "-" ]]; then
                # If no default value is given, output an error message
                # indicating the number of required and given arguments.
                if [[ "${arg_number}" == 1 ]]; then
                    error_message="Error: The argument \"%s\" requires 1 "
                    error_message+="value, but has %s given."

                    argparser_translate "Error wrong arg number 1" \
                        "${error_message}" "${option_names}" "${#values[@]}"
                    error_message="${translation}"
                elif [[ "${arg_number}" == "+" ]]; then
                    error_message="Error: The argument \"%s\" requires at "
                    error_message+="least 1 value, but has %s given."

                    argparser_translate "Error wrong arg number 2" \
                        "${error_message}" "${option_names}" "${#values[@]}"
                    error_message="${translation}"
                else
                    error_message="Error: The argument \"%s\" requires %s "
                    error_message+="values, but has %s given."

                    argparser_translate "Error wrong arg number 3" \
                        "${error_message}" "${option_names}" "${arg_number}" \
                        "${#values[@]}"
                    error_message="${translation}"
                fi
                messages+=("${error_message}")
                return
            else
                # As some default values are given, print a similar
                # warning message as for the absence case, but set the
                # values to the default values and continue.
                if [[ "${arg_key}" != "ARGPARSER_ARG_DELIMITER_2" ]]; then
                    default_value="${default_values[0]}"
                    for (( i = 1; i < "${#default_values[@]}"; i++ )); do
                        default_value+="${ARGPARSER_ARG_DELIMITER_2}"
                        default_value+="${default_values[i]}"
                    done
                fi

                if [[ "${arg_number}" == 1 ]]; then
                    warning_message="Warning: The argument \"%s\" requires 1 "
                    warning_message+="value, but has %s given.  For "
                    warning_message+="convenience, the default (%s) is used."

                    argparser_translate "Warning wrong arg number 1" \
                        "${warning_message}" "${option_names}" \
                        "${#values[@]}" "${default_value}"
                    warning_message="${translation}"
                elif [[ "${arg_number}" == "+" ]]; then
                    warning_message="Warning: The argument \"%s\" requires at "
                    warning_message+="least 1 value, but has %s given.  For "
                    warning_message+="convenience, the default (%s) is used."

                    argparser_translate "Warning wrong arg number 2" \
                        "${warning_message}" "${option_names}" \
                        "${#values[@]}" "${default_value}"
                    warning_message="${translation}"
                else
                    warning_message="Warning: The argument \"%s\" requires "
                    warning_message+="%s values, but has %s given.  For "
                    warning_message+="convenience, the default (%s) is used."

                    argparser_translate "Warning wrong arg number 3" \
                        "${warning_message}" "${option_names}" \
                        "${arg_number}" "${#values[@]}" "${default_value}"
                    warning_message="${translation}"
                fi
                messages+=("${warning_message}")

                if [[ "${arg_key}" == "ARGPARSER_ARG_DELIMITER_2" ]]; then
                    IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a \
                        default_values \
                            <<< "${all_default_values[${arg_key}]}"
                fi
                values=("${default_values[@]}")
            fi
        elif [[ "${arg_number}" == 0 && (! -v values || -z "${values[0]}") ]]
        then
            # If no value is required nor given, the argument is a flag.
            # As it is set (present), set the value to true for a "-"
            # prefix and to false for a "+" prefix.  Thereby, the last
            # given prefix determines the value, implicitly overriding
            # any prefix given before.
            if [[ "${ARGPARSER_COUNT_FLAGS}" == true ]]; then
                argparser_count "-" "${prefixes[@]}"
                count_hyphen="${count}"

                argparser_count "+" "${prefixes[@]}"
                count_plus="${count}"

                (( count = count_hyphen - count_plus ))
                values=("${count}")
            else
                if [[ "${prefixes[-1]}" == "-" ]]; then
                    values=(true)
                else
                    values=(false)
                fi
            fi
        fi
    fi

    # Check if the given values accord to the choice values, i.e., if
    # each given value lies within the array of choice values.  Else,
    # output an error message.
    if [[ "${choice_values[0]}" != "-" ]]; then
        for value in "${values[@]}"; do
            if ! argparser_in_array "${value}" "${choice_values[@]}"; then
                choice_value="${choice_values[0]}"
                for (( i = 1; i < "${#choice_values[@]}"; i++ )); do
                    choice_value+="${ARGPARSER_ARG_DELIMITER_2}"
                    choice_value+="${choice_values[i]}"
                done

                value="${values[0]}"
                for (( i = 1; i < "${#values[@]}"; i++ )); do
                    value+="${ARGPARSER_ARG_DELIMITER_2}${values[i]}"
                done

                error_message="Error: The argument \"%s\" must be in {%s}, "
                error_message+="but is {%s}."

                argparser_translate "Error arg choice" "${error_message}" \
                    "${option_names}" "${choice_value}" "${value}"
                error_message="${translation}"
                messages+=("${error_message}")
                return
            fi
        done
    fi

    # Check if the given values accord to the type.
    for value in "${values[@]}"; do
        if [[ "${type}" == "-" ]]; then
            # No type is given, so abort the loop.
            break
        elif [[ "${type}" == "bool" && "${arg_number}" != 0 ]] \
            && ! argparser_is_variable_bool "${value}"
        then
            # Check if the value is a boolean.  If the argument is a
            # flag, then the values are set by the argparser to
            # booleans, or, if ${ARGPARSER_COUNT_FLAGS} is set to true,
            # to unsigned integers.  Since both automatically have the
            # correct type, don't check them.
            error_message="Error: The argument \"%s\" is set to \"%s\", but "
            error_message+="must be a boolean, i.e., true or false."

            argparser_translate "Error arg bool" "${error_message}" \
                "${option_names}" "${value}"
            error_message="${translation}"
            messages+=("${error_message}")
            return
        elif [[ "${type}" == "char" ]] \
            && ! argparser_is_variable_char "${value}"
        then
            # Check if the value is a character.
            error_message="Error: The argument \"%s\" is set to \"%s\", but "
            error_message+="must be a character, i.e., a string comprising "
            error_message+="one printable ASCII character."

            argparser_translate "Error arg char" "${error_message}" \
                "${option_names}" "${value}"
            error_message="${translation}"
            messages+=("${error_message}")
            return
        elif [[ "${type}" == "int" ]] \
            && ! argparser_is_variable_int "${value}"
        then
            # Check if the value is an integer.
            error_message="Error: The argument \"%s\" is set to \"%s\", but "
            error_message+="must be an integer, i.e., comprise only digits "
            error_message+="and possibly a leading sign."

            argparser_translate "Error arg int" "${error_message}" \
                "${option_names}" "${value}"
            error_message="${translation}"
            messages+=("${error_message}")
            return
        elif [[ "${type}" == "uint" ]] \
            && ! argparser_is_variable_uint "${value}"
        then
            # Check if the value is an unsigned integer.
            error_message="Error: The argument \"%s\" is set to \"%s\", but "
            error_message+="must be an unsigned integer, i.e., comprise only "
            error_message+="digits and no sign."

            argparser_translate "Error arg uint" "${error_message}" \
                "${option_names}" "${value}"
            error_message="${translation}"
            messages+=("${error_message}")
            return
        fi
    done

    # Check the notes.
    for note in "${notes[@]}"; do
        if [[ "${note}" == "deprecated" && "${#prefixes[@]}" != 0 ]]; then
            # Only output a deprecation warning if the argument had been
            # given (and thus the prefix is non-empty), not when its
            # default value has been used.
            warning_message="Warning: The argument \"%s\" is deprecated and "
            warning_message+="will be removed in the future."

            argparser_translate "Warning deprecation" "${warning_message}" \
                "${option_names}"
            warning_message="${translation}"
            messages+=("${warning_message}")
        fi
    done

    # Output the checked values.
    value="${values[0]}"
    for (( i = 1; i < "${#values[@]}"; i++ )); do
        value+="${ARGPARSER_ARG_DELIMITER_2}${values[i]}"
    done
    messages+=("Value: ${value}")
}

function argparser_parse_args() {
    # Parse the script's given arguments and check if they accord to
    # their definition.  Give proper error messages for wrongly set
    # arguments and assign the values to the respective variables.
    # Possibly, create and print a help message.
    #
    # Arguments:
    # - $@: the arguments to parse
    #
    # Globals:
    # - ${ARGPARSER_ARG_ARRAY_NAME}: the parsed and checked arguments
    #   with key and value as associative array
    #
    # Environment:
    # - ARGPARSER_ARG_ARRAY_NAME (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_CHECK_ARG_DEFINITION (read-only)
    # - ARGPARSER_ERROR_EXIT_CODE (read-only)
    # - ARGPARSER_SILENCE_ERRORS (read-only)

    # Define the local variables.  If the variable that
    # ${ARGPARSER_ARG_ARRAY_NAME} refers to is undefined, all variables
    # prefixed with "arg" are searched, later.  In order to not shadow
    # them by local variables, all locals starting with "arg" are
    # defined later.
    local -A all_arg_groups
    local -A all_arg_numbers
    local -A all_choice_values
    local -A all_default_values
    local -A all_help_texts
    local -A all_long_options
    local -A all_notes
    local -a all_positional_args
    local -A all_short_options
    local -A all_types
    local -A all_value_names
    local error_message
    local -a error_messages
    local given_arg
    local -a given_args
    local -a given_positional_args
    local -A help_message_groups
    local i
    local is_extglob_set
    local is_help
    local is_logo
    local is_positional
    local is_positional_only
    local is_usage
    local is_version
    local message
    local -a messages
    local name
    local names
    local prefix
    local -A prefixes
    local translated_error
    local translated_warning
    local translation
    local -A usage_message_groups
    local value
    local values
    local warning_message
    local -a warning_messages

    # Read the arguments.
    read -r -a given_args <<< "$@"

    # Locally disable errexit and enable extglob.  Since all functions
    # relying on the latter being set are called from argparser_main,
    # they inherit the option.
    local -
    set +o errexit
    is_extglob_set="$(shopt -p extglob)"
    shopt -s extglob

    # Check if the variable that ${ARGPARSER_ARG_ARRAY_NAME} refers to
    # is defined.  If not, guess how it may be called by searching the
    # set variables (not functions, hence the set POSIX mode) for a
    # variable name starting with "arg" to give a clearer error message.
    # If no such variable name is found, skip that part of the message.
    if [[ ! -v "${ARGPARSER_ARG_ARRAY_NAME}" ]]; then
        mapfile -t names <<< "$(set -o posix; set)"
        for name in "${names[@]}"; do
            if [[ "${name}" == "arg"* ]]; then
                name="${name%%=*}"
                break
            else
                name=""
            fi
        done

        if [[ -n "${name}" ]]; then
            error_message="Error: The variable ARGPARSER_ARG_ARRAY_NAME "
            error_message+="refers to \"%s\", but this variable is not "
            error_message+="defined.  Either you have given your arguments "
            error_message+="array another name (maybe \"%s\" -- then change "
            error_message+="ARGPARSER_ARG_ARRAY_NAME accordingly) or you "
            error_message+="forgot defining the array at all (then define it)."

            argparser_translate "Error arg array 1" "${error_message}" \
                "${ARGPARSER_ARG_ARRAY_NAME}" "${name}"
            error_message="${translation}"
        else
            error_message="Error: The variable ARGPARSER_ARG_ARRAY_NAME "
            error_message+="refers to \"%s\", but this variable is not "
            error_message+="defined.  Either you have given your arguments "
            error_message+="array another name (then change "
            error_message+="ARGPARSER_ARG_ARRAY_NAME accordingly) or you "
            error_message+="forgot defining the array at all (then define it)."

            argparser_translate "Error arg array 2" "${error_message}" \
                "${ARGPARSER_ARG_ARRAY_NAME}"
            error_message="${translation}"
        fi
        argparser_print_error_or_warning_message "error" false true \
            "${error_message}"
    fi

    # Define the remaining local variables that start with "arg".
    local arg
    local arg_key
    local -a args_definition_file
    local -a args_definition_script

    # Read in the requested arguments.  ${ARGPARSER_ARG_ARRAY_NAME} is
    # set to the name of the indexed array holding the arguments in the
    # script.  If it is already "args" (the default name), nothing needs
    # to be done, but other variable names need to be mapped to "args"
    # to be able to refer to the variable by name.  Thus, declare prints
    # the array contents stored in the variable
    # ${ARGPARSER_ARG_ARRAY_NAME} refers to, which then gets stripped
    # from the leading assignment (before the equals sign ("=")) and set
    # to the new indexed array ${args}.  Since later, the variable
    # ${ARGPARSER_ARG_ARRAY_NAME} refers to is assigned an associative
    # array, while being an indexed array, unset it.
    if [[ "${ARGPARSER_ARG_ARRAY_NAME}" != "args" ]]; then
        local args
        args="$(declare -p "${ARGPARSER_ARG_ARRAY_NAME}")"
        local -a args="${args#*=}"

        unset "${ARGPARSER_ARG_ARRAY_NAME}"
    fi

    # Read the arguments definition.
    args_definition_file=( )
    args_definition_script=( )
    error_messages=( )

    argparser_translate "Error" "Error"
    translated_error="${translation}"

    argparser_translate "Warning" "Warning"
    translated_warning="${translation}"

    messages=( )
    argparser_read_args_definition "${args[@]}"
    for message in "${messages[@]}"; do
        # Append the arguments definition to those for the file or
        # script, respectively.
        case "${message}" in
            File*) args_definition_file+=("${message#File: }") ;;
            Script*) args_definition_script+=("${message#Script: }") ;;
            ${translated_error}*)
                error_messages+=("${message}")
            ;;
        esac
    done

    # If there are error messages, sort, colorize, and print them, then
    # exit, as parsing the arguments definition with missing parts is
    # useless.
    argparser_print_error_or_warning_message "error" false true \
        "${error_messages[@]}"

    # Parse the arguments definition.
    all_positional_args=( )
    if (( "${#args_definition_file[@]}" > 0 )); then
        argparser_parse_args_definition "file" "${args_definition_file[@]}"
    fi
    if (( "${#args_definition_script[@]}" > 0 )); then
        argparser_parse_args_definition "script" "${args_definition_script[@]}"
    fi

    # If ${ARGPARSER_CHECK_ARG_DEFINITION} is set to true, check the
    # consistency of the arguments definition.
    error_messages=( )
    if [[ "${ARGPARSER_CHECK_ARG_DEFINITION}" == true ]]; then
        # Check the arguments definition, first the short and long
        # option names, then the default and choice values.
        argparser_check_args_definition_names
        argparser_check_args_definition_positional_values
        argparser_check_args_definition_option_values

        # If there are error messages, sort, filter, colorize, and print
        # them, then exit, as parsing the arguments with a faulty
        # definition is useless or even impossible.
        argparser_print_error_or_warning_message "error" true true \
            "${error_messages[@]}"
    fi

    # Parse the script's given arguments.
    is_help=false
    is_logo=false
    is_usage=false
    is_version=false
    is_positional=true
    is_positional_only=false
    error_messages=( )

    unset args
    local -A args

    for given_arg in "${given_args[@]}"; do
        # Parse the argument.
        messages=( )
        argparser_parse_arg "${given_arg}"

        # Read the output message and either set the help, usage, or
        # version message for printing and stop parsing, append the
        # message to the previous error messages or set the argument's
        # value or prefix. In case of arguments given multiple times,
        # i.e., when the key already exists in ${!args[@]}, add the new
        # value or prefix to the previously given ones.
        for message in "${messages[@]}"; do
            case "${message}" in
                Help) is_help=true ;;
                Usage) is_usage=true ;;
                Version) is_version=true ;;
                ${translated_error}*)
                    error_messages+=("${message}")
                    ;;
                Positional_Start)
                    # Set the flag that the positional-only arguments
                    # delimiter "--" has been set, such that all
                    # following arguments are interpreted as positional.
                    is_positional=true
                    is_positional_only=true
                    ;;
                Positional_End)
                    # Set the flag that the positional-only arguments
                    # delimiter "++" has been set (and thus "--" has
                    # been unset), such that all following arguments are
                    # interpreted as usual.
                    is_positional=true
                    is_positional_only=false
                    ;;
                Argument*)
                    # Set the current argument name.
                    is_positional=false
                    arg_key="${message#Argument: }"
                    ;;
                Prefix*)
                    # Set the current argument's prefix ("-" or "+").
                    prefix="${message#Prefix: }"
                    if ! argparser_in_array "${arg_key}" "${!prefixes[@]}"; then
                        prefixes[${arg_key}]="${prefix}"
                    else
                        prefixes[${arg_key}]+="${ARGPARSER_ARG_DELIMITER_2}"
                        prefixes[${arg_key}]+="${prefix}"
                    fi
                    ;;
                Value*)
                    # Set the current argument's value.
                    value="${message#Value: }"
                    if [[ "${is_positional}" == true ]]; then
                        given_positional_args+=("${value}")
                    elif ! argparser_in_array "${arg_key}" "${!args[@]}"; then
                        args[${arg_key}]="${value}"
                    else
                        args[${arg_key}]+="${ARGPARSER_ARG_DELIMITER_2}"
                        args[${arg_key}]+="${value}"
                    fi
                    ;;
                Logo) is_logo=true ;;
            esac
        done
    done

    # If the help, usage, or version message, or the logo was requested
    # (in this order of priority), print it.
    if [[ "${is_help}" == true ]]; then
        argparser_print_help_or_usage_message "help" true 1
    elif [[ "${is_usage}" == true ]]; then
        argparser_print_help_or_usage_message "usage" true 1
    elif [[ "${is_version}" == true ]]; then
        argparser_print_version_message true 1
    elif [[ "${is_logo}" == true ]]; then
        argparser_print_logo
        exit
    fi

    # Parse the script's given positional arguments, that are yet only
    # assigned to a single indexed array.
    messages=( )
    argparser_parse_positional_args "${given_positional_args[@]}"

    # Read the output message and either append the message to the
    # previous error messages or set the argument's value.  Again, in
    # case of arguments given multiple times, i.e., when the key already
    # exists in ${!args[@]}, add the new value to the previously given
    # ones.
    for message in "${messages[@]}"; do
        case "${message}" in
            ${translated_error}*) error_messages+=("${message}") ;;
            Argument*) arg_key="${message#Argument: }" ;;
            Value*)
                # Set the current argument's value.
                value="${message#Value: }"
                if ! argparser_in_array "${arg_key}" "${!args[@]}"; then
                    args[${arg_key}]="${value}"
                else
                    args[${arg_key}]+="${ARGPARSER_ARG_DELIMITER_2}"
                    args[${arg_key}]+="${value}"
                fi
                ;;
        esac
    done

    # Sort, filter, colorize, and print all error messages.
    argparser_print_error_or_warning_message "error" true false \
        "${error_messages[@]}"

    # If any argument was not or wrongly given (i.e., there were
    # errors), print a blank line and the usage message and abort the
    # script.
    if (( "${#error_messages[@]}" > 0 )); then
        if [[ "${ARGPARSER_SILENCE_ERRORS}" == false ]]; then
            printf '\n' >&2
            argparser_print_help_or_usage_message "usage" false 2 >&2
        fi
        exit "${ARGPARSER_ERROR_EXIT_CODE}"
    fi

    # Check the arguments' values.
    error_messages=( )
    warning_messages=( )
    for arg_key in "${!all_short_options[@]}" "${all_positional_args[@]}"; do
        # Check which defined argument is given to the script.  Omitted
        # arguments or those without value are assigned the empty string
        # as prefix and/or value. This is then interpreted as hint for
        # the argument's or value's absence.
        if argparser_in_array "${arg_key}" "${!prefixes[@]}"; then
            prefix="${prefixes[${arg_key}]}"
        else
            prefix=""
        fi

        if argparser_in_array "${arg_key}" "${!args[@]}"; then
            values="${args[${arg_key}]}"
        else
            values=""
        fi

        # Check the argument's values.
        messages=( )
        argparser_check_arg_values "${arg_key}" "${prefix}" "${values}"

        # Read the output message and either append the message to the
        # previous error or warning messages or set the argument's
        # values.
        values=""
        for message in "${messages[@]}"; do
            case "${message}" in
                ${translated_error}*) error_messages+=("${message}") ;;
                ${translated_warning}*) warning_messages+=("${message}") ;;
                Value*) values="${message#Value: }" ;;
            esac
        done

        # Assign the checked values to the argument.
        args[${arg_key}]="${values}"
    done

    # Sort, filter, colorize, and print all error and warning messages.
    argparser_print_error_or_warning_message "error" true false \
        "${error_messages[@]}"
    argparser_print_error_or_warning_message "warning" true false \
        "${warning_messages[@]}"

    # If any argument was not or wrongly given (i.e., there were errors
    # and not just warnings), print a blank line and the usage message
    # and abort the script.
    if (( "${#error_messages[@]}" > 0 )); then
        if [[ "${ARGPARSER_SILENCE_ERRORS}" == false ]]; then
            printf '\n' >&2
            argparser_print_help_or_usage_message "usage" false 2 >&2
        fi
        exit "${ARGPARSER_ERROR_EXIT_CODE}"
    fi

    # Copy the values of the associative array ${args} to the variable
    # ${ARGPARSER_ARG_ARRAY_NAME} refers to.  Thereby, declare prints
    # the array contents stored in ${args}, which then gets stripped
    # from the leading assignment (before the equals sign ("=")) and set
    # to the new associative array with the name of
    # ${ARGPARSER_ARG_ARRAY_NAME}.

    # shellcheck disable=SC2178  # Intentional string, not array.
    args="$(declare -p args)"
    declare -g -A "${ARGPARSER_ARG_ARRAY_NAME}"="${args#*=}"

    # Depending on the value of ${is_extglob_set}, which uses shopt's
    # feature of storing the extglob state in a format reusable as
    # input, possibly disable extglob.
    eval "${is_extglob_set}"
}

function argparser_set_args() {
    # Set the keyword and positional arguments to global variables.
    #
    # Globals:
    # - ${${ARGPARSER_ARG_ARRAY_NAME}[@]}: the parsed and checked
    #   arguments with key and value as associative array, which
    #   ${ARGPARSER_ARG_ARRAY_NAME} refers to (read-only)
    # - ${!${ARGPARSER_ARG_ARRAY_NAME}[@]}: all argument identifiers
    #   found in ${${ARGPARSER_ARG_ARRAY_NAME}[@]}
    #
    # Environment:
    # - ARGPARSER_ARG_ARRAY_NAME (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_SET_ARRAYS (read-only)

    # Define the local variable.
    local arg_key

    # Get the associative array ${ARGPARSER_ARG_ARRAY_NAME} refers to.
    # If it is already "args" (the default name), nothing needs to be
    # done, but other variable names need to be mapped to "args" to be
    # able to refer to the variable by name.  Thus, declare prints the
    # array contents stored in the variable ${ARGPARSER_ARG_ARRAY_NAME}
    # refers to, which then gets stripped from the leading assignment
    # (before the equals sign ("=")) and set to the new associative
    # array ${args}.
    if [[ "${ARGPARSER_ARG_ARRAY_NAME}" != "args" ]]; then
        local args
        args="$(declare -p "${ARGPARSER_ARG_ARRAY_NAME}")"
        local -A args="${args#*=}"
    fi

    # Set the arguments.
    for arg_key in "${!args[@]}"; do
        if [[ "${args[${arg_key}]}" == *"${ARGPARSER_ARG_DELIMITER_2}"*
            && "${ARGPARSER_SET_ARRAYS}" == true ]]
        then
            # Set the argument, which includes the
            # ${ARGPARSER_ARG_DELIMITER_2} and hence is a sequence of
            # elements, as indexed array variable, while keeping it in
            # ${args} for usage by the calling script.
            declare -g -a "${arg_key}"

            # shellcheck disable=SC2229  # Indirect variable reference.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a "${arg_key}" \
                <<< "${args[${arg_key}]}"
        else
            # Set the keyword argument as variable, while keeping it in
            # ${args} for potential usage by the calling script.
            declare -g "${arg_key}"="${args[${arg_key}]}"
        fi
    done
}

# Define the argparser functions for creating and printing the help,
# usage, and version messages, as well as for printing error and warning
# messages, and the argparser logo.
function argparser_create_help_message() {
    # Create a help message for the script's arguments.
    #
    # Nonlocals:
    # - all_arg_groups: the associative array holding the argument
    #   groups (read-only)
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_choice_values: the associative array holding the choice
    #   values (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_help_texts: the associative array holding the help texts
    #   (read-only)
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - all_notes: the associative array holding the notes (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - all_value_names: the associative array holding the value names
    #   (read-only)
    # - help_message_groups: the associative array holding the help
    #   message's groups usable as include directive
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_1 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_2 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_3 (read-only)
    # - ARGPARSER_POSITIONAL_ARG_GROUP (read-only)
    # - ARGPARSER_SCRIPT_NAME (read-only)
    # - ARGPARSER_USE_LONG_OPTIONS (read-only)
    # - ARGPARSER_USE_SHORT_OPTIONS (read-only)

    # Define the local variables.
    local -a all_option_names
    local arg_group
    local -a arg_groups
    local arg_key
    local arg_number
    local choice_values
    local -a col_1
    local -a col_2
    local -a col_3
    local col_width_1
    local col_width_2
    local col_width_3
    local count
    local default_values
    local has_default_args
    local has_required_args
    local help_message
    local help_text
    local i
    local index
    local is_deprecated
    local j
    local joined_words
    local largest_col_width
    local line_count_1
    local line_count_2
    local line_count_3
    local lines_col_1
    local lines_col_2
    local lines_col_3
    local long_option
    local -a long_options
    local max_line_count
    local -a new_col_1
    local new_col_1_value
    local -a new_col_2
    local new_col_2_value
    local -a new_col_3
    local new_col_3_value
    local newline_count_1
    local newline_count_2
    local newline_count_3
    local newlines_1
    local newlines_2
    local newlines_3
    local note
    local -a notes
    local -a option_names
    local remark
    local short_option
    local -a short_options
    local -A sorted_col_1
    local -A sorted_col_2
    local -A sorted_col_3
    local translation
    local usage
    local -a value_names
    local -a whitespace_1
    local -a whitespace_2
    local whitespace_len_1
    local whitespace_len_2

    # Read the arguments' groups to sort the keyword arguments by group
    # in the help message.  To this end, compare each argument's group
    # later upon iterating over them.
    arg_groups=( )
    for arg_group in "${all_arg_groups[@]}"; do
        if [[ "${arg_group}" != "${ARGPARSER_POSITIONAL_ARG_GROUP}" ]] \
            && ! argparser_in_array "${arg_group}" "${arg_groups[@]}"
        then
            arg_groups+=("${arg_group}")
        fi
    done

    # The help message is structured in three columns: short options,
    # long options and the help text.  Populate these columns with the
    # entries for each argument.
    col_1=( )
    col_2=( )
    col_3=( )

    has_default_args=false
    has_required_args=false

    # Compute the columns for the positional arguments.
    for arg_key in "${all_positional_args[@]}"; do
        # Read the argument's definition.
        value_names="${all_value_names[${arg_key}]}"
        default_values="${all_default_values[${arg_key}]}"
        choice_values="${all_choice_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a notes \
            <<< "${all_notes[${arg_key}]}"
        help_text="${all_help_texts[${arg_key}]}"

        # Set a flag whether the argument is deprecated.
        is_deprecated=false
        for note in "${notes[@]}"; do
            if [[ "${note}" == "deprecated" ]]; then
                is_deprecated=true
            fi
        done

        # Define the columns' next line, for the current argument.  The
        # argument may have some default and some choice values with the
        # existence of each changing  the look of the first column.
        # Set the first column's value.
        if [[ "${choice_values}" != "-" && "${default_values}" != "-" ]]
        then  # Choice and default.
            col_1+=("[${value_names}={${choice_values}}]")
        elif [[ "${choice_values}" != "-" ]]; then  # Choice only.
            col_1+=("${value_names}={${choice_values}}")
        elif [[ "${default_values}" != "-" ]]; then  # Default only.
            col_1+=("[${value_names}]")
        else  # No choice nor default.
            col_1+=("${value_names}")
        fi

        # Set the second column's value.
        col_2+=("")

        # Set the third column's value.
        if [[ "${default_values}" != "-" && "${is_deprecated}" == true ]]
        then  # Default and deprecated.
            argparser_translate "Deprecated" "DEPRECATED"
            new_col_3_value="(${translation}) "
            new_col_3_value+="${help_text} ("
            argparser_translate "Default" "default"
            new_col_3_value+="${translation}: "
            new_col_3_value+="${default_values})"
            col_3+=("${new_col_3_value}")
        elif [[ "${default_values}" != "-" ]]; then  # Default only
            new_col_3_value="${help_text} ("
            argparser_translate "Default" "default"
            new_col_3_value+="${translation}: "
            new_col_3_value+="${default_values})"
            col_3+=("${new_col_3_value}")
        elif [[ "${is_deprecated}" == true ]]; then  # Deprecated only.
            argparser_translate "Deprecated" "DEPRECATED"
            new_col_3_value="(${translation}) "
            new_col_3_value+="${help_text}"
            col_3+=("${new_col_3_value}")
        else  # No default nor deprecated.
            col_3+=("${help_text}")
        fi
    done

    # To mark the end of an argument group later upon printing, add an
    # empty line in all three columns.  This cannot appear by chance,
    # whereas empty lines for single columns emerge from the line break
    # insertion when they are differently long.  Thus, a completely
    # empty line can be used as safe argument group delimiter.
    col_1+=("")
    col_2+=("")
    col_3+=("")

    # Compute the columns for the keyword arguments.
    for arg_group in "${arg_groups[@]}"; do
        new_col_1=( )
        new_col_2=( )
        new_col_3=( )
        all_option_names=( )

        for arg_key in "${!all_short_options[@]}"; do
            # Read the argument's group to check whether it belongs to
            # the current group.
            if [[ "${all_arg_groups[${arg_key}]}" != "${arg_group}" ]]; then
                continue
            fi

            # Read the argument's remaining definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
                <<< "${all_short_options[${arg_key}]}"
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
                <<< "${all_long_options[${arg_key}]}"
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a value_names \
                <<< "${all_value_names[${arg_key}]}"
            default_values="${all_default_values[${arg_key}]}"
            choice_values="${all_choice_values[${arg_key}]}"
            arg_number="${all_arg_numbers[${arg_key}]}"
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a notes \
                <<< "${all_notes[${arg_key}]}"
            help_text="${all_help_texts[${arg_key}]}"

            # Concatenate the name of all short and long options for the
            # sorting of all arguments, later.
            argparser_get_option_names "${arg_key}" "long-short"
            all_option_names+=("${option_names}")

            # Set a flag whether the option has default values for
            # adjustment of the help message header, later.
            if [[ "${default_values}" != "-" ]]; then
                has_default_args=true
            else
                has_required_args=true
            fi

            # Set a flag whether the option is deprecated.
            is_deprecated=false
            for note in "${notes[@]}"; do
                if [[ "${note}" == "deprecated" ]]; then
                    is_deprecated=true
                fi
            done

            # Define the columns' next line, for the current argument.
            # The argument may have some short and long options, along
            # with value names, some default and some choice values or
            # an argument number of 0 (i.e., it is a flag), with the
            # existence of each changing  the look of the respective
            # column.  If either no short or no long option is given,
            # use the empty string instead.
            # Set the first column's value.
            if [[ "${short_options[0]}" == "-" ]]; then  # No short option.
                new_col_1_value=""
            elif [[ "${long_options[0]}" == "-" ]]; then  # No long option.
                if [[ "${arg_number}" == 0 ]]; then  # Flag.
                    new_col_1_value="["
                    for short_option in "${short_options[@]}"; do
                        new_col_1_value+="-${short_option}, "
                    done
                    new_col_1_value="${new_col_1_value%, }"
                    new_col_1_value+="]"
                elif [[ "${choice_values}" != "-" \
                    && "${default_values}" != "-" ]]
                then  # Choice and default.
                    new_col_1_value=""
                    for short_option in "${short_options[@]}"; do
                        new_col_1_value+="[-${short_option}="
                        new_col_1_value+="{${choice_values}}], "
                    done
                    new_col_1_value="${new_col_1_value%, }"
                elif [[ "${choice_values}" != "-" ]]; then  # Choice only.
                    new_col_1_value=""
                    for short_option in "${short_options[@]}"; do
                        new_col_1_value+="-${short_option}="
                        new_col_1_value+="{${choice_values}}, "
                    done
                    new_col_1_value="${new_col_1_value%, }"
                elif [[ "${default_values}" != "-" ]]; then  # Default only.
                    new_col_1_value=""
                    for i in "${!short_options[@]}"; do
                        new_col_1_value+="[-${short_options[i]}="
                        new_col_1_value+="${value_names[i]:-${short_options[i]^^}}], "
                    done
                    new_col_1_value="${new_col_1_value%, }"
                else  # No choice nor default.
                    new_col_1_value=""
                    for i in "${!short_options[@]}"; do
                        new_col_1_value+="-${short_options[i]}="
                        new_col_1_value+="${value_names[i]:-${short_options[i]^^}}, "
                    done
                    new_col_1_value="${new_col_1_value%, }"
                fi
            elif [[ "${arg_number}" == 0 ]]; then  # Long option, flag.
                new_col_1_value="["
                for short_option in "${short_options[@]}"; do
                    new_col_1_value+="-${short_option}, "
                done
                new_col_1_value="${new_col_1_value%, }"
                new_col_1_value+="],"
            else  # Long option, non-flag.
                new_col_1_value=""
                for short_option in "${short_options[@]}"; do
                    new_col_1_value+="-${short_option}, "
                done
            fi
            new_col_1+=("${new_col_1_value}")

            # Set the second column's value.
            if [[ "${long_options[0]}" == "-" ]]; then  # No long option.
                new_col_2+=("")
            elif [[ "${arg_number}" == 0 ]]; then  # Flag.
                new_col_2_value="["
                for long_option in "${long_options[@]}"; do
                    new_col_2_value+="--${long_option}, "
                done
                new_col_2_value="${new_col_2_value%, }"
                new_col_2_value+="]"
                new_col_2+=("${new_col_2_value}")
            elif [[ "${choice_values}" != "-" && "${default_values}" != "-" ]]
            then  # Choice and default.
                new_col_2_value=""
                for long_option in "${long_options[@]}"; do
                    new_col_2_value+="[--${long_option}={${choice_values}}], "
                done
                new_col_2_value="${new_col_2_value%, }"
                new_col_2+=("${new_col_2_value}")
            elif [[ "${choice_values}" != "-" ]]; then  # Choice only.
                new_col_2_value=""
                for long_option in "${long_options[@]}"; do
                    new_col_2_value+="--${long_option}={${choice_values}}, "
                done
                new_col_2_value="${new_col_2_value%, }"
                new_col_2+=("${new_col_2_value}")
            elif [[ "${default_values}" != "-" ]]; then  # Default only.
                new_col_2_value=""
                for i in "${!long_options[@]}"; do
                    new_col_2_value+="[--${long_options[i]}="
                    new_col_2_value+="${value_names[i]:-${long_options[i]^^}}], "
                done
                new_col_2_value="${new_col_2_value%, }"
                new_col_2+=("${new_col_2_value}")
            else  # No choice nor default.
                new_col_2_value=""
                for i in "${!long_options[@]}"; do
                    new_col_2_value+="--${long_options[i]}="
                    new_col_2_value+="${value_names[i]:-${long_options[i]^^}}, "
                done
                new_col_2_value="${new_col_2_value%, }"
                new_col_2+=("${new_col_2_value}")
            fi

            # Set the third column's value.
            if [[ "${arg_number}" == 0  && "${is_deprecated}" == true ]]
            then  # Flag and deprecated.
                argparser_translate "Deprecated" "DEPRECATED"
                new_col_3_value="(${translation}) "
                new_col_3_value+="${help_text} ("
                argparser_translate "Default" "default"
                new_col_3_value+="${translation}: "
                argparser_translate "${default_values}" "${default_values}"
                new_col_3_value+="${translation})"
                new_col_3+=("${new_col_3_value}")
            elif [[ "${arg_number}" == 0 ]]; then  # Flag only.
                new_col_3_value="${help_text} ("
                argparser_translate "Default" "default"
                new_col_3_value+="${translation}: "
                argparser_translate "${default_values}" "${default_values}"
                new_col_3_value+="${translation})"
                new_col_3+=("${new_col_3_value}")
            elif [[ "${default_values}" != "-" && "${is_deprecated}" == true ]]
            then  # Default and deprecated.
                argparser_translate "Deprecated" "DEPRECATED"
                new_col_3_value="(${translation}) "
                new_col_3_value+="${help_text} ("
                argparser_translate "Default" "default"
                new_col_3_value+="${translation}: "
                new_col_3_value+="${default_values})"
                new_col_3+=("${new_col_3_value}")
            elif [[ "${default_values}" != "-" ]]; then  # Default only
                new_col_3_value="${help_text} ("
                argparser_translate "Default" "default"
                new_col_3_value+="${translation}: "
                new_col_3_value+="${default_values})"
                new_col_3+=("${new_col_3_value}")
            elif [[ "${is_deprecated}" == true ]]; then  # Deprecated only.
                argparser_translate "Deprecated" "DEPRECATED"
                new_col_3_value="(${translation}) "
                new_col_3_value+="${help_text}"
                new_col_3+=("${new_col_3_value}")
            else  # No default nor deprecated.
                new_col_3+=("${help_text}")
            fi
        done

        # Sort the arguments by the option names.  To this end, three
        # associative arrays are defined that use the option names as
        # keys and the first, second, or third column's values as
        # values.  Then, the option names' indexed array gets sorted and
        # the indexed arrays for the first, second, and third columns
        # are re-populated using the values from the associative array,
        # such that the sorted option names define the order of the yet
        # unsorted columns.  As a consequence, all columns are sorted as
        # if they would have been sorted together (which appears not be
        # feasible).
        for i in "${!all_option_names[@]}"; do
            sorted_col_1[${all_option_names[i]}]="${new_col_1[i]}"
            sorted_col_2[${all_option_names[i]}]="${new_col_2[i]}"
            sorted_col_3[${all_option_names[i]}]="${new_col_3[i]}"
        done

        mapfile -d "" -t all_option_names \
            < <(argparser_sort false "${all_option_names[@]}")

        for i in "${!all_option_names[@]}"; do
            col_1+=("${sorted_col_1[${all_option_names[i]}]}")
            col_2+=("${sorted_col_2[${all_option_names[i]}]}")
            col_3+=("${sorted_col_3[${all_option_names[i]}]}")
        done

        # To mark the end of an argument group later upon printing, add
        # an empty line in all three columns.  This cannot appear by
        # chance, whereas empty lines for single columns emerge from the
        # line break insertion when they are differently long.  Thus, a
        # completely empty line can be used as safe argument group
        # delimiter.
        col_1+=("")
        col_2+=("")
        col_3+=("")
    done

    # Add the help, usage, and version flags that always exist (if
    # defined).
    if [[ "${ARGPARSER_ADD_HELP}" == true ]]; then
        if [[ "${ARGPARSER_USE_SHORT_OPTIONS}" == true
            && "${ARGPARSER_USE_LONG_OPTIONS}" == true ]]
        then
            col_1+=("-h,")
            col_2+=("--help")
        elif [[ "${ARGPARSER_USE_SHORT_OPTIONS}" == true ]]; then
            col_1+=("-h")
            col_2+=("")
        elif [[ "${ARGPARSER_USE_LONG_OPTIONS}" == true ]]; then
            col_1+=("")
            col_2+=("--help")
        else
            col_1+=("")
            col_2+=("")
        fi
        argparser_translate "--help" "display this help and exit"
        col_3+=("${translation}")
    fi

    if [[ "${ARGPARSER_ADD_USAGE}" == true ]]; then
        if [[ "${ARGPARSER_USE_SHORT_OPTIONS}" == true
            && "${ARGPARSER_USE_LONG_OPTIONS}" == true ]]
        then
            col_1+=("-u,")
            col_2+=("--usage")
        elif [[ "${ARGPARSER_USE_SHORT_OPTIONS}" == true ]]; then
            col_1+=("-u")
            col_2+=("")
        elif [[ "${ARGPARSER_USE_LONG_OPTIONS}" == true ]]; then
            col_1+=("")
            col_2+=("--usage")
        else
            col_1+=("")
            col_2+=("")
        fi
        argparser_translate "--usage" "display the usage and exit"
        col_3+=("${translation}")
    fi

    if [[ "${ARGPARSER_ADD_VERSION}" == true ]]; then
        if [[ "${ARGPARSER_USE_SHORT_OPTIONS}" == true
            && "${ARGPARSER_USE_LONG_OPTIONS}" == true ]]
        then
            col_1+=("-V,")
            col_2+=("--version")
        elif [[ "${ARGPARSER_USE_SHORT_OPTIONS}" == true ]]; then
            col_1+=("-V")
            col_2+=("")
        elif [[ "${ARGPARSER_USE_LONG_OPTIONS}" == true ]]; then
            col_1+=("")
            col_2+=("--version")
        else
            col_1+=("")
            col_2+=("")
        fi
        argparser_translate "--version" "display the version and exit"
        col_3+=("${translation}")
    fi

    # Limit the width of each column of the help message to
    # ${ARGPARSER_MAX_COL_WIDTH_*} by inserting line breaks.
    # Split the element of column 1.
    col_width_1=0
    for i in "${!col_1[@]}"; do
        argparser_fold "${col_1[i]}" "${ARGPARSER_MAX_COL_WIDTH_1}" \
            "${col_width_1}"
        col_1[i]="${joined_words}"
        col_width_1="${largest_col_width}"
    done

    # Split the element of column 2.
    col_width_2=0
    for i in "${!col_2[@]}"; do
        argparser_fold "${col_2[i]}" "${ARGPARSER_MAX_COL_WIDTH_2}" \
            "${col_width_2}"
        col_2[i]="${joined_words}"
        col_width_2="${largest_col_width}"
    done

    # Split the element of column 3.
    col_width_3=0
    for i in "${!col_3[@]}"; do
        argparser_fold "${col_3[i]}" "${ARGPARSER_MAX_COL_WIDTH_3}" \
            "${col_width_3}"
        col_3[i]="${joined_words}"
        col_width_3="${largest_col_width}"
    done

    # Adjust the number of line breaks between each column's rows, such
    # that each element shares the same number of rows.
    for i in "${!col_1[@]}"; do
        # Count the number of rows for each element.
        mapfile -t lines_col_1 <<< "${col_1[i]}"
        line_count_1="${#lines_col_1[@]}"

        mapfile -t lines_col_2 <<< "${col_2[i]}"
        line_count_2="${#lines_col_2[@]}"

        mapfile -t lines_col_3 <<< "${col_3[i]}"
        line_count_3="${#lines_col_3[@]}"

        # Get the largest line count.
        if (( line_count_1 > line_count_2 )); then
            if (( line_count_1 > line_count_3 )); then
                max_line_count="${line_count_1}"
            else
                max_line_count="${line_count_3}"
            fi
        else
            if (( line_count_2 > line_count_3 )); then
                max_line_count="${line_count_2}"
            else
                max_line_count="${line_count_3}"
            fi
        fi

        # Set the number of required line breaks to align each line.  If
        # the line count is 0, 1 is subtracted from the maximum line
        # count, such that the last line does not end in a line break.
        # The same holds true for a line count of greater than 0, where
        # normally 1 would have to be added.  This trailing newline
        # character gets added by the here string upon re-reading the
        # arrays, below.
        if (( line_count_1 == 0 )); then
            (( newline_count_1 = max_line_count - 1 ))
        else
            (( newline_count_1 = max_line_count - line_count_1 ))
        fi

        if (( line_count_2 == 0 )); then
            (( newline_count_2 = max_line_count - 1 ))
        else
            (( newline_count_2 = max_line_count - line_count_2 ))
        fi

        if (( line_count_3 == 0 )); then
            (( newline_count_3 = max_line_count - 1 ))
        else
            (( newline_count_3 = max_line_count - line_count_3 ))
        fi

        # To each element, add as many line breaks as computed.
        newlines_1=""
        for (( j = 0; j < newline_count_1; j++ )); do
            newlines_1+=$'\n'
        done
        col_1[i]+="${newlines_1}"

        newlines_2=""
        for (( j = 0; j < newline_count_2; j++ )); do
            newlines_2+=$'\n'
        done
        col_2[i]+="${newlines_2}"

        newlines_3=""
        for (( j = 0; j < newline_count_3; j++ )); do
            newlines_3+=$'\n'
        done
        col_3[i]+="${newlines_3}"
    done

    # Re-read in the columns' lines, such that each line makes up one
    # element of the array.  To this end, split the lines on newline
    # characters (that get stripped off the lines).  The here string
    # adds a trailing newline that acts as additional delimiter.  Else,
    # a line without line break would give the same number of lines
    # (one) as a line with one line break as trailing newline, since
    # line breaks act as trailing delimiters for mapfile, not as inner
    # separators.
    new_col_1=( )
    new_col_2=( )
    new_col_3=( )
    for i in "${!col_1[@]}"; do
        mapfile -t -O "${#new_col_1[@]}" new_col_1 <<< "${col_1[i]}"
        mapfile -t -O "${#new_col_2[@]}" new_col_2 <<< "${col_2[i]}"
        mapfile -t -O "${#new_col_3[@]}" new_col_3 <<< "${col_3[i]}"
    done

    # Store the lines back in the original columns' variables.
    col_1=("${new_col_1[@]}")
    col_2=("${new_col_2[@]}")
    col_3=("${new_col_3[@]}")

    # For proper alignment of the columns, whitespace must be used as
    # separation between shorter elements.  Compute the width for both
    # the first and the second column.  If a line is wider, set the
    # width to the respective value, as long as the width doesn't exceed
    # the limit set by ${ARGPARSER_MAX_COL_WIDTH_*}.
    col_width_1=0
    col_width_2=0
    for i in "${!col_1[@]}"; do
        if (( "${#col_1[i]}" <= ARGPARSER_MAX_COL_WIDTH_1 \
            && "${#col_1[i]}" > col_width_1 ))
        then
            col_width_1="${#col_1[i]}"
        fi

        if (( "${#col_2[i]}" <= ARGPARSER_MAX_COL_WIDTH_2 \
            && "${#col_2[i]}" > col_width_2 ))
        then
            col_width_2="${#col_2[i]}"
        fi
    done

    # Compute the length of whitespace between column 1 and 2, as well
    # as between column 2 and 3.  This length equals the column's
    # maximum width minus the current line's element's length plus 1 to
    # have at least one space as separation.  If the column width
    # exceeds the limit set by ${ARGPARSER_MAX_COL_WIDTH_*}, insert a
    # line break instead to make the following column's content begin on
    # the next line.  Then, insert as much whitespace as needed to align
    # the column with the other elements.  For column 1, this equals the
    # column's maximum width plus 1 (the mandatory separation), for
    # column 2, both columns' maximum widths plus 2 (twice the mandatory
    # separation).
    whitespace_1=( )
    whitespace_2=( )
    for i in "${!col_1[@]}"; do
        whitespace_1+=("")
        whitespace_2+=("")

        if (( "${#col_1[i]}" <= ARGPARSER_MAX_COL_WIDTH_1 )); then
            (( whitespace_len_1 = col_width_1 - "${#col_1[i]}" + 1 ))
            for (( j = 0; j < whitespace_len_1; j++ )); do
                whitespace_1[-1]+=" "
            done
        else
            (( whitespace_len_1 = col_width_1 + 1 ))
            whitespace_1[-1]+=$'\n '
            for (( j = 0; j < whitespace_len_1; j++ )); do
                whitespace_1[-1]+=" "
            done
        fi

        if (( "${#col_2[i]}" <= ARGPARSER_MAX_COL_WIDTH_2 )); then
            (( whitespace_len_2 = col_width_2 - "${#col_2[i]}" + 1 ))
            for (( j = 0; j < whitespace_len_2; j++ )); do
                whitespace_2[-1]+=" "
            done
        else
            (( whitespace_len_2 = col_width_1 + col_width_2 + 2 ))
            whitespace_2[-1]+=$'\n '
            for (( j = 0; j < whitespace_len_2; j++ )); do
                whitespace_2[-1]+=" "
            done
        fi
    done

    # Set the help message's usage line, including the script's name.
    argparser_translate "Usage" "Usage"
    usage="${translation}: ${ARGPARSER_SCRIPT_NAME}"

    # Add a hint for the optional keyword arguments (as summary), if
    # existing.
    if [[ "${has_default_args}" == true ]]; then
        argparser_translate "Options" "OPTIONS"
        usage+=" [${translation}]"
    fi

    # Add a hint for the mandatory keyword arguments (as summary), if
    # existing.
    if [[ "${has_required_args}" == true ]]; then
        argparser_translate "Arguments" "ARGUMENTS"
        usage+=" ${translation}"
    fi

    # Add the names of the positional arguments, if existing.
    if (( "${#all_positional_args[@]}" > 0 )); then
        usage+=" [--]"
        for arg_key in "${all_positional_args[@]}"; do
            value_names=("${all_value_names[${arg_key}]}")
            default_values="${all_default_values[${arg_key}]}"

            if [[ "${default_values}" != "-" ]]; then
                usage+=" [${value_names[0]}]"
            else
                usage+=" ${value_names[0]}"
            fi
        done
    fi

    usage+=$'\n'
    help_message_groups["Usage"]="${usage}"

    # Set the remark.
    remark="Mandatory arguments to long options are mandatory for short "
    remark+="options too"

    argparser_translate "Mandatory arguments" "${remark}"
    remark="${translation}."
    remark+=$'\n'
    help_message_groups["Remark"]="${remark}"

    # For each argument group, including the positional argument group
    # as first one, and the rest being sorted alphabetically, print its
    # arguments.
    index=0
    arg_groups=("${ARGPARSER_POSITIONAL_ARG_GROUP}" "${arg_groups[@]}")
    for arg_group in "${arg_groups[@]}"; do
        # Set the argument group's name for output.
        help_message="${arg_group}:"
        help_message+=$'\n'

        # For any argument line, output the three columns and their
        # delimiting whitespace.  If all three columns are empty, the
        # end of the current argument group has been reached.
        for (( i = index; i < "${#col_1[@]}"; i++ )); do
            if [[ -z "${col_1[i]}" && -z "${col_2[i]}" && -z "${col_3[i]}" ]]
            then
                break
            fi

            help_message+="${col_1[i]}${whitespace_1[i]}${col_2[i]}"
            help_message+="${whitespace_2[i]}${col_3[i]}"
            help_message+=$'\n'
        done
        help_message_groups[${arg_group}]="${help_message}"

        # Set the start index for the next argument group to the current
        # group's end index plus 1 (with the latter being the empty line
        # used as argument group delimiter).
        (( index = i + 1 ))
    done

    # Output the help, usage, and version lines, which are the last
    # three lines.  Thereby, count the number of "true" as value of the
    # respective environment variable, viz. ${ARGPARSER_ADD_HELP},
    # ${ARGPARSER_ADD_USAGE}, and ${ARGPARSER_ADD_VERSION}, to get the
    # number of lines to output.
    help_message=""
    argparser_count true "${ARGPARSER_ADD_HELP}" "${ARGPARSER_ADD_USAGE}" \
        "${ARGPARSER_ADD_VERSION}"
    if (( count == 3 )); then
        help_message+="${col_1[-3]}${whitespace_1[-3]}${col_2[-3]}"
        help_message+="${whitespace_2[-3]}${col_3[-3]}"
        help_message+=$'\n'
    fi
    if (( count >= 2 )); then
        help_message+="${col_1[-2]}${whitespace_1[-2]}${col_2[-2]}"
        help_message+="${whitespace_2[-2]}${col_3[-2]}"
        help_message+=$'\n'
    fi
    if (( count >= 1 )); then
        help_message+="${col_1[-1]}${whitespace_1[-1]}${col_2[-1]}"
        help_message+="${whitespace_2[-1]}${col_3[-1]}"
        help_message+=$'\n'
    fi
    help_message_groups["Help"]="${help_message}"
}

function argparser_create_usage_message() {
    # Create a usage message for the script's arguments.
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_choice_values: the associative array holding the choice
    #   values (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - all_value_names: the associative array holding the value names
    #   (read-only)
    # - usage_message_groups: the associative array holding the usage
    #   message's groups usable as include directive
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_SCRIPT_NAME (read-only)
    # - ARGPARSER_USAGE_MESSAGE_OPTION_TYPE(read-only)
    # - ARGPARSER_USAGE_MESSAGE_ORIENTATION (read-only)
    # - ARGPARSER_USE_LONG_OPTIONS (read-only)
    # - ARGPARSER_USE_SHORT_OPTIONS (read-only)

    # Define the local variables.
    local arg_key
    local arg_number
    local choice_values
    local default_values
    local header
    local i
    local line
    local -a lines
    local long_option
    local -a long_option_default_args
    local -a long_option_required_args
    local -a long_options
    local -a positional_default_args
    local -a positional_required_args
    local short_option
    local -a short_option_default_args
    local -a short_option_required_args
    local -a short_options
    local translation
    local usage_message
    local value_names
    local whitespace

    # Output the usage message's header, giving the script's name and
    # the existence of the -h | --help, -u | --usage, and -V | --version
    # arguments.
    argparser_translate "Usage" "Usage"
    header="${translation}: ${ARGPARSER_SCRIPT_NAME}"
    usage_message="${header}"

    if [[ ("${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" == "short" \
        && "${ARGPARSER_USE_SHORT_OPTIONS}" == true) \
        || "${ARGPARSER_USE_LONG_OPTIONS}" == false ]]
    then
        if [[ "${ARGPARSER_ADD_HELP}" == true \
            && "${ARGPARSER_ADD_USAGE}" == true \
            && "${ARGPARSER_ADD_VERSION}" == true ]]
        then
            usage_message+=" [-h | -u | -V]"
        elif [[ "${ARGPARSER_ADD_HELP}" == true \
            && "${ARGPARSER_ADD_USAGE}" == true ]]
        then
            usage_message+=" [-h | -u]"
        elif [[ "${ARGPARSER_ADD_HELP}" == true \
            && "${ARGPARSER_ADD_VERSION}" == true ]]
        then
            usage_message+=" [-h | -V]"
        elif [[ "${ARGPARSER_ADD_USAGE}" == true \
            && "${ARGPARSER_ADD_VERSION}" == true ]]
        then
            usage_message+=" [-u | -V]"
        elif [[ "${ARGPARSER_ADD_HELP}" == true ]]; then
            usage_message+=" [-h]"
        elif [[ "${ARGPARSER_ADD_USAGE}" == true ]]; then
            usage_message+=" [-u]"
        elif [[ "${ARGPARSER_ADD_VERSION}" == true ]]; then
            usage_message+=" [-V]"
        fi
    elif [[ ("${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" == "long" \
        && "${ARGPARSER_USE_LONG_OPTIONS}" == true) \
        || "${ARGPARSER_USE_SHORT_OPTIONS}" == false ]]
    then
        if [[ "${ARGPARSER_ADD_HELP}" == true \
            && "${ARGPARSER_ADD_USAGE}" == true \
            && "${ARGPARSER_ADD_VERSION}" == true ]]
        then
            usage_message+=" [--help | --usage | --version]"
        elif [[ "${ARGPARSER_ADD_HELP}" == true \
            && "${ARGPARSER_ADD_USAGE}" == true ]]
        then
            usage_message+=" [--help | --usage]"
        elif [[ "${ARGPARSER_ADD_HELP}" == true \
            && "${ARGPARSER_ADD_VERSION}" == true ]]
        then
            usage_message+=" [--help | --version]"
        elif [[ "${ARGPARSER_ADD_USAGE}" == true \
            && "${ARGPARSER_ADD_VERSION}" == true ]]
        then
            usage_message+=" [--usage | --version]"
        elif [[ "${ARGPARSER_ADD_HELP}" == true ]]; then
            usage_message+=" [--help]"
        elif [[ "${ARGPARSER_ADD_USAGE}" == true ]]; then
            usage_message+=" [--usage]"
        elif [[ "${ARGPARSER_ADD_VERSION}" == true ]]; then
            usage_message+=" [--version]"
        fi
    fi

    # To keep all arguments aligned in columnar output, compute the
    # length of the script name and the (translated) leading "Usage: ".
    # For a row-like orientation, only use one space.
    if [[ "${ARGPARSER_USAGE_MESSAGE_ORIENTATION}" == "column" ]]; then
        whitespace=$'\n '
        for (( i = 0; i < "${#header}"; i++ )); do
            whitespace+=" "
        done
    else
        whitespace=" "
    fi

    # If ${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE} is set to "short",
    # separate keyword arguments with default values from those without
    # to output first the arguments with default values and afterwards
    # those without.  Within either block, separate arguments with short
    # options from those without to output first the arguments with
    # short option names and then those with only long option names.  If
    # ${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE} is set to "long", do the
    # same for the long options and short option-only arguments.  In
    # both cases, having both short and long option names does not
    # matter as only one sort gets printed.
    short_option_default_args=( )
    short_option_required_args=( )
    long_option_default_args=( )
    long_option_required_args=( )
    if [[ "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" == "short" ]]; then
        for arg_key in "${!all_short_options[@]}"; do
            # Read the argument's definition.
            short_options="${all_short_options[${arg_key}]}"
            default_values="${all_default_values[${arg_key}]}"

            # Add the argument to the respective array.
            if [[ "${default_values}" == "-" ]]; then
                if [[ "${short_options}" == "-" ]]; then
                    long_option_required_args+=("${arg_key}")
                else
                    short_option_required_args+=("${arg_key}")
                fi
            else
                if [[ "${short_options}" == "-" ]]; then
                    long_option_default_args+=("${arg_key}")
                else
                    short_option_default_args+=("${arg_key}")
                fi
            fi
        done
    else
        for arg_key in "${!all_short_options[@]}"; do
            # Read the argument's definition.
            long_options="${all_long_options[${arg_key}]}"
            default_values="${all_default_values[${arg_key}]}"

            # Add the argument to the respective array.
            if [[ "${default_values}" == "-" ]]; then
                if [[ "${long_options}" == "-" ]]; then
                    short_option_required_args+=("${arg_key}")
                else
                    long_option_required_args+=("${arg_key}")
                fi
            else
                if [[ "${long_options}" == "-" ]]; then
                    short_option_default_args+=("${arg_key}")
                else
                    long_option_default_args+=("${arg_key}")
                fi
            fi
        done
    fi

    # Likewise, separate positional arguments with default values from
    # those without.
    positional_default_args=( )
    positional_required_args=( )
    for arg_key in "${all_positional_args[@]}"; do
        # Read the argument's definition.
        default_values="${all_default_values[${arg_key}]}"

        # Add the argument to the respective array.
        if [[ "${default_values}" == "-" ]]; then
            positional_required_args+=("${arg_key}")
        else
            positional_default_args+=("${arg_key}")
        fi
    done

    # Output each keyword argument with short options and default values
    # and sort them alphabetically.
    lines=( )
    for arg_key in "${short_option_default_args[@]}"; do
        # Read the argument's definition.
        short_options=("${all_short_options[${arg_key}]}")
        value_names="${all_value_names[${arg_key}]}"
        choice_values="${all_choice_values[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # If no value name is given, set them to the capitalized short
        # option names.
        if [[ "${value_names}" == "-" ]]; then
            value_names="${short_options[0]^^}"
        fi

        # Prefix the short options with one hyphen for their printing
        # style.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
            <<< "${short_options[0]}"
        short_options[0]="-${short_options[0]}"
        for short_option in "${short_options[@]:1}"; do
            short_options[0]+="${ARGPARSER_ARG_DELIMITER_2}-${short_option}"
        done
        short_options=("${short_options[0]}")

        # Define the line for the current argument.  The argument has
        # some short options and some default values and may have some
        # choice values or an argument number of 0 (i.e., it is a flag),
        # with the existence of each changing the look of the line.
        if [[ "${arg_number}" == 0 ]]; then  # Flag.
            lines+=("[${short_options[0]}]")
        elif [[ "${choice_values}" != "-" ]]; then  # Choice and default.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("[${short_options[0]}={${choice_values}}...]")
            else
                lines+=("[${short_options[0]}={${choice_values}}]")
            fi
        else  # Default only.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("[${short_options[0]}=${value_names}...]")
            else
                lines+=("[${short_options[0]}=${value_names}]")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        mapfile -d "" -t lines < <(argparser_sort false "${lines[@]}")
        for line in "${lines[@]}"; do
            usage_message+="${whitespace}${line}"
        done
    fi

    # Output each keyword argument with long options and default values
    # and sort them alphabetically.
    lines=( )
    for arg_key in "${long_option_default_args[@]}"; do
        # Read the argument's definition.
        long_options=("${all_long_options[${arg_key}]}")
        value_names="${all_value_names[${arg_key}]}"
        choice_values="${all_choice_values[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # If no value name is given, set them to the capitalized long
        # option names.
        if [[ "${value_names}" == "-" ]]; then
            value_names="${long_options[0]^^}"
        fi

        # Prefix the long options with two hyphens for their printing
        # style.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
            <<< "${long_options[0]}"
        long_options[0]="--${long_options[0]}"
        for long_option in "${long_options[@]:1}"; do
            long_options[0]+="${ARGPARSER_ARG_DELIMITER_2}--${long_option}"
        done
        long_options=("${long_options[0]}")

        # Define the line for the current argument.  The argument has
        # some long options and some default values and may have some
        # choice values or an argument number of 0 (i.e., it is a flag),
        # with the existence of each changing the look of the line.
        if [[ "${arg_number}" == 0 ]]; then  # Flag.
            lines+=("[${long_options[0]}]")
        elif [[ "${choice_values}" != "-" ]]; then  # Choice and default.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("[${long_options[0]}={${choice_values}}...]")
            else
                lines+=("[${long_options[0]}={${choice_values}}]")
            fi
        else  # Default only.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("[${long_options[0]}=${value_names}...]")
            else
                lines+=("[${long_options[0]}=${value_names}]")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        mapfile -d "" -t lines < <(argparser_sort false "${lines[@]}")
        for line in "${lines[@]}"; do
            usage_message+="${whitespace}${line}"
        done
    fi

    # Output each keyword argument with short options and without
    # default values and sort them alphabetically.
    lines=( )
    for arg_key in "${short_option_required_args[@]}"; do
        # Read the argument's definition.
        short_options=("${all_short_options[${arg_key}]}")
        value_names="${all_value_names[${arg_key}]}"
        choice_values="${all_choice_values[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # If no value name is given, set them to the capitalized short
        # option names.
        if [[ "${value_names}" == "-" ]]; then
            value_names="${short_options[0]^^}"
        fi

        # Prefix the short options with one hyphen for their printing
        # style.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
            <<< "${short_options[0]}"
        short_options[0]="-${short_options[0]}"
        for short_option in "${short_options[@]:1}"; do
            short_options[0]+="${ARGPARSER_ARG_DELIMITER_2}-${short_option}"
        done
        short_options=("${short_options[0]}")

        # Define the line for the current argument.  The argument has
        # some short options and no default values and may have some
        # choice values, with the existence of each changing the look of
        # the line.
        if [[ "${choice_values}" != "-" ]]; then  # Choice only.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("${short_options[0]}={${choice_values}}...")
            else
                lines+=("${short_options[0]}={${choice_values}}")
            fi
        else  # No choice nor default.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("${short_options[0]}=${value_names}...")
            else
                lines+=("${short_options[0]}=${value_names}")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        mapfile -d "" -t lines < <(argparser_sort false "${lines[@]}")
        for line in "${lines[@]}"; do
            usage_message+="${whitespace}${line}"
        done
    fi

    # Output each keyword argument with long options and without default
    # values and sort them alphabetically.
    lines=( )
    for arg_key in "${long_option_required_args[@]}"; do
        # Read the argument's definition.
        long_options=("${all_long_options[${arg_key}]}")
        value_names="${all_value_names[${arg_key}]}"
        choice_values="${all_choice_values[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # If no value name is given, set them to the capitalized long
        # option names.
        if [[ "${value_names}" == "-" ]]; then
            value_names="${long_options[0]^^}"
        fi

        # Prefix the long options with two hyphens for their printing
        # style.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
            <<< "${long_options[0]}"
        long_options[0]="--${long_options[0]}"
        for long_option in "${long_options[@]:1}"; do
            long_options[0]+="${ARGPARSER_ARG_DELIMITER_2}--${long_option}"
        done
        long_options=("${long_options[0]}")

        # Define the line for the current argument.  The argument has
        # some long options and no default values and may have some
        # choice values, with the existence of each changing the look of
        # the line.
        if [[ "${choice_values}" != "-" ]]; then  # Choice only.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("${long_options[0]}={${choice_values}}...")
            else
                lines+=("${long_options[0]}={${choice_values}}")
            fi
        else  # No choice nor default.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("${long_options[0]}=${value_names}...")
            else
                lines+=("${long_options[0]}=${value_names}")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        mapfile -d "" -t lines < <(argparser_sort false "${lines[@]}")
        for line in "${lines[@]}"; do
            usage_message+="${whitespace}${line}"
        done
    fi

    # Output each positional argument with default values and sort them
    # alphabetically.
    lines=( )
    for arg_key in "${positional_default_args[@]}"; do
        # Read the argument's definition.
        value_names="${all_value_names[${arg_key}]}"
        choice_values="${all_choice_values[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # Define the line for the current argument.  The argument has
        # some default values and may have some choice values, with the
        # existence of each changing the look of the line.
        if [[ "${choice_values}" != "-" ]]; then  # Choice and default.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("[{${choice_values}}...]")
            else
                lines+=("[{${choice_values}}]")
            fi
        else  # Default only.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("[${value_names}...]")
            else
                lines+=("[${value_names}]")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        mapfile -d "" -t lines < <(argparser_sort false "${lines[@]}")
        for line in "${lines[@]}"; do
            usage_message+="${whitespace}${line}"
        done
    fi

    # Output each positional argument without default values and sort
    # them alphabetically.
    lines=( )
    for arg_key in "${positional_required_args[@]}"; do
        # Read the argument's definition.
        value_names="${all_value_names[${arg_key}]}"
        choice_values="${all_choice_values[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # Define the line for the current argument.  The argument has no
        # default values and may have some choice values, with the
        # existence of each changing the look of the line.
        if [[ "${choice_values}" != "-" ]]; then  # Choice only.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("{${choice_values}}...")
            else
                lines+=("{${choice_values}}")
            fi
        else  # No choice nor default.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("${value_names}...")
            else
                lines+=("${value_names}")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        mapfile -d "" -t lines < <(argparser_sort false "${lines[@]}")
        for line in "${lines[@]}"; do
            usage_message+="${whitespace}${line}"
        done
    fi

    # Output the final usage message.
    usage_message+=$'\n'
    usage_message_groups["Usage"]="${usage_message}"
}

function argparser_print_help_or_usage_message() {
    # Print a help or usage message.  If a file with such is given,
    # print the file, else, create a message for the script's arguments.
    # For files, possibly skip commented lines (i.e., lines starting
    # with "#") and their trailing blank lines.  Replace lines starting
    # with ${ARGPARSER_*_FILE_INCLUDE_CHAR} by the auto-generated help
    #   or usage message.
    #
    # Arguments:
    # - $1: the help type ("help" or "usage")
    # - $2: whether to exit after printing
    # - $3: the file descriptor to write to (1 or 2)
    #
    # Nonlocals:
    # - all_arg_groups: the associative array holding the argument
    #   groups (read-only)
    # - help_message_groups: the associative array holding the help
    #   message's groups usable as include directive (read-only)
    # - usage_message_groups: the associative array holding the usage
    #   message's groups usable as include directive (read-only)
    #
    # Environment:
    # - ARGPARSER_HELP_EXIT_CODE (read-only)
    # - ARGPARSER_HELP_FILE (read-only)
    # - ARGPARSER_HELP_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_HELP_FILE_KEEP_COMMENTS (read-only)
    # - ARGPARSER_HELP_STYLE (read-only)
    # - ARGPARSER_POSITIONAL_ARG_GROUP (read-only)
    # - ARGPARSER_USAGE_EXIT_CODE (read-only)
    # - ARGPARSER_USAGE_FILE (read-only)
    # - ARGPARSER_USAGE_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_USAGE_FILE_KEEP_COMMENTS (read-only)
    # - ARGPARSER_USAGE_STYLE (read-only)

    # Define the local variables.
    local arg_group
    local -a arg_groups
    local error_message
    local -a error_messages
    local exit
    local exit_code
    local file
    local file_descriptor
    local help_type
    local include_char
    local include_directive
    local keep_comments
    local line
    local -a lines
    local line_type
    local message
    local style
    local translation

    # Read the arguments.
    help_type="$1"
    exit="$2"
    file_descriptor="$3"

    # Set the constants to the respective environment variables.
    if [[ "${help_type}" == "help" ]]; then
        file="${ARGPARSER_HELP_FILE}"
        include_char="${ARGPARSER_HELP_FILE_INCLUDE_CHAR}"
        keep_comments="${ARGPARSER_HELP_FILE_KEEP_COMMENTS}"
        style="${ARGPARSER_HELP_STYLE}"
        exit_code="${ARGPARSER_HELP_EXIT_CODE}"
    else
        file="${ARGPARSER_USAGE_FILE}"
        include_char="${ARGPARSER_USAGE_FILE_INCLUDE_CHAR}"
        keep_comments="${ARGPARSER_USAGE_FILE_KEEP_COMMENTS}"
        style="${ARGPARSER_USAGE_STYLE}"
        exit_code="${ARGPARSER_USAGE_EXIT_CODE}"
    fi

    # Read the keyword arguments' groups to sort them for the help
    # message.
    arg_groups=( )
    for arg_group in "${all_arg_groups[@]}"; do
        if [[ "${arg_group}" != "${ARGPARSER_POSITIONAL_ARG_GROUP}" ]] \
            && ! argparser_in_array "${arg_group}" "${arg_groups[@]}"
        then
            arg_groups+=("${arg_group}")
        fi
    done

    # Sort the argument groups and prepend the positional arguments
    # group.
    mapfile -d "" -t arg_groups < <(argparser_sort false "${arg_groups[@]}")
    arg_groups=("${ARGPARSER_POSITIONAL_ARG_GROUP}" "${arg_groups[@]}")

    # Create the help or usage message groups, which are saved in an
    # associative array using the include directives as keys.
    if [[ "${help_type}" == "help" ]]; then
        argparser_create_help_message
    else
        argparser_create_usage_message
    fi

    # Read the help or usage file, if given, or set the lines to just
    # the include directive "All", meaning to create the entire help or
    # usage message.
    if [[ -n "${file}" ]]; then
        mapfile -t lines < "${file}"
    else
        lines=("${include_char}All")
    fi

    # For each line, print the text and replace the include directives
    # by the respective part from the help or usage message.  Possibly,
    # skip comments.
    line_type="text"
    message=""
    for line in "${lines[@]}"; do
        # Set ${line_type} to "include directive" if the line contains
        # an include directive, to "comment" if the line is commented
        # and ${keep_comments} is false, and to "text" if it is not
        # empty (but not commented).  Thus, empty lines following
        # comments still have ${line_type} set to "comment".  For
        # include directives, add the requested groups from the help or
        # usage message.
        if [[ "${line::1}" == "${include_char}" ]]; then
            line_type="include directive"
            include_directive="${line:1}"
            if [[ "${help_type}" == "help" ]]; then
                if [[ "${include_directive}" == "All" ]]; then
                    message+="${help_message_groups["Usage"]}"
                    message+=$'\n'

                    message+="${help_message_groups["Remark"]}"
                    message+=$'\n'

                    for arg_group in "${arg_groups[@]}"; do
                        message+="${help_message_groups[${arg_group}]}"
                        message+=$'\n'
                    done

                    message+="${help_message_groups["Help"]}"
                elif [[ "${include_directive}" == "Header" ]]; then
                    message+="${help_message_groups["Usage"]}"
                    message+=$'\n'
                    message+="${help_message_groups["Remark"]}"
                elif argparser_in_array "${include_directive}" "Help" \
                    "Remark" "Usage"
                then
                    message+="${help_message_groups["${include_directive}"]}"
                elif argparser_in_array "${include_directive}" \
                    "${arg_groups[@]}"
                then
                    message+="${help_message_groups["${include_directive}"]}"
                else
                    error_message="Error: The include directive \"%s\" could "
                    error_message+="not be recognized."

                    argparser_translate "Error include directive" \
                        "${error_message}" "${include_directive}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi
            else
                if [[ "${include_directive}" == "All" ]]; then
                    message+="${usage_message_groups["Usage"]}"
                else
                    error_message="Error: The include directive \"%s\" could "
                    error_message+="not be recognized."

                    argparser_translate "Error include directive" \
                        "${error_message}" "${include_directive}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi
            fi
        elif [[ "${line::1}" == \# && "${keep_comments}" == false ]]; then
            line_type="comment"
        elif [[ -n "${line}" || "${keep_comments}" == true ]]; then
            line_type="text"
        fi

        # If ${line_type} has been set to "text", print the current
        # line.  If it is set to "include_directive", reset it to "text"
        # to (possibly) print the next line, and only not the current
        # "<ArgumentGroup>" line.
        if [[ "${line_type}" == "text" ]]; then
            message+="${line}"
            message+=$'\n'
        elif [[ "${line_type}" == "include directive" ]]; then
            line_type="text"
        fi
    done

    # Sort, filter, colorize, and print all error messages.
    argparser_print_error_or_warning_message "error" true false \
        "${error_messages[@]}"

    # Colorize and print the help or usage message, then exit, if
    # requested.
    argparser_colorize "${style}" "${message}" "${file_descriptor}" true

    if [[ "${exit}" == true ]]; then
        exit "${exit_code}"
    fi
}

function argparser_print_version_message() {
    # Create and print a version message.
    #
    # Arguments:
    # - $1: whether to exit after printing
    #
    # Environment:
    # - ARGPARSER_SCRIPT_NAME (read-only)
    # - ARGPARSER_SCRIPT_VERSION (read-only)
    # - ARGPARSER_SCRIPT_VERSION_EXIT_CODE (read-only)
    # - ARGPARSER_SCRIPT_VERSION_STYLE (read-only)

    # Define the local variables.
    local exit
    local message
    local style

    # Read the argument.
    exit="$1"

    # Colorize and print the version message, then exit, if requested.
    message="${ARGPARSER_SCRIPT_NAME} v${ARGPARSER_SCRIPT_VERSION}"
    argparser_colorize "${ARGPARSER_SCRIPT_VERSION_STYLE}" "${message}" 1 true
    printf '\n'

    if [[ "${exit}" == true ]]; then
        exit "${ARGPARSER_SCRIPT_VERSION_EXIT_CODE}"
    fi
}

function argparser_print_error_or_warning_message() {
    # Sort, filter, colorize, and print all error or warning messages.
    #
    # Arguments:
    # - $1: the error type ("error" or "warning")
    # - $2: whether to filter the messages (by argparser_uniq)
    # - $3: whether to exit after printing
    # - $@: the error or warning messages
    #
    # Environment:
    # - ARGPARSER_ERROR_EXIT_CODE (read-only)
    # - ARGPARSER_ERROR_STYLE (read-only)
    # - ARGPARSER_SCRIPT_NAME (read-only)
    # - ARGPARSER_SILENCE_ERRORS (read-only)
    # - ARGPARSER_SILENCE_WARNINGS (read-only)
    # - ARGPARSER_WARNING_STYLE (read-only)

    # Define the local variables.
    local exit
    local filter
    local message
    local -a messages
    local style
    local error_type

    # Read the arguments.
    error_type="$1"
    filter="$2"
    exit="$3"
    shift 3
    messages=("$@")

    # Set the colorization style.  If the error or warning message shall
    # not be emitted (output), return or exit, effectively silencing the
    # message.
    if [[ "${error_type}" == "error" ]]; then
        if [[ "${ARGPARSER_SILENCE_ERRORS}" == true ]]; then
            if [[ "${exit}" == true ]]; then
                exit "${ARGPARSER_ERROR_EXIT_CODE}"
            else
                return
            fi
        fi

        style="${ARGPARSER_ERROR_STYLE}"
    elif [[ "${error_type}" == "warning" ]]; then
        if [[ "${ARGPARSER_SILENCE_WARNINGS}" == true ]]; then
            return
        fi

        style="${ARGPARSER_WARNING_STYLE}"
    fi

    # Sort, filter, colorize, and print all error or warning messages,
    # then exit, if requested.
    if (( "${#messages[@]}" > 0 )); then
        # Prepend the script name, if given.
        for i in "${!messages[@]}"; do
            if [[ -n "${ARGPARSER_SCRIPT_NAME}" ]]; then
                messages[i]="${ARGPARSER_SCRIPT_NAME}: ${messages[i]}"
            fi
        done

        # Sort and filter the messages.
        mapfile -d "" -t messages < <(argparser_sort false "${messages[@]}")

        if [[ "${filter}" == true ]]; then
            mapfile -d "" -t messages < <(argparser_uniq "${messages[@]}")
        fi

        # Colorize the messages, if writing to a terminal or the escape
        # sequences shall be included in the file.  The test assumes
        # that argparser_print_error_or_warning_message is never run
        # through command substitution, else [[ -t ${file_descriptor} ]]
        # would always be false, i.e., it would impossible to tell if
        # the final STDOUT/STDERR goes to a terminal.
        argparser_colorize "${style}" "" 2 false
        {
            # shellcheck disable=SC2059  # Escape sequence in variable.
            printf "${style}"
            printf "%s\n" "${messages[@]}"
            if [[ "${ARGPARSER_USE_STYLES_IN_FILES}" == true \
                || -t "${file_descriptor}" ]]
            then
                printf '\e[0m'
            fi
        } >&2

        if [[ "${exit}" == true ]]; then
            exit "${ARGPARSER_ERROR_EXIT_CODE}"
        fi
    fi
}

function argparser_print_logo() {
    # Print the argparser logo in ANSI art.

    # Define the local variables.
    local font_1
    local font_2
    local font_3
    local font_4
    local font_5
    local font_6
    local font_7
    local font_8
    local font_9
    local space
    local style

    # Set each letter's color as all primary and secondary colors,
    # traversing the color wheel for one and a half rounds.
    space="black,reverse"     # _ (whitespace)
    font_1="green,reverse"    # A
    font_2="cyan,reverse"     # R
    font_3="blue,reverse"     # G
    font_4="magenta,reverse"  # P
    font_5="red,reverse"      # A
    font_6="yellow,reverse"   # R
    font_7="green,reverse"    # S
    font_8="cyan,reverse"     # E
    font_9="blue,reverse"     # R

    # Output the first line, which is empty.
    argparser_colorize "${space}" "                              " 1 true  # _
    argparser_colorize "${space}" "                              " 1 true  # _
    argparser_colorize "${space}" "              " 1 true                  # _
    printf '\n'

    # Output the second line, containing the first of five lines of the
    # letters.
    argparser_colorize "${space}" "   " 1 true      # _, A
    argparser_colorize "${font_1}" "    " 1 true    # A
    argparser_colorize "${space}" "    " 1 true     # A, _, R
    argparser_colorize "${font_2}" "    " 1 true    # R
    argparser_colorize "${space}" "    " 1 true     # R, _, G
    argparser_colorize "${font_3}" "     " 1 true   # G
    argparser_colorize "${space}" "   " 1 true      # _, P
    argparser_colorize "${font_4}" "    " 1 true    # P
    argparser_colorize "${space}" "    " 1 true     # P, _, A
    argparser_colorize "${font_5}" "    " 1 true    # A
    argparser_colorize "${space}" "    " 1 true     # A, _, R
    argparser_colorize "${font_6}" "    " 1 true    # R
    argparser_colorize "${space}" "    " 1 true     # R, _, S
    argparser_colorize "${font_7}" "     " 1 true   # S
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_8}" "      " 1 true  # E
    argparser_colorize "${space}" "   " 1 true      # _, R
    argparser_colorize "${font_9}" "    " 1 true    # R
    argparser_colorize "${space}" "   " 1 true      # R, _
    printf '\n'

    # Output the third line, containing the second of five lines of the
    # letters.
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_1}" "  " 1 true      # A
    argparser_colorize "${space}" "  " 1 true       # A
    argparser_colorize "${font_1}" "  " 1 true      # A
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_2}" "  " 1 true      # R
    argparser_colorize "${space}" "  " 1 true       # R
    argparser_colorize "${font_2}" "  " 1 true      # R
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_3}" "  " 1 true      # G
    argparser_colorize "${space}" "      " 1 true   # G, _
    argparser_colorize "${font_4}" "  " 1 true      # P
    argparser_colorize "${space}" "  " 1 true       # P
    argparser_colorize "${font_4}" "  " 1 true      # P
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_5}" "  " 1 true      # A
    argparser_colorize "${space}" "  " 1 true       # A
    argparser_colorize "${font_5}" "  " 1 true      # A
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_6}" "  " 1 true      # R
    argparser_colorize "${space}" "  " 1 true       # R
    argparser_colorize "${font_6}" "  " 1 true      # R
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_7}" "  " 1 true      # S
    argparser_colorize "${space}" "      " 1 true   # S, _
    argparser_colorize "${font_8}" "  " 1 true      # E
    argparser_colorize "${space}" "      " 1 true   # E, _
    argparser_colorize "${font_9}" "  " 1 true      # R
    argparser_colorize "${space}" "  " 1 true       # R
    argparser_colorize "${font_9}" "  " 1 true      # R
    argparser_colorize "${space}" "  " 1 true       # _
    printf '\n'

    # Output the fourth line, containing the third of five lines of the
    # letters.
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_1}" "      " 1 true  # A
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_2}" "      " 1 true  # R
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_3}" "     " 1 true   # G
    argparser_colorize "${space}" "   " 1 true      # G, _
    argparser_colorize "${font_4}" "     " 1 true   # P
    argparser_colorize "${space}" "   " 1 true      # P, _
    argparser_colorize "${font_5}" "      " 1 true  # A
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_6}" "      " 1 true  # R
    argparser_colorize "${space}" "   " 1 true      # _, S
    argparser_colorize "${font_7}" "    " 1 true    # S
    argparser_colorize "${space}" "   " 1 true      # S, _
    argparser_colorize "${font_8}" "      " 1 true  # E
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_9}" "      " 1 true  # R
    argparser_colorize "${space}" "  " 1 true       # _
    printf '\n'

    # Output the fifth line, containing the fourth of five lines of the
    # letters.
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_1}" "  " 1 true      # A
    argparser_colorize "${space}" "  " 1 true       # A
    argparser_colorize "${font_1}" "  " 1 true      # A
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_2}" "  " 1 true      # R
    argparser_colorize "${space}" " " 1 true        # R
    argparser_colorize "${font_2}" "  " 1 true      # R
    argparser_colorize "${space}" "   " 1 true      # R, _
    argparser_colorize "${font_3}" "  " 1 true      # G
    argparser_colorize "${space}" "  " 1 true       # G
    argparser_colorize "${font_3}" "  " 1 true      # G
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_4}" "  " 1 true      # P
    argparser_colorize "${space}" "      " 1 true   # P, _
    argparser_colorize "${font_5}" "  " 1 true      # A
    argparser_colorize "${space}" "  " 1 true       # A
    argparser_colorize "${font_5}" "  " 1 true      # A
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_6}" "  " 1 true      # R
    argparser_colorize "${space}" " " 1 true        # R
    argparser_colorize "${font_6}" "  " 1 true      # R
    argparser_colorize "${space}" "       " 1 true  # R, _, S
    argparser_colorize "${font_7}" "  " 1 true      # S
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_8}" "  " 1 true      # E
    argparser_colorize "${space}" "      " 1 true   # E, _
    argparser_colorize "${font_9}" "  " 1 true      # R
    argparser_colorize "${space}" " " 1 true        # R
    argparser_colorize "${font_9}" "  " 1 true      # R
    argparser_colorize "${space}" "   " 1 true      # R, _
    printf '\n'

    # Output the sixth line, containing the fifth of five lines of the
    # letters.
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_1}" "  " 1 true      # A
    argparser_colorize "${space}" "  " 1 true       # A
    argparser_colorize "${font_1}" "  " 1 true      # A
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_2}" "  " 1 true      # R
    argparser_colorize "${space}" "  " 1 true       # R
    argparser_colorize "${font_2}" "  " 1 true      # R
    argparser_colorize "${space}" "   " 1 true      # _, G
    argparser_colorize "${font_3}" "    " 1 true    # G
    argparser_colorize "${space}" "   " 1 true      # G, _
    argparser_colorize "${font_4}" "  " 1 true      # P
    argparser_colorize "${space}" "      " 1 true   # P, _
    argparser_colorize "${font_5}" "  " 1 true      # A
    argparser_colorize "${space}" "  " 1 true       # A
    argparser_colorize "${font_5}" "  " 1 true      # A
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_6}" "  " 1 true      # R
    argparser_colorize "${space}" "  " 1 true       # R
    argparser_colorize "${font_6}" "  " 1 true      # R
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_7}" "     " 1 true   # S
    argparser_colorize "${space}" "   " 1 true      # S, _
    argparser_colorize "${font_8}" "      " 1 true  # E
    argparser_colorize "${space}" "  " 1 true       # _
    argparser_colorize "${font_9}" "  " 1 true      # R
    argparser_colorize "${space}" "  " 1 true       # R
    argparser_colorize "${font_9}" "  " 1 true      # R
    argparser_colorize "${space}" "  " 1 true       # _
    printf '\n'

    # Output the seventh line, which is empty again.
    argparser_colorize "${space}" "                              " 1 true  # _
    argparser_colorize "${space}" "                              " 1 true  # _
    argparser_colorize "${space}" "              " 1 true                  # _
    printf '\n'
}

# Define the main argparser function.
function argparser_main() {
    # Run the argparser, depending on the values of its environment
    # variables, to read, parse, and set the script's arguments.

    # Define the local variable.
    local translation

    # If the argparser hasn't sourced itself (i.e., the current
    # recursion level is the outer one from the calling script), set the
    # internal "environment" variables.
    if [[ "${BASH_SOURCE[2]}" != "${BASH_SOURCE[1]}" ]]; then
        argparser_set_internal_vars
    fi

    # If ${ARGPARSER_CONFIGURATION_FILE} is defined and not set to the
    # empty string, read the configuration file.
    if [[ -v ARGPARSER_CONFIGURATION_FILE \
        && -n "${ARGPARSER_CONFIGURATION_FILE}" ]]
    then
        argparser_read_configuration
    fi

    # If the argparser hasn't sourced itself (i.e., the current
    # recursion level is the outer one from the calling script), set the
    # environment variables that aren't already set by the calling
    # script or environment or read from the configuration file to
    # prevent overriding them.  Then, set the script's command-line
    # arguments (with the argparser arguments being removed) as the
    # current command line.
    if [[ "${BASH_SOURCE[2]}" != "${BASH_SOURCE[1]}" ]]; then
        argparser_set_env_vars "$@"
        set -- "${ARGPARSER_SCRIPT_ARGS[@]}"
    fi

    # If ${ARGPARSER_TRANSLATION_FILE} isn't set to the empty string,
    # read the translation file.  To be able to use the localized name
    # of ${ARGPARSER_POSITIONAL_ARG_GROUP} in the arguments definition
    # and help message, translate it.
    if [[ -n "${ARGPARSER_TRANSLATION_FILE}" ]]; then
        argparser_read_translation

        argparser_translate "Positional arguments" \
            "${ARGPARSER_POSITIONAL_ARG_GROUP}"
        ARGPARSER_POSITIONAL_ARG_GROUP="${translation}"
    fi

    # If ${ARGPARSER_CHECK_ENV_VARS} isn't set to false, check if the
    # environment variables accord to their definition.  Since
    # ${ARGPARSER_CHECK_ENV_VARS} is, as any other environment variable,
    # yet unchecked, its value may be different from the expected "true"
    # or "false".  Hence, testing for "not false" is not the exact
    # opposite of testing for "true".  Even more, if
    # ${ARGPARSER_CHECK_ENV_VARS} is different from "true" and "false",
    # the test would be mandatory as it shows the environment variables
    # have been wrongly set.
    if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
        argparser_check_env_vars
    fi

    # If ${ARGPARSER_READ_ARGS} is set to true, read and parse the
    # arguments.
    if [[ "${ARGPARSER_READ_ARGS}" == true ]]; then
        argparser_parse_args "$@"
    fi

    # If ${ARGPARSER_UNSET_ARGS} is set to true, disable all arguments
    # given to the calling script, effectively unsetting the command
    # line.
    if [[ "${ARGPARSER_UNSET_ARGS}" == true ]]; then
        set --
    fi

    # If ${ARGPARSER_SET_ARGS} is set to true, set the arguments as
    # variables to the current environment.
    if [[ "${ARGPARSER_SET_ARGS}" == true ]]; then
        argparser_set_args
    fi

    # If ${ARGPARSER_UNSET_FUNCTIONS} is set to true, unset all
    # argparser functions.  The names are used instead of a glob to
    # limit side effects with potentially same-named functions (i.e.,
    # those starting with "argparser_") from the calling script that
    # stand in no relation to the argparser.
    if [[ "${ARGPARSER_UNSET_FUNCTIONS}" == true ]]; then
        unset -f argparser_check_arg_values
        unset -f argparser_check_args_definition_names
        unset -f argparser_check_args_definition_option_values
        unset -f argparser_check_args_definition_positional_values
        unset -f argparser_check_bash_version
        unset -f argparser_check_color_or_style
        unset -f argparser_check_env_vars
        unset -f argparser_check_file
        unset -f argparser_check_shell
        unset -f argparser_colorize
        unset -f argparser_count
        unset -f argparser_create_help_message
        unset -f argparser_create_usage_message
        unset -f argparser_fold
        unset -f argparser_get_arg_key
        unset -f argparser_get_option_names
        unset -f argparser_in_array
        unset -f argparser_is_variable_bool
        unset -f argparser_is_variable_char
        unset -f argparser_is_variable_identifier
        unset -f argparser_is_variable_int
        unset -f argparser_is_variable_uint
        unset -f argparser_main
        unset -f argparser_parse_arg
        unset -f argparser_parse_args
        unset -f argparser_parse_args_definition
        unset -f argparser_parse_long_option
        unset -f argparser_parse_positional_args
        unset -f argparser_parse_short_option
        unset -f argparser_print_error_or_warning_message
        unset -f argparser_print_help_or_usage_message
        unset -f argparser_print_logo
        unset -f argparser_print_version_message
        unset -f argparser_quicksort
        unset -f argparser_read_args_definition
        unset -f argparser_read_configuration
        unset -f argparser_read_translation
        unset -f argparser_set_args
        unset -f argparser_set_env_vars
        unset -f argparser_set_internal_vars
        unset -f argparser_sort
        unset -f argparser_translate
        unset -f argparser_trim
        unset -f argparser_uniq
    fi

    # If ${ARGPARSER_UNSET_ENV_VARS} is set to true, unset all argparser
    # environment variables.  Again, the names are used instead of a
    # glob to limit side effects with potentially same-named variables
    # (i.e., those starting with "ARGPARSER_") from the calling script
    # that stand in no relation to the argparser.
    if [[ "${ARGPARSER_UNSET_ENV_VARS}" == true ]]; then
        unset ARGPARSER_ADD_HELP
        unset ARGPARSER_ADD_USAGE
        unset ARGPARSER_ADD_VERSION
        unset ARGPARSER_ALLOW_OPTION_ABBREVIATION
        unset ARGPARSER_ALLOW_OPTION_MERGING
        unset ARGPARSER_ARG_ARRAY_NAME
        unset ARGPARSER_ARG_DEF_FILE
        unset ARGPARSER_ARG_DEF_FILE_HAS_HEADER
        unset ARGPARSER_ARG_DEF_HAS_HEADER
        unset ARGPARSER_ARG_DELIMITER_1
        unset ARGPARSER_ARG_DELIMITER_2
        unset ARGPARSER_ARGS
        unset ARGPARSER_CHECK_ARG_DEFINITION
        unset ARGPARSER_CHECK_ENV_VARS
        unset ARGPARSER_CONFIGURATION_FILE
        unset ARGPARSER_COUNT_FLAGS
        unset ARGPARSER_DICTIONARY
        unset ARGPARSER_ERROR_EXIT_CODE
        unset ARGPARSER_ERROR_STYLE
        unset ARGPARSER_HELP_EXIT_CODE
        unset ARGPARSER_HELP_FILE
        unset ARGPARSER_HELP_FILE_INCLUDE_CHAR
        unset ARGPARSER_HELP_FILE_KEEP_COMMENTS
        unset ARGPARSER_HELP_STYLE
        unset ARGPARSER_LANGUAGE
        unset ARGPARSER_MAX_COL_WIDTH_1
        unset ARGPARSER_MAX_COL_WIDTH_2
        unset ARGPARSER_MAX_COL_WIDTH_3
        unset ARGPARSER_POSITIONAL_ARG_GROUP
        unset ARGPARSER_READ_ARGS
        unset ARGPARSER_SCRIPT_ARGS
        unset ARGPARSER_SCRIPT_NAME
        unset ARGPARSER_SCRIPT_VERSION
        unset ARGPARSER_SCRIPT_VERSION_EXIT_CODE
        unset ARGPARSER_SCRIPT_VERSION_STYLE
        unset ARGPARSER_SET_ARGS
        unset ARGPARSER_SET_ARRAYS
        unset ARGPARSER_SILENCE_ERRORS
        unset ARGPARSER_SILENCE_WARNINGS
        unset ARGPARSER_TRANSLATION_FILE
        unset ARGPARSER_UNSET_ARGS
        unset ARGPARSER_UNSET_ENV_VARS
        unset ARGPARSER_UNSET_FUNCTIONS
        unset ARGPARSER_USAGE_EXIT_CODE
        unset ARGPARSER_USAGE_FILE
        unset ARGPARSER_USAGE_FILE_INCLUDE_CHAR
        unset ARGPARSER_USAGE_FILE_KEEP_COMMENTS
        unset ARGPARSER_USAGE_MESSAGE_OPTION_TYPE
        unset ARGPARSER_USAGE_MESSAGE_ORIENTATION
        unset ARGPARSER_USAGE_STYLE
        unset ARGPARSER_USE_LONG_OPTIONS
        unset ARGPARSER_USE_SHORT_OPTIONS
        unset ARGPARSER_USE_STYLES_IN_FILES
        unset ARGPARSER_VERSION
        unset ARGPARSER_WARNING_STYLE
    fi
}

# Check the version of the current Bash instance.
argparser_check_bash_version

# Run the argparser.
argparser_main "$@"
