#!/usr/bin/env bash

###############################################################################
#                                                                             #
# Copyright 2025 Simon Brandt                                                 #
#                                                                             #
# Licensed under the Apache License, Version 2.0 (the "License");             #
# you may not use this file except in compliance with the License.            #
# You may obtain a copy of the License at                                     #
#                                                                             #
#     http://www.apache.org/licenses/LICENSE-2.0                              #
#                                                                             #
# Unless required by applicable law or agreed to in writing, software         #
# distributed under the License is distributed on an "AS IS" BASIS,           #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    #
# See the License for the specific language governing permissions and         #
# limitations under the License.                                              #
#                                                                             #
###############################################################################

# Author: Simon Brandt
# E-Mail: simon.brandt@uni-greifswald.de
# Last Modification: 2025-10-28

# Usage: Source this script with 'source argparser -- "$@"' inside the
# script whose arguments need to be parsed.  If ${ARGPARSER_READ_ARGS}
# is set to "true" (the default), the arguments will be parsed upon
# sourcing.  If ${ARGPARSER_SET_ARGS} is set to "true" (the default),
# the arguments will also be set to variables upon sourcing, else, the
# associative array which ${ARGPARSER_ARG_ARRAY_NAME} points to needs to
# be accessed.  Refer to the documentation for details.

# Purpose: Parse a script's arguments, giving proper error and warning
# messages for wrongly set arguments, assigning the values to the
# respective variables, as well as creating and printing a help, usage,
# and version message.  Refer to the documentation for details.

###############################################################################

# Define the Argparser functions to check that the Argparser is run by
# Bash 4.4 or higher, and execute them immediately, such that the rest
# of the script doesn't get parsed (which would create errors since it's
# written in Bash, not POSIX compliantly, and using Bash syntax not
# available prior Bash 4.4).
argparser_check_shell() {
    # Check that the current shell is a Bash instance.  Else, print an
    # error message.
    #
    # In order to have the function interpretable by shells other than
    # Bash, all commands are written in a POSIX-conformant form.

    # shellcheck disable=SC2292  # Intentional POSIX conformance.
    if [ -z "${BASH}" ]; then
        if [ -t 2 ]; then
            printf '\e[31;1;7m%s: %s\e[m\n' "$0" \
                "Error: The Argparser requires Bash as executing shell."
        else
            printf '%s: %s\n' "$0" \
                "Error: The Argparser requires Bash as executing shell."
        fi >&2
        exit 1
    fi
}
argparser_check_shell

function argparser_check_bash_version() {
    # Check that version of the current Bash instance is at least 4.4.
    # Else, print an error message.

    if (( BASH_VERSINFO[0] < 4 \
        || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 4) ))
    then
        if [[ -t 2 ]]; then
            printf '\e[31;1;7m%s: %s\e[m\n' "$0" \
                "Error: The Argparser requires Bash 4.4 or higher."
        else
            printf '%s: %s\n' "$0" \
                "Error: The Argparser requires Bash 4.4 or higher."
        fi >&2
        exit 1
    fi
}
argparser_check_bash_version

# Define the Argparser function used for debugging.
function argparser_toggle_debugger() {
    # Start or stop the Argparser debugger.
    #
    # Arguments:
    # - $1: whether to start or stop the debugger ("start" or "stop")

    # Define the local variables.
    local status
    local trap_action

    status="$1"

    # shellcheck disable=SC2016  # Intentional single quotes around variables.
    # shellcheck disable=SC2064  # Intentional double-quoted trap action.
    if [[ "${status}" == "start" ]]; then
        # Print the current 4-digit line number, the currently executing
        # function's name, and the command to be executed, for any
        # command.
        trap_action='printf "Line %4d in %s:    %s\n" "${LINENO}" '
        trap_action+='"${FUNCNAME[0]:-main}" "${BASH_COMMAND}" >&2'
        trap "${trap_action}" DEBUG
        set -o functrace
    else
        # Reset the trap action.
        trap - DEBUG
    fi
}

# Define the Argparser functions used for general tests.
function argparser_in_array() {
    # Check if an element occurs in an array.
    #
    # Arguments:
    # - $1: the element to search for
    # - $@: the array to search through
    #
    # Return value:
    # - 0, if the element exists in the array
    # - 1, else

    # Define the local variables.
    local element
    local query

    # Read the query element and shift the arguments such that only the
    # array to search through remains.
    query="$1"
    shift

    # Iterate through the array and compare each element to the query.
    # Return 0 on success, else 1.
    for element in "$@"; do
        if [[ "${element}" == "${query}" ]]; then
            return 0
        fi
    done

    return 1
}

function argparser_is_alpha() {
    # Check if a variable's value is an alphabetical character.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Return value:
    # - 0, if the variable's value is an alphabetical character
    # - 1, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == [[:alpha:]] ]]; then
        return 0
    else
        return 1
    fi
}

function argparser_is_bool() {
    # Check if a variable's value is a Boolean.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Return value:
    # - 0, if the variable's value is a Boolean
    # - 1, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == true || "${var}" == false ]]; then
        return 0
    else
        return 1
    fi
}

function argparser_is_char() {
    # Check if a variable's value is a (printable) character.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Return value:
    # - 0, if the variable's value is a character
    # - 1, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == [[:print:]] ]]; then
        return 0
    else
        return 1
    fi
}

function argparser_is_float() {
    # Check if a variable's value is a floating-point number.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Return value:
    # - 0, if the variable's value is a floating-point number
    # - 1, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == ?([+-])+([[:digit:]]).*([[:digit:]])
        || "${var}" == ?([+-])*([[:digit:]]).+([[:digit:]]) ]]
    then
        return 0
    else
        return 1
    fi
}

function argparser_is_identifier() {
    # Check if a variable's value is usable as Bash variable identifier.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Return value:
    # - 0, if the variable's value is usable as identifier
    # - 1, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == [[:alpha:]_]*([[:word:]]) ]]; then
        return 0
    else
        return 1
    fi
}

function argparser_is_int() {
    # Check if a variable's value is an integer.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Return value:
    # - 0, if the variable's value is an integer
    # - 1, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == ?([+-])+([[:digit:]]) ]]; then
        return 0
    else
        return 1
    fi
}

function argparser_is_uint() {
    # Check if a variable's value is an unsigned integer.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Return value:
    # - 0, if the variable's value is an unsigned integer
    # - 1, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == +([[:digit:]]) ]]; then
        return 0
    else
        return 1
    fi
}

function argparser_check_color_or_style() {
    # Check if the specified colors and/or styles are implemented for
    # argparser_colorize.
    #
    # Arguments:
    # - $1: the colors and/or styles to use as
    #       ${ARGPARSER_ARG_DELIMITER_2}-separated list
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    #
    # Return value:
    # - 0, if all colors and/or styles are implemented
    # - 1, else

    # Define the local variables.
    local request
    local requests
    local -a styles

    # Read the argument.
    requests="$1"

    # Define the array of implemented colors and styles.
    # shellcheck disable=SC2190  # Indexed, not associative array.
    styles=(
        black
        red
        green
        yellow
        blue
        magenta
        cyan
        white
        normal
        bold
        faint
        italic
        underline
        double
        overline
        crossed-out
        blink
        reverse
    )

    # Split the requested color and/or style on
    # ${ARGPARSER_ARG_DELIMITER_2} characters and check any.
    IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a requests <<< "${requests}"
    if (( "${#requests[@]}" == 0 )); then
        return 1
    fi

    for request in "${requests[@]}"; do
        if ! argparser_in_array "${request}" "${styles[@]}"; then
            return 1
        fi
    done

    return 0
}

function argparser_check_file() {
    # Check if a file exists, is a regular file, is readable, and has a
    # size greater than 0 bytes.
    #
    # Arguments:
    # - $1: the file to check
    #
    # Nonlocals:
    # - file_attributes: a bit mask with four bits set to 0 ("true") if
    #   the file exists (first bit), is a regular file (second bit), is
    #   readable (third bit), and/or has a size greater than 0 bytes
    #   (fourth bit), else set to 1 ("false")

    # Define the local variable.
    local file

    # Read the argument.
    file="$1"

    # Check the variable's value.
    if [[ -e "${file}" ]]; then
        file_attributes="0"
    else
        file_attributes="1"
    fi

    if [[ -f "${file}" ]]; then
        file_attributes+="0"
    else
        file_attributes+="1"
    fi

    if [[ -r "${file}" ]]; then
        file_attributes+="0"
    else
        file_attributes+="1"
    fi

    if [[ -s "${file}" ]]; then
        file_attributes+="0"
    else
        file_attributes+="1"
    fi
}

# Define the general Argparser utility functions.
function argparser_pad() {
    # Right-pad all elements of an array to have the same length.
    #
    # Arguments:
    # - $@: the array whose elements to pad
    #
    # Nonlocals:
    # - padded_array: the array with padded elements.

    # Set the local variables.
    local arg_key
    local i
    local whitespace
    local width

    padded_array=("$@")

    # Pad the array's elements in-place.
    width=0
    for arg_key in "${padded_array[@]}"; do
        if (( "${#arg_key}" > width )); then
            width="${#arg_key}"
        fi
    done

    for i in "${!padded_array[@]}"; do
        printf -v whitespace '%*s' $(( width - "${#padded_array[i]}" )) ""
        padded_array[i]="${padded_array[i]}${whitespace}"
    done
}

function argparser_trim() {
    # Trim leading and trailing space characters from a string.
    #
    # Arguments:
    # - $1: the string to trim
    #
    # Nonlocals:
    # - trimmed_string: the trimmed string

    # Define the local variable.
    local string

    # Read the argument.
    string="$1"

    # Trim the string and set the nonlocal ${trimmed_string} to it.
    string="${string##+( )}"
    string="${string%%+( )}"
    trimmed_string="${string}"
}

function argparser_fold() {
    # Limit the width of a help message's column to the maximum column
    # width by inserting line breaks.
    #
    # Arguments:
    # - $1: the line in the column in which to insert line breaks
    # - $2: the maximum width a column may have
    # - $3: the maximum width a column has yet
    #
    # Nonlocals:
    # - joined_words: the line with introduced line breaks
    # - largest_col_width: the width of the widest line part

    # Define the local variables.
    local col_width
    local i
    local len_word
    local line
    local max_col_width
    local word
    local words

    # Read the arguments.
    line="$1"
    max_col_width="$2"
    largest_col_width="$3"

    # Split the column element word by word (on whitespace), such that
    # line breaks aren't inserted into entire words.
    joined_words=""
    col_width=0
    IFS=" " read -r -a words <<< "${line}"

    for i in "${!words[@]}"; do
        word="${words[i]}"
        len_word="${#word}"

        if (( col_width == 0 )); then
            # For the first word in the line, add the word only and set
            # the column width.  Since the word *must* be given on some
            # line, don't test whether it is too long for the line,
            # i.e., if it exceeds ${max_col_width}
            joined_words+="${word}"
            col_width="${len_word}"
        elif (( col_width + len_word + 1 > max_col_width )); then
            # As the line with the appended word (and the preceding
            # space) would be too long, introduce a line break, print
            # the word, and set the column width.
            joined_words+=$'\n'
            joined_words+="${word}"
            col_width="${len_word}"
        else
            # For any other word, add the word and a leading space
            # (otherwise, the words would be concatenated without
            # separation since the splitting removed any whitespace).
            # Increase the column width appropriately.
            joined_words+=" ${word}"
            (( col_width += len_word + 1 ))
        fi

        # If the current line is wider than the previous ones and less
        # wide than the maximum column width, set ${largest_col_width}
        # correspondingly.  Later, this value is used to determine the
        # amount of whitespace between the columns' elements.
        if (( col_width > largest_col_width && col_width <= max_col_width ))
        then
            largest_col_width="${col_width}"
        fi
    done
}

function argparser_join() {
    # Join an array by ${ARGPARSER_ARG_DELIMITER_2} characters.
    #
    # Arguments:
    # - $1: whether to colorize the option names by argparser_colorize
    # - $2: the colors and/or styles to use as
    #       ${ARGPARSER_ARG_DELIMITER_2}-separated list
    # - $3: the file descriptor to write to (1 or 2)
    # - $@: the array to join
    #
    # Nonlocals:
    # - joined_array: the joined array
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)

    # Define the local variables.
    local array
    local colorize
    local file_descriptor
    local IFS
    local string
    local style_requests

    # Read the arguments.
    colorize="$1"
    style_requests="$2"
    file_descriptor="$3"
    shift 3
    array=("$@")

    # Possibly, colorize the array.
    if [[ "${colorize}" == true ]]; then
        for i in "${!array[@]}"; do
            argparser_colorize "${style_requests}" "${array[i]}" \
                "${file_descriptor}" string
            array[i]="${string}"
        done
    fi

    # Join the array.
    IFS="${ARGPARSER_ARG_DELIMITER_2}"
    joined_array="${array[*]}"
}

function argparser_seq() {
    # Create a sequence of integer or string values, ranging from the
    # start to the stop (inclusive), with a given step size.
    #
    # Arguments:
    # - $1: the argument identifier
    # - $2: the start value (as integer or string)
    # - $3: the stop value (as integer or string)
    # - $4: the step size (as integer, default: 1)
    #
    # Nonlocals:
    # - error_messages: the error messages, starting with "Error: "
    #   (translated), as indexed array
    # - sequence: the created sequence

    # Define the local variables.
    local arg_key
    local char
    local decimals
    local decimals_start
    local decimals_step
    local decimals_stop
    local i
    local number
    local offset
    local start
    local stop
    local step

    # Read the arguments.
    arg_key="$1"
    start="$2"
    stop="$3"
    step="${4:-1}"

    if argparser_is_alpha "${start}" \
        && argparser_is_alpha "${stop}" \
        && argparser_is_int "${step}"
    then
        # For alphabetical character sequences, get the decimal value in
        # the ASCII table for the start and stop.
        printf -v start '%d' "'${start}"
        printf -v stop '%d' "'${stop}"
    elif argparser_is_int "${start}" \
        && argparser_is_int "${stop}" \
        && argparser_is_int "${step}"
    then
        # For entirely integer sequences, do nothing.  This is required
        # to simplify the subsequent comparisons.
        :
    elif (argparser_is_float "${start}" || argparser_is_int "${start}") \
        && (argparser_is_float "${stop}" || argparser_is_int "${stop}") \
        && (argparser_is_float "${step}" || argparser_is_int "${step}")
    then
        # For at least partially float sequences, get the decimal part
        # (after the period) and count its length.
        if [[ "${start}" == *.* ]]; then
            decimals_start="${start#*.}"
            decimals_start="${#decimals_start}"
        else
            decimals_start=0
        fi

        if [[ "${stop}" == *.* ]]; then
            decimals_stop="${stop#*.}"
            decimals_stop="${#decimals_stop}"
        else
            decimals_stop=0
        fi

        if [[ "${step}" == *.* ]]; then
            decimals_step="${step#*.}"
            decimals_step="${#decimals_step}"
        else
            decimals_step=0
        fi

        # Remove the period from the start, stop, and step values, as
        # well as any leading 0, to prevent the numbers being
        # interpreted as octal, instead of decimal.  These leading zeros
        # may result from the removal of the period, like "0.01" being
        # transformed to "001", instead of "1".
        start="${start/.}"
        start="${start##+(0)}"
        stop="${stop/.}"
        stop="${stop##+(0)}"
        step="${step/.}"
        step="${step##+(0)}"

        # Add as many trailing zeros to the start, stop, and step values
        # as required to make them the same length, in terms of decimal
        # digits.  By this, the sequence can be created as integer
        # sequence, below, and afterwards, by re-introducing the periods
        # as appropriate, the numbers can be converted back to floats.
        if (( decimals_start < decimals_step \
            && decimals_stop < decimals_step ))
        then
            (( decimals = decimals_step ))
            while (( decimals_start < decimals_step )); do
                start+="0"
                (( decimals_start++ ))
            done
            while (( decimals_stop < decimals_step )); do
                stop+="0"
                (( decimals_stop++ ))
            done
        elif (( decimals_start < decimals_stop )); then
            (( decimals = decimals_stop ))
            while (( decimals_start < decimals_stop )); do
                start+="0"
                (( decimals_start++ ))
            done
            while (( decimals_step < decimals_stop )); do
                step+="0"
                (( decimals_step++ ))
            done
        else
            (( decimals = decimals_start ))
            while (( decimals_stop < decimals_start )); do
                stop+="0"
                (( decimals_stop++ ))
            done
            while (( decimals_step < decimals_start )); do
                step+="0"
                (( decimals_step++ ))
            done
        fi
    else
        # For any other data type, output an error message.
        error_message="Error: The argument with the identifier \"\$1\" has "
        error_message+="choice values given with \"\$2\" as start, \"\$3\" as "
        error_message+="stop, and \"\$4\" as step size, while only integer, "
        error_message+="float, or letter sequences are supported."

        argparser_translate "Error arg def choice range" \
            "${error_message}" "${arg_key}" "${start}" "${stop}" "${step}"
        error_message="${translation}"
        error_messages+=("${error_message}")
        return
    fi

    # Create the actual sequence by iterating from the start to the stop
    # value, incrementing or decrementing by the given step size as
    # appropriate for the numerical order.
    sequence=( )
    if (( start <= stop )); then
        for (( i = start; i <= stop; i += step )); do
            sequence+=("${i}")
        done
    else
        for (( i = start; i >= stop; i -= step )); do
            sequence+=("${i}")
        done
    fi

    if argparser_is_alpha "$2"; then
        # If the start value (and, by this, also the stop and step
        # values) had been given as alphabetical character, convert each
        # number within the sequence to its hexadecimal representation
        # and subsequently to the respective character in the ASCII
        # table.
        for i in "${!sequence[@]}"; do
            char="${sequence[i]}"
            printf -v char '%x' "${char}"

            # shellcheck disable=SC2059  # Escape sequence in variable.
            printf -v char "\x${char}"
            sequence[i]="${char}"
        done
    elif argparser_is_float "$2" \
        || argparser_is_float "$3" \
        || argparser_is_float "$4"
    then
        # If either of the start, stop, and step value had been given as
        # float, convert the integers in the sequence to floats by
        # introducing a period at the decimal offset the most precise
        # number had (like two digits for start=1.0, stop=1.5, and
        # step=0.05).
        for i in "${!sequence[@]}"; do
            number="${sequence[i]}"
            (( offset = "${#number}" - decimals ))
            sequence[i]="${number::offset}.${number:offset}"
        done
    fi
}

function argparser_count() {
    # Count the number of occurences of an element in an array.
    #
    # Arguments:
    # - $1: the element to count
    # - $@: the array where to count the element
    #
    # Nonlocals:
    # - count: the count of the element

    # Define the local variables.
    local element
    local query

    # Read the query element and shift the arguments such that only the
    # array to search through remains.
    query="$1"
    shift

    # Count the number of occurences.
    count=0
    for element in "$@"; do
        if [[ "${element}" == "${query}" ]]; then
            (( count++ ))
        fi
    done
}

function argparser_uniq() {
    # Filter adjacent duplicate entries from an array.
    #
    # Arguments:
    # - $@: the array to filter
    #
    # Nonlocals:
    # - filtered_array: the filtered array

    # Define the local variables.
    local array
    local element
    local prev_element

    # Read the arguments.
    array=("$@")

    # Filter the array and output it.
    prev_element="${array[0]}"
    filtered_array=("${array[0]}")
    for element in "${array[@]:1}"; do
        if [[ "${element}" != "${prev_element}" ]]; then
            filtered_array+=("${element}")
        fi
        prev_element="${element}"
    done
}

function argparser_quicksort() {
    # Sort an array using the recursive Quicksort algorithm with Tony
    # Hoare's partition scheme.
    #
    # Arguments:
    # - $1: the left boundary of the array bucket
    # - $2: the right boundary of the array bucket
    #
    # Nonlocals:
    # - array: the array to sort

    # Define the local variables.
    local i
    local j
    local left
    local pivot
    local pivot_point
    local right
    local swap

    # Read the arguments.
    left="$1"
    right="$2"

    # Sort the array by Quicksort.
    if (( left < right )); then
        # Set the start indices for the current bucket.  Take the
        # leftmost element as pivot.
        (( i = "${left}" - 1 ))
        (( j = "${right}" + 1 ))
        pivot="${array[left]}"

        while :; do
            # Traverse the array from the left, until a larger element
            # than the pivot has been found.
            (( i++ ))
            while [[ "${array[i]}" < "${pivot}" ]]; do
                (( i++ ))
            done

            # Traverse the array from the right, until a smaller element
            # than the pivot has been found.
            (( j-- ))
            while [[ "${array[j]}" > "${pivot}" ]]; do
                (( j-- ))
            done

            # If the indices have crossed each other, return.
            if (( i >= j )); then
                pivot_point="${j}"
                break
            fi

            # Swap the elements at the current indices.
            swap="${array[i]}"
            array[i]="${array[j]}"
            array[j]="${swap}"
        done

        # Recursively call the Quicksort algorithm to sort the buckets
        # individually.
        argparser_quicksort "${left}" "${pivot_point}"
        argparser_quicksort "$(( pivot_point + 1 ))" "${right}"
    fi
}

function argparser_sort() {
    # Sort an array, internally using the Quicksort algorithm.
    #
    # Arguments:
    # - $1: whether to reverse-sort the array
    # - $@: the array to sort
    #
    # Nonlocals:
    # - sorted_array: the sorted array

    # Define the local variables.
    local array
    local i
    local reverse

    # Read the arguments.
    reverse="$1"
    shift
    array=("$@")

    # Sort the array and output it, possibly after reversing it.
    argparser_quicksort 0 "$(( "${#array[@]}" - 1 ))"
    if [[ "${reverse}" == true ]]; then
        sorted_array=( )
        for (( i = "${#array[@]}" - 1; i >= 0; i-- )); do
            sorted_array+=("${array[i]}")
        done
    else
        sorted_array=("${array[@]}")
    fi
}

function argparser_colorize() {
    # Colorize and format the string using ANSI escape sequences.
    #
    # Arguments:
    # - $1: the colors and/or styles to use as
    #       ${ARGPARSER_ARG_DELIMITER_2}-separated list
    # - $2: the string to colorize
    # - $3: the file descriptor to write to (1 or 2)
    # - $4: the variable to set the colorized string to; if not given,
    #       the string is printed
    #
    # Nonlocals:
    # - $4: the stylized string (if $4 is given)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_USE_STYLES_IN_FILES (read-only)
    #
    # Output:
    # - the colorized string (if $4 is not given)

    # Define the local variables.
    local colorized_string
    local file_descriptor
    local style
    local style_request
    local style_requests
    local -A styles
    local var

    # Read the arguments.
    style_requests="$1"
    colorized_string="$2"
    file_descriptor="$3"

    if (( "$#" == 4 )); then
        var="$4"
    fi

    # Define the associative array with colors and styles, and their
    # corresponding Select Graphic Rendition (SGR) ANSI escape sequence
    # codes.
    styles=(
        [black]=30
        [red]=31
        [green]=32
        [yellow]=33
        [blue]=34
        [magenta]=35
        [cyan]=36
        [white]=37
        [normal]=22
        [bold]=1
        [faint]=2
        [italic]=3
        [underline]=4
        [double]=21
        [overline]=53
        [crossed-out]=9
        [blink]=5
        [reverse]=7
    )

    # Split the requested color and/or style on
    # ${ARGPARSER_ARG_DELIMITER_2} characters and replace it with the
    # corresponding escape sequence, if writing to a terminal or the
    # escape sequences shall be included in the file.  The test assumes
    # that Argparser_colorize is never run through command substitution,
    # else [[ -t ${file_descriptor} ]] would always be false, i.e., it
    # would impossible to tell if the final STDOUT/STDERR goes to a
    # terminal.
    if [[ "${ARGPARSER_USE_STYLES_IN_FILES}" == true \
        || -t "${file_descriptor}" ]]
    then
        style=""
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a style_requests \
            <<< "${style_requests}"
        for style_request in "${style_requests[@]}"; do
            style+=$'\e['"${styles[${style_request}]}"'m'
        done

        if [[ -n "${colorized_string}" ]]; then
            colorized_string="${style}${colorized_string}"$'\e[m'
        fi
    fi

    # Print the colorized string and reset the color/style, or set it to
    # the target variable, using a name reference to the variable name
    # given as ${var} (i.e., as $4).
    if (( "$#" == 3 )); then
        printf '%s' "${colorized_string}"
    else
        declare -n var="${var}"
        var="${colorized_string}"
    fi
}

# Define the Argparser functions for reading the configuration and
# setting and checking the environment variables.
function argparser_read_configuration() {
    # Read the configuration from the configuration file into the
    # environment variables.
    #
    # Environment:
    # ARGPARSER_ADD_HELP
    # ARGPARSER_ADD_USAGE
    # ARGPARSER_ADD_VERSION
    # ARGPARSER_ALLOW_ARG_INTERMIXING
    # ARGPARSER_ALLOW_FLAG_INVERSION
    # ARGPARSER_ALLOW_FLAG_NEGATION
    # ARGPARSER_ALLOW_OPTION_ABBREVIATION
    # ARGPARSER_ALLOW_OPTION_MERGING
    # ARGPARSER_ARG_ARRAY_NAME
    # ARGPARSER_ARG_DEF_FILE
    # ARGPARSER_ARG_DELIMITER_1
    # ARGPARSER_ARG_DELIMITER_2
    # ARGPARSER_CHECK_ARG_DEF
    # ARGPARSER_CHECK_ENV_VARS
    # ARGPARSER_CONFIG_FILE (read-only)
    # ARGPARSER_COUNT_FLAGS
    # ARGPARSER_ERROR_EXIT_CODE
    # ARGPARSER_ERROR_STYLE
    # ARGPARSER_HELP_ARG_GROUP
    # ARGPARSER_HELP_DESCRIPTION
    # ARGPARSER_HELP_EXIT_CODE
    # ARGPARSER_HELP_FILE
    # ARGPARSER_HELP_FILE_INCLUDE_CHAR
    # ARGPARSER_HELP_FILE_KEEP_COMMENTS
    # ARGPARSER_HELP_STYLE
    # ARGPARSER_LANGUAGE
    # ARGPARSER_MAX_COL_WIDTH_1
    # ARGPARSER_MAX_COL_WIDTH_2
    # ARGPARSER_MAX_COL_WIDTH_3
    # ARGPARSER_MAX_WIDTH
    # ARGPARSER_POSITIONAL_ARG_GROUP
    # ARGPARSER_READ_ARGS
    # ARGPARSER_SCRIPT_NAME
    # ARGPARSER_SET_ARGS
    # ARGPARSER_SET_ARRAYS
    # ARGPARSER_SILENCE_ERRORS
    # ARGPARSER_SILENCE_WARNINGS
    # ARGPARSER_STYLE_FILE
    # ARGPARSER_TRANSLATION_FILE
    # ARGPARSER_UNSET_ARGS
    # ARGPARSER_UNSET_ENV_VARS
    # ARGPARSER_UNSET_FUNCTIONS
    # ARGPARSER_USAGE_EXIT_CODE
    # ARGPARSER_USAGE_FILE
    # ARGPARSER_USAGE_FILE_INCLUDE_CHAR
    # ARGPARSER_USAGE_FILE_KEEP_COMMENTS
    # ARGPARSER_USAGE_MESSAGE_OPTION_TYPE
    # ARGPARSER_USAGE_MESSAGE_ORIENTATION
    # ARGPARSER_USAGE_STYLE
    # ARGPARSER_USE_LONG_OPTIONS
    # ARGPARSER_USE_SHORT_OPTIONS
    # ARGPARSER_USE_STYLES_IN_FILES
    # ARGPARSER_VERSION_EXIT_CODE
    # ARGPARSER_VERSION_NUMBER
    # ARGPARSER_VERSION_STYLE
    # ARGPARSER_WARNING_STYLE

    # Define the local variables.
    local error_message
    local -a error_messages
    local file_attributes
    local line
    local -a lines
    local value
    local var

    # Check if the configuration file exists and is readable.  Else,
    # output an error message and exit.  Since at this point of
    # invokation, the environment variables aren't checked, yet, set the
    # needed ones to default values, if ${ARGPARSER_CHECK_ENV_VARS}
    # isn't set to "false" (and by this, the checking hasn't been
    # explicitly disabled).
    argparser_check_file "${ARGPARSER_CONFIG_FILE}"
    if [[ "${file_attributes}" != "0000" ]]; then
        error_message="Error: The environment variable \"\$1\" is set to "
        error_message+="\"\$2\", but the referenced file "
        case "${file_attributes}" in
            0001) error_message+="is empty." ;;
            0010) error_message+="is not readable." ;;
            0011) error_message+="is not readable and empty." ;;
            0100) error_message+="is not a regular file." ;;
            0101) error_message+="is not a regular file and empty." ;;
            0110) error_message+="is not a regular file and not readable." ;;
            0111)
                error_message+="is not a regular file, not readable, and "
                error_message+="empty."
                ;;
            1111) error_message+="does not exist." ;;
        esac

        error_message="${error_message/"\$1"/"ARGPARSER_CONFIG_FILE"}"
        error_message="${error_message/"\$2"/${ARGPARSER_CONFIG_FILE}}"

        if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
            ARGPARSER_ARG_DELIMITER_2=","
            ARGPARSER_ERROR_EXIT_CODE=1
            ARGPARSER_ERROR_STYLE="red,bold,reverse"
        fi

        argparser_print_error_message false true "${error_message}"
    fi

    # Read the configuration file.
    mapfile -t lines < "${ARGPARSER_CONFIG_FILE}"
    error_messages=( )

    for line in "${lines[@]}"; do
        if [[ -z "${line}" || "${line}" == \#* ]]; then
            # Ignore the empty or commented line.
            continue
        elif [[ "${line}" == *( )"args"*( )=* ]]; then
            # Output an error message when the line sets
            # ${ARGPARSER_ARGS}.
            error_message="Error: In the configuration file \"\$1\", the line "
            error_message+="\"\$2\" sets ARGPARSER_ARGS, which is an "
            error_message+="internal variable and must not be set."

            error_message="${error_message/"\$1"/"${ARGPARSER_CONFIG_FILE}"}"
            error_message="${error_message/"\$2"/"${line}"}"
            error_messages+=("${error_message}")
        elif [[ "${line}" =~ = ]]; then
            # Set the variable name as shortest part before an equals
            # sign ("="), strip leading and trailing spaces, replace
            # hyphens and spaces by underscores, capitalize the variable
            # name, and prepend the string "ARGPARSER_".  Then, extract
            # the value as longest part after the equals sign and strip
            # leading and trailing spaces and a double quote each.
            var="${line%%=*}"
            argparser_trim "${var}"
            var="${trimmed_string}"
            var="${var//-/_}"
            var="${var// /_}"
            var="ARGPARSER_${var^^}"

            value="${line#*=}"
            argparser_trim "${value}"
            value="${trimmed_string}"
            value="${value#\"}"
            value="${value%\"}"

            # Set the environment variable, as long as it isn't already
            # set by the calling script or environment to prevent
            # overriding it.  For ${ARGPARSER_SCRIPT_NAME}, set the
            # value to the basename of the script's $0 if an empty
            # string is given.
            if [[ ! -v "${var}" ]]; then
                if [[ "${var}" == "ARGPARSER_SCRIPT_NAME" && -z "${value}" ]]
                then
                    value="${0##*/}"
                fi
                declare -g "${var}"="${value}"
            fi
        else
            # Output an error message when the line doesn't contain an
            # equals sign ("=").
            error_message="Error: In the configuration file \"\$1\", the line "
            error_message+="\"\$2\" doesn't contain an equals sign (\"=\"), "
            error_message+="nor is it empty or commented."

            error_message="${error_message/"\$1"/"${ARGPARSER_CONFIG_FILE}"}"
            error_message="${error_message/"\$2"/"${line}"}"
            error_messages+=("${error_message}")
        fi
    done

    # Sort, filter, colorize, and print all error messages, then exit,
    # as the environment variables should be correctly read.
    if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
        ARGPARSER_ARG_DELIMITER_2=","
        ARGPARSER_ERROR_EXIT_CODE=1
        ARGPARSER_ERROR_STYLE="red,bold,reverse"
    fi

    argparser_print_error_message true true "${error_messages[@]}"
}

function argparser_set_env_vars() {
    # Set the Argparser environment variables, as long as they aren't
    # already set by the calling script or environment to prevent
    # overriding them.
    #
    # Arguments:
    # - $@: the command line upon sourcing the Argparser
    #
    # Nonlocals:
    # - script_args: the script's command line
    #
    # Environment:
    # ARGPARSER_ADD_HELP
    # ARGPARSER_ADD_USAGE
    # ARGPARSER_ADD_VERSION
    # ARGPARSER_ALLOW_ARG_INTERMIXING
    # ARGPARSER_ALLOW_FLAG_INVERSION
    # ARGPARSER_ALLOW_FLAG_NEGATION
    # ARGPARSER_ALLOW_OPTION_ABBREVIATION
    # ARGPARSER_ALLOW_OPTION_MERGING
    # ARGPARSER_ARG_ARRAY_NAME
    # ARGPARSER_ARG_DEF_FILE
    # ARGPARSER_ARG_DELIMITER_1
    # ARGPARSER_ARG_DELIMITER_2
    # ARGPARSER_ARGS
    # ARGPARSER_CHECK_ARG_DEF
    # ARGPARSER_CHECK_ENV_VARS
    # ARGPARSER_CONFIG_FILE
    # ARGPARSER_COUNT_FLAGS
    # ARGPARSER_CREATE_ARG_DEF
    # ARGPARSER_DEBUG
    # ARGPARSER_ERROR_EXIT_CODE
    # ARGPARSER_ERROR_STYLE
    # ARGPARSER_HELP_ARG_GROUP
    # ARGPARSER_HELP_DESCRIPTION
    # ARGPARSER_HELP_EXIT_CODE
    # ARGPARSER_HELP_FILE
    # ARGPARSER_HELP_FILE_INCLUDE_CHAR
    # ARGPARSER_HELP_FILE_KEEP_COMMENTS
    # ARGPARSER_HELP_OPTIONS
    # ARGPARSER_HELP_STYLE
    # ARGPARSER_LANGUAGE
    # ARGPARSER_MAX_COL_WIDTH_1
    # ARGPARSER_MAX_COL_WIDTH_2
    # ARGPARSER_MAX_COL_WIDTH_3
    # ARGPARSER_MAX_WIDTH
    # ARGPARSER_POSITIONAL_ARG_GROUP
    # ARGPARSER_READ_ARGS
    # ARGPARSER_SCRIPT_NAME
    # ARGPARSER_SET_ARGS
    # ARGPARSER_SET_ARRAYS
    # ARGPARSER_SILENCE_ERRORS
    # ARGPARSER_SILENCE_WARNINGS
    # ARGPARSER_STYLE_FILE
    # ARGPARSER_TRANSLATION_FILE
    # ARGPARSER_UNSET_ARGS
    # ARGPARSER_UNSET_ENV_VARS
    # ARGPARSER_UNSET_FUNCTIONS
    # ARGPARSER_USAGE_EXIT_CODE
    # ARGPARSER_USAGE_FILE
    # ARGPARSER_USAGE_FILE_INCLUDE_CHAR
    # ARGPARSER_USAGE_FILE_KEEP_COMMENTS
    # ARGPARSER_USAGE_MESSAGE_OPTION_TYPE
    # ARGPARSER_USAGE_MESSAGE_ORIENTATION
    # ARGPARSER_USAGE_OPTIONS
    # ARGPARSER_USAGE_STYLE
    # ARGPARSER_USE_LONG_OPTIONS
    # ARGPARSER_USE_SHORT_OPTIONS
    # ARGPARSER_USE_STYLES_IN_FILES
    # ARGPARSER_VERSION_EXIT_CODE
    # ARGPARSER_VERSION_NUMBER
    # ARGPARSER_VERSION_OPTIONS
    # ARGPARSER_VERSION_STYLE
    # ARGPARSER_WARNING_STYLE
    # ARGPARSER_WRITE_ARGS

    # Define the local variables.
    local arg
    local arg_key
    local -a args
    local value

    # As the Argparser can be sourced with command-line arguments,
    # separate them from the script's command line.  Any argument until
    # the first "--" is seen as argument to the Argparser.  Lastly,
    # shift also the "--" and set ${script_args} to the remainder of the
    # command line.
    # In order to show the need for the script's command line in the
    # Argparser's help and usage message, ${script_args} is added to the
    # Argparser's arguments definition as mandatory positional argument.
    # Since using its actual value would mean that upon parsing, a "++"
    # in the script's arguments would be interpreted as sign to
    # re-evaluate the arguments as keyword arguments for the Argparser
    # (and not for the script), set the string "argparser" as dummy
    # value for the positional argument.  As only keyword arguments are
    # set as environment variables, below, the actual value of
    # ${script_args} won't be overridden and kept as the script's
    # command line.
    args=( )

    # shellcheck disable=SC2190  # Indexed, not associative array.
    while (( "$#" > 0 )) && [[ -n "$1" && "$1" != "--" ]]; do
        args+=("$1")
        shift
    done
    if (( "$#" > 0 )) && [[ -n "$1" && "$1" == "--" ]]; then
        shift
    fi
    script_args=("$@")
    # shellcheck disable=SC2190  # Indexed, not associative array.
    args+=("--" "argparser")

    # Set all non-internal environment variables by reading the
    # Argparser's command line given upon sourcing the Argparser, using
    # the Argparser itself with default values for all environment
    # variables (which are yet to be set).
    ARGPARSER_ARGS=(
        "id                                  : long_opts                 : val_names    : defaults             : choices    : type : arg_no : arg_group : help                                                                                                          "
        "ARGPARSER_ADD_HELP                  : add-help                  :              : true                 :            : bool : 0      : Options   : add ARGPARSER_HELP_OPTIONS and --help as flags to call the help message                                       "
        "ARGPARSER_ADD_USAGE                 : add-usage                 :              : true                 :            : bool : 0      : Options   : add ARGPARSER_USAGE_OPTIONS and --usage as flags to call the usage message                                    "
        "ARGPARSER_ADD_VERSION               : add-version               :              : true                 :            : bool : 0      : Options   : add ARGPARSER_VERSION_OPTIONS and --version as flags to call the version message                              "
        "ARGPARSER_ALLOW_ARG_INTERMIXING     : allow-arg-intermixing     :              : true                 :            : bool : 0      : Options   : allow the user to intermix positional and keyword arguments                                                   "
        "ARGPARSER_ALLOW_FLAG_INVERSION      : allow-flag-inversion      :              : true                 :            : bool : 0      : Options   : allow the user to invert flags by prefixing them with \"+\" (short options) or \"++\" (long options)          "
        "ARGPARSER_ALLOW_FLAG_NEGATION       : allow-flag-negation       :              : true                 :            : bool : 0      : Options   : allow the user to negate long-option flags by prefixing them with \"no-\"                                     "
        "ARGPARSER_ALLOW_OPTION_ABBREVIATION : allow-option-abbreviation :              : false                :            : bool : 0      : Options   : allow the user to give long option names in abbreviated form                                                  "
        "ARGPARSER_ALLOW_OPTION_MERGING      : allow-option-merging      :              : false                :            : bool : 0      : Options   : allow the user to give short option names in merged (concatenated) form                                       "
        "ARGPARSER_ARG_ARRAY_NAME            : arg-array-name            : NAME         : args                 :            : str  : 1      : Options   : the indexed array for the raw arguments and the associative array for the parsed arguments                    "
        "ARGPARSER_ARG_DEF_FILE              : arg-def-file              : FILE         : ''                   :            : file : 1      : Options   : the path to a file holding the definition of the arguments                                                    "
        "ARGPARSER_ARG_DELIMITER_1           : arg-delimiter-1           : CHAR         : |                    :            : char : 1      : Options   : the primary delimiter that separates the fields in the arguments definition                                   "
        "ARGPARSER_ARG_DELIMITER_2           : arg-delimiter-2           : CHAR         : ,                    :            : char : 1      : Options   : the secondary delimiter that separates the elements of sequences in the arguments definition                  "
        "ARGPARSER_CHECK_ARG_DEF             : check-arg-def             :              : false                :            : bool : 0      : Options   : check if the arguments definition is consistent                                                               "
        "ARGPARSER_CHECK_ENV_VARS            : check-env-vars            :              : false                :            : bool : 0      : Options   : check if the Argparser environment variables accord to their definition                                       "
        "ARGPARSER_CONFIG_FILE               : config-file               : FILE         : ''                   :            : file : 1      : Options   : the path to a file holding the Argparser configuration                                                        "
        "ARGPARSER_COUNT_FLAGS               : count-flags               :              : false                :            : bool : 0      : Options   : count flags instead of setting them to \"true\" or \"false\" based on the last prefix used on the command line"
        "ARGPARSER_CREATE_ARG_DEF            : create-arg-def            :              : false                :            : bool : 0      : Options   : create the arguments definition for a script                                                                  "
        "ARGPARSER_DEBUG                     : debug                     :              : false                :            : bool : 0      : Options   : (EXPERT OPTION) run the Argparser in debug mode, writing the stack trace for each command to STDERR           "
        "ARGPARSER_ERROR_EXIT_CODE           : error-exit-code           : INT          : 1                    :            : int  : 1      : Options   : the exit code when errors occurred upon parsing                                                               "
        "ARGPARSER_ERROR_STYLE               : error-style               : STYLE        : red,bold,reverse     :            : str  : +      : Options   : the color and style specification for error messages                                                          "
        "ARGPARSER_HELP_ARG_GROUP            : help-arg-group            : NAME         : Help options         :            : str  : 1      : Options   : the name of the argument group holding all help options, i.e., --help, --usage, and --version                 "
        "ARGPARSER_HELP_DESCRIPTION          : help-description          : TEXT         : ''                   :            : str  : 1      : Options   : the script's description (purpose) to show in help message                                                    "
        "ARGPARSER_HELP_EXIT_CODE            : help-exit-code            : INT          : 0                    :            : int  : 1      : Options   : the exit code for help messages                                                                               "
        "ARGPARSER_HELP_FILE                 : help-file                 : FILE         : ''                   :            : file : 1      : Options   : the path to a file holding the extended help message                                                          "
        "ARGPARSER_HELP_FILE_INCLUDE_CHAR    : help-file-include-char    : CHAR         : @                    :            : char : 1      : Options   : the character that introduces an include directive in an ARGPARSER_HELP_FILE                                  "
        "ARGPARSER_HELP_FILE_KEEP_COMMENTS   : help-file-keep-comments   :              : false                :            : bool : 0      : Options   : keep commented lines in the help file                                                                         "
        "ARGPARSER_HELP_OPTIONS              : help-options              : CHAR         : h,?                  :            : char : +      : Options   : the short (single-character) option names to invoke the help message                                          "
        "ARGPARSER_HELP_STYLE                : help-style                : STYLE        : italic               :            : str  : +      : Options   : the color and style specification for help messages                                                           "
        "ARGPARSER_LANGUAGE                  : language                  : LANG         : en                   :            : str  : 1      : Options   : the language in which to localize the help and usage messages                                                 "
        "ARGPARSER_MAX_COL_WIDTH_1           : max-col-width-1           : INT          : 9                    :            : uint : 1      : Options   : the maximum column width of the first column in the help message                                              "
        "ARGPARSER_MAX_COL_WIDTH_2           : max-col-width-2           : INT          : 33                   :            : uint : 1      : Options   : the maximum column width of the second column in the help message                                             "
        "ARGPARSER_MAX_COL_WIDTH_3           : max-col-width-3           : INT          : 0                    :            : uint : 1      : Options   : the maximum column width of the third column in the help message                                              "
        "ARGPARSER_MAX_WIDTH                 : max-width                 : INT          : 79                   :            : uint : 1      : Options   : the maximum width of the help message                                                                         "
        "ARGPARSER_POSITIONAL_ARG_GROUP      : positional-arg-group      : NAME         : Positional arguments :            : str  : 1      : Options   : the name of the argument group holding all positional arguments                                               "
        "ARGPARSER_READ_ARGS                 : read-args                 :              : true                 :            : bool : 0      : Options   : read the arguments and parse them to ARGPARSER_ARG_ARRAY_NAME                                                 "
        "ARGPARSER_SCRIPT_NAME               : script-name               : NAME         : ''                   :            : str  : 1      : Options   : the script's name for the help, usage, version, error, and warning messages                                   "
        "ARGPARSER_SET_ARGS                  : set-args                  :              : true                 :            : bool : 0      : Options   : set the arguments from ARGPARSER_ARG_ARRAY_NAME as variables in the script's scope                            "
        "ARGPARSER_SET_ARRAYS                : set-arrays                :              : true                 :            : bool : 0      : Options   : set arguments intended to have multiple values as indexed array                                               "
        "ARGPARSER_SILENCE_ERRORS            : silence-errors            :              : false                :            : bool : 0      : Options   : silence the emission (output) of error messages                                                               "
        "ARGPARSER_SILENCE_WARNINGS          : silence-warnings          :              : false                :            : bool : 0      : Options   : silence the emission (output) of warning messages                                                             "
        "ARGPARSER_STYLE_FILE                : style-file                : FILE         : ''                   :            : file : 1      : Options   : the path to a file holding the style definitions for the messages                                             "
        "ARGPARSER_TRANSLATION_FILE          : translation-file          : FILE         : ''                   :            : file : 1      : Options   : the path to a simplified YAML file holding the translation to ARGPARSER_LANGUAGE                              "
        "ARGPARSER_UNSET_ARGS                : unset-args                :              : true                 :            : bool : 0      : Options   : unset (remove) all command-line arguments given to the script                                                 "
        "ARGPARSER_UNSET_ENV_VARS            : unset-env-vars            :              : true                 :            : bool : 0      : Options   : unset (remove) the Argparser environment variables from the environment                                       "
        "ARGPARSER_UNSET_FUNCTIONS           : unset-functions           :              : true                 :            : bool : 0      : Options   : unset (remove) the Argparser functions from the environment                                                   "
        "ARGPARSER_USAGE_EXIT_CODE           : usage-exit-code           : INT          : 0                    :            : int  : 1      : Options   : the exit code for usage messages                                                                              "
        "ARGPARSER_USAGE_FILE                : usage-file                : FILE         : ''                   :            : file : 1      : Options   : the path to a file holding the extended usage message                                                         "
        "ARGPARSER_USAGE_FILE_INCLUDE_CHAR   : usage-file-include-char   : CHAR         : @                    :            : char : 1      : Options   : the character that introduces an include directive in an ARGPARSER_USAGE_FILE                                 "
        "ARGPARSER_USAGE_FILE_KEEP_COMMENTS  : usage-file-keep-comments  :              : false                :            : bool : 0      : Options   : keep commented lines in the usage file                                                                        "
        "ARGPARSER_USAGE_MESSAGE_OPTION_TYPE : usage-message-option-type :              : short                : long,short : str  : 1      : Options   : use short or long option names in usage messages                                                              "
        "ARGPARSER_USAGE_MESSAGE_ORIENTATION : usage-message-orientation :              : row                  : row,column : str  : 1      : Options   : output the positional and keyword arguments in usage messages in a row or in a column                         "
        "ARGPARSER_USAGE_OPTIONS             : usage-options             : CHAR         : u                    :            : char : +      : Options   : the short (single-character) option names to invoke the usage message                                         "
        "ARGPARSER_USAGE_STYLE               : usage-style               : STYLE        : italic               :            : str  : +      : Options   : the color and style specification for usage messages                                                          "
        "ARGPARSER_USE_LONG_OPTIONS          : use-long-options          :              : true                 :            : bool : 0      : Options   : use the long option names for parsing                                                                         "
        "ARGPARSER_USE_SHORT_OPTIONS         : use-short-options         :              : true                 :            : bool : 0      : Options   : use the short option names for parsing                                                                        "
        "ARGPARSER_USE_STYLES_IN_FILES       : use-styles-in-files       :              : false                :            : bool : 0      : Options   : use the colors and styles when STDOUT/STDERR is not a terminal                                                "
        "ARGPARSER_VERSION_EXIT_CODE         : version-exit-code         : INT          : 0                    :            : int  : 1      : Options   : the exit code for version messages                                                                            "
        "ARGPARSER_VERSION_NUMBER            : version-number            : VERSION      : 1.0.0                :            : str  : 1      : Options   : the script's version number for the version message                                                           "
        "ARGPARSER_VERSION_OPTIONS           : version-options           : CHAR         : V                    :            : char : +      : Options   : the short (single-character) option names to invoke the version message                                       "
        "ARGPARSER_VERSION_STYLE             : version-style             : STYLE        : bold                 :            : str  : +      : Options   : the color and style specification for version messages                                                        "
        "ARGPARSER_WARNING_STYLE             : warning-style             : STYLE        : red,bold             :            : str  : +      : Options   : the color and style specification for warning messages                                                        "
        "ARGPARSER_WRITE_ARGS                : write-args                :              : false                :            : bool : 0      : Options   : write the arguments from ARGPARSER_ARG_ARRAY_NAME to STDOUT                                                   "
        "script_args                         :                           : command_line :                      :            : str  : +      : Options   : the indexed array in which the Argparser stores the script's command line upon parsing its own arguments      "
    )

    ARGPARSER_ADD_HELP=true \
        ARGPARSER_ADD_USAGE=true \
        ARGPARSER_ADD_VERSION=true \
        ARGPARSER_ALLOW_ARG_INTERMIXING=false \
        ARGPARSER_ALLOW_FLAG_INVERSION=true \
        ARGPARSER_ALLOW_FLAG_NEGATION=true \
        ARGPARSER_ALLOW_OPTION_ABBREVIATION=false \
        ARGPARSER_ALLOW_OPTION_MERGING=false \
        ARGPARSER_ARG_ARRAY_NAME="ARGPARSER_ARGS" \
        ARGPARSER_ARG_DEF_FILE="" \
        ARGPARSER_ARG_DELIMITER_1=":" \
        ARGPARSER_ARG_DELIMITER_2="," \
        ARGPARSER_CHECK_ARG_DEF=false \
        ARGPARSER_CHECK_ENV_VARS=false \
        ARGPARSER_CONFIG_FILE="" \
        ARGPARSER_COUNT_FLAGS=false \
        ARGPARSER_CREATE_ARG_DEF=false \
        ARGPARSER_ERROR_EXIT_CODE=1 \
        ARGPARSER_ERROR_STYLE="red,bold,reverse" \
        ARGPARSER_HELP_ARG_GROUP="Help options" \
        ARGPARSER_HELP_DESCRIPTION="" \
        ARGPARSER_HELP_EXIT_CODE=0 \
        ARGPARSER_HELP_FILE="" \
        ARGPARSER_HELP_FILE_INCLUDE_CHAR="@" \
        ARGPARSER_HELP_FILE_KEEP_COMMENTS=false \
        ARGPARSER_HELP_OPTIONS="h,?" \
        ARGPARSER_HELP_STYLE="italic" \
        ARGPARSER_LANGUAGE="en" \
        ARGPARSER_MAX_COL_WIDTH_1=5 \
        ARGPARSER_MAX_COL_WIDTH_2=33 \
        ARGPARSER_MAX_COL_WIDTH_3=0 \
        ARGPARSER_MAX_WIDTH=79 \
        ARGPARSER_POSITIONAL_ARG_GROUP="Positional arguments" \
        ARGPARSER_READ_ARGS=true \
        ARGPARSER_SCRIPT_NAME="${BASH_SOURCE[0]##*/}" \
        ARGPARSER_SET_ARGS=false \
        ARGPARSER_SET_ARRAYS=false \
        ARGPARSER_SILENCE_ERRORS=false \
        ARGPARSER_SILENCE_WARNINGS=false \
        ARGPARSER_STYLE_FILE="" \
        ARGPARSER_TRANSLATION_FILE="" \
        ARGPARSER_UNSET_ARGS=true \
        ARGPARSER_UNSET_ENV_VARS=false \
        ARGPARSER_UNSET_FUNCTIONS=false \
        ARGPARSER_USAGE_EXIT_CODE=0 \
        ARGPARSER_USAGE_FILE="" \
        ARGPARSER_USAGE_FILE_INCLUDE_CHAR="@" \
        ARGPARSER_USAGE_FILE_KEEP_COMMENTS=false \
        ARGPARSER_USAGE_MESSAGE_OPTION_TYPE="long" \
        ARGPARSER_USAGE_MESSAGE_ORIENTATION="column" \
        ARGPARSER_USAGE_OPTIONS="u" \
        ARGPARSER_USAGE_STYLE="italic" \
        ARGPARSER_USE_LONG_OPTIONS=true \
        ARGPARSER_USE_SHORT_OPTIONS=false \
        ARGPARSER_USE_STYLES_IN_FILES=false \
        ARGPARSER_VERSION_EXIT_CODE=0 \
        ARGPARSER_VERSION_NUMBER="${argparser_version}" \
        ARGPARSER_VERSION_OPTIONS="V" \
        ARGPARSER_VERSION_STYLE="bold" \
        ARGPARSER_WARNING_STYLE="red,bold" \
        ARGPARSER_WRITE_ARGS=false \
        argparser_parse_args "${args[@]}"

    # Set the environment variables that aren't set yet as global
    # variables.  For all environment variables that weren't given by
    # neither a config file, nor as an environment variable assignment,
    # nor as a command-line parameter to the Argparser, use the default
    # value the Argparser has assigned.  If the environment variable has
    # been given before, check if it was also given on the command line,
    # then override the previous value, else, keep the previous value.
    # By this, the command-line parameters have a higher importance than
    # environment variables.  For those environment variables whose
    # default is given as "''" (two single quotes), set the value to the
    # empty string.  For ${ARGPARSER_SCRIPT_NAME}, set the value to the
    # basename of the script's $0, if an empty string is given.  Skip
    # ${script_args}, i.e., the command line.
    for arg_key in "${!ARGPARSER_ARGS[@]}"; do
        if [[ "${arg_key}" == "script_args" ]]; then
            continue
        elif [[ -v "${arg_key}" ]]; then
            # The environment variable has already been set.  Override
            # it if it was also given on the command line.
            for arg in "${args[@]}"; do
                # Set the variable name as shortest part before an
                # equals sign ("="), strip the leading hyphens, replace
                # inner hyphens by underscores, capitalize the variable
                # name, and prepend the string "ARGPARSER_".
                arg="${arg%%=*}"
                arg="${arg#--}"
                arg="${arg//-/_}"
                arg="ARGPARSER_${arg^^}"

                # If the command-line argument is the current
                # environment variable, override its value with the one
                # given on the command line, which was parsed by the
                # Argparser.
                if [[ "${arg}" == "${arg_key}" ]]; then
                    value="${ARGPARSER_ARGS[${arg_key}]}"
                    if [[ "${value}" == "''" ]]; then
                        if [[ "${arg_key}" == "ARGPARSER_SCRIPT_NAME" ]]; then
                            value="${0##*/}"
                        else
                            value=""
                        fi
                    fi
                    declare -g "${arg_key}"="${value}"
                    break
                fi
            done
        else
            # The environment variable is yet unset, so set it to the
            # value the Argparser has set upon parsing, i.e., either the
            # value from the command line, or, if absent, the default
            # value.
            value="${ARGPARSER_ARGS[${arg_key}]}"
            if [[ "${value}" == "''" ]]; then
                if [[ "${arg_key}" == "ARGPARSER_SCRIPT_NAME" ]]; then
                    value="${0##*/}"
                else
                    value=""
                fi
            fi
            declare -g "${arg_key}"="${value}"
        fi
    done
}

function argparser_check_env_vars() {
    # Check if the Argparser environment variables accord to their
    # definition.  This should always be true for production scripts,
    # but maybe not while testing, and also not if the user is allowed
    # to set the variables himself.
    #
    # The following environment variables are unchecked:
    # - ARGPARSER_ARGS (auto-set)
    # - ARGPARSER_HELP_ARG_GROUP (arbitrary value)
    # - ARGPARSER_HELP_DESCRIPTION (arbitrary value)
    # - ARGPARSER_LANGUAGE (arbitrary value)
    # - ARGPARSER_POSITIONAL_ARG_GROUP (arbitrary value)
    # - ARGPARSER_SCRIPT_NAME (arbitrary value)
    # - ARGPARSER_VERSION_NUMBER (arbitrary value)
    #
    # The following environment variables are only checked for mutual
    # exclusivity with other environment variables:
    # - ARGPARSER_CONFIG_FILE (checked earlier)
    # - ARGPARSER_TRANSLATION_FILE (checked earlier)
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    # - ARGPARSER_ALLOW_ARG_INTERMIXING (read-only)
    # - ARGPARSER_ALLOW_FLAG_INVERSION (read-only)
    # - ARGPARSER_ALLOW_FLAG_NEGATION (read-only)
    # - ARGPARSER_ALLOW_OPTION_ABBREVIATION (read-only)
    # - ARGPARSER_ALLOW_OPTION_MERGING (read-only)
    # - ARGPARSER_ARG_ARRAY_NAME (read-only)
    # - ARGPARSER_ARG_DEF_FILE (read-only)
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_CHECK_ARG_DEF (read-only)
    # - ARGPARSER_CHECK_ENV_VARS (read-only)
    # - ARGPARSER_COUNT_FLAGS (read-only)
    # - ARGPARSER_CREATE_ARG_DEF (read-only)
    # - ARGPARSER_DEBUG (read-only)
    # - ARGPARSER_ERROR_EXIT_CODE
    # - ARGPARSER_ERROR_STYLE
    # - ARGPARSER_HELP_EXIT_CODE (read-only)
    # - ARGPARSER_HELP_FILE (read-only)
    # - ARGPARSER_HELP_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_HELP_FILE_KEEP_COMMENTS (read-only)
    # - ARGPARSER_HELP_OPTIONS (read-only)
    # - ARGPARSER_HELP_STYLE (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_1 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_2 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_3 (read-only)
    # - ARGPARSER_MAX_WIDTH (read-only)
    # - ARGPARSER_READ_ARGS (read-only)
    # - ARGPARSER_SET_ARGS (read-only)
    # - ARGPARSER_SET_ARRAYS (read-only)
    # - ARGPARSER_SILENCE_ERRORS (read-only)
    # - ARGPARSER_SILENCE_WARNINGS (read-only)
    # - ARGPARSER_UNSET_ARGS (read-only)
    # - ARGPARSER_UNSET_ENV_VARS (read-only)
    # - ARGPARSER_UNSET_FUNCTIONS (read-only)
    # - ARGPARSER_USAGE_EXIT_CODE (read-only)
    # - ARGPARSER_USAGE_FILE (read-only)
    # - ARGPARSER_USAGE_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_USAGE_FILE_KEEP_COMMENTS (read-only)
    # - ARGPARSER_USAGE_MESSAGE_OPTION_TYPE (read-only)
    # - ARGPARSER_USAGE_MESSAGE_ORIENTATION (read-only)
    # - ARGPARSER_USAGE_OPTIONS (read-only)
    # - ARGPARSER_USAGE_STYLE (read-only)
    # - ARGPARSER_USE_LONG_OPTIONS (read-only)
    # - ARGPARSER_USE_SHORT_OPTIONS (read-only)
    # - ARGPARSER_USE_STYLES_IN_FILES (read-only)
    # - ARGPARSER_VERSION_EXIT_CODE (read-only)
    # - ARGPARSER_VERSION_OPTIONS (read-only)
    # - ARGPARSER_VERSION_STYLE (read-only)
    # - ARGPARSER_WARNING_STYLE (read-only)
    # - ARGPARSER_WRITE_ARGS (read-only)

    # Define the local variables.
    local -A checked_short_options
    local error_message
    local -a error_messages
    local file_attributes
    local i
    local short_option
    local -a short_options
    local translation
    local value
    local -a values
    local var
    local var_1
    local var_2
    local -a vars

    # Check if all environment variables expected to be Booleans are
    # "true" or "false".  Else, output an error message.
    error_messages=( )
    vars=(
        ARGPARSER_ADD_HELP
        ARGPARSER_ADD_USAGE
        ARGPARSER_ADD_VERSION
        ARGPARSER_ALLOW_ARG_INTERMIXING
        ARGPARSER_ALLOW_FLAG_INVERSION
        ARGPARSER_ALLOW_FLAG_NEGATION
        ARGPARSER_ALLOW_OPTION_ABBREVIATION
        ARGPARSER_ALLOW_OPTION_MERGING
        ARGPARSER_CHECK_ARG_DEF
        ARGPARSER_CHECK_ENV_VARS
        ARGPARSER_COUNT_FLAGS
        ARGPARSER_CREATE_ARG_DEF
        ARGPARSER_DEBUG
        ARGPARSER_HELP_FILE_KEEP_COMMENTS
        ARGPARSER_READ_ARGS
        ARGPARSER_SET_ARGS
        ARGPARSER_SET_ARRAYS
        ARGPARSER_SILENCE_ERRORS
        ARGPARSER_SILENCE_WARNINGS
        ARGPARSER_UNSET_ARGS
        ARGPARSER_UNSET_ENV_VARS
        ARGPARSER_UNSET_FUNCTIONS
        ARGPARSER_USAGE_FILE_KEEP_COMMENTS
        ARGPARSER_USE_LONG_OPTIONS
        ARGPARSER_USE_SHORT_OPTIONS
        ARGPARSER_USE_STYLES_IN_FILES
        ARGPARSER_WRITE_ARGS
    )
    for var in "${vars[@]}"; do
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a values <<< "${!var}"
        for value in "${values[@]}"; do
            if ! argparser_is_bool "${value}"; then
                error_message="Error: The environment variable \"\$1\" is set "
                error_message+="to \"\$2\", but must be a Boolean, i.e., "
                error_message+="\"true\" or \"false\"."

                argparser_translate "Error env var bool" "${error_message}" \
                    "${var}" "${!var}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        done
    done

    # Check if all environment variables expected to be characters are
    # one-character strings.  Else, output an error message.
    vars=(
        ARGPARSER_ARG_DELIMITER_1
        ARGPARSER_ARG_DELIMITER_2
        ARGPARSER_HELP_FILE_INCLUDE_CHAR
        ARGPARSER_HELP_OPTIONS
        ARGPARSER_USAGE_FILE_INCLUDE_CHAR
        ARGPARSER_USAGE_OPTIONS
        ARGPARSER_VERSION_OPTIONS
    )
    for var in "${vars[@]}"; do
        if [[ "${var}" == "ARGPARSER_ARG_DELIMITER_2" ]]; then
            values=("${!var}")
        else
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a values <<< "${!var}"
        fi

        for value in "${values[@]}"; do
            if ! argparser_is_char "${value}"; then
                error_message="Error: The environment variable \"\$1\" is set "
                error_message+="to \"\$2\", but must be a character, i.e., a "
                error_message+="string comprising one printable ASCII "
                error_message+="character."

                argparser_translate "Error env var char" "${error_message}" \
                    "${var}" "${!var}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        done
    done

    # Check if all environment variables to be used as Bash variable
    # identifiers start with a letter or underscore and contain only
    # letters, digits, and underscores.  Else, output an error message.
    vars=(
        ARGPARSER_ARG_ARRAY_NAME
    )
    for var in "${vars[@]}"; do
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a values <<< "${!var}"
        for value in "${values[@]}"; do
            if ! argparser_is_identifier "${value}"; then
                error_message="Error: The environment variable \"\$1\" is set "
                error_message+="to \"\$2\", but designed to be used as Bash "
                error_message+="variable identifier, i.e., its value must "
                error_message+="start with a letter or underscore and contain "
                error_message+="only letters, digits, and underscores."

                argparser_translate "Error env var identifier" \
                    "${error_message}" "${var}" "${!var}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        done
    done

    # Check if all environment variables expected to be integers are
    # only digits, possibly with a leading sign.  Else, output an error
    # message.
    vars=(
        ARGPARSER_ERROR_EXIT_CODE
        ARGPARSER_HELP_EXIT_CODE
        ARGPARSER_USAGE_EXIT_CODE
        ARGPARSER_VERSION_EXIT_CODE
    )
    for var in "${vars[@]}"; do
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a values <<< "${!var}"
        for value in "${values[@]}"; do
            if ! argparser_is_int "${value}"; then
                error_message="Error: The environment variable \"\$1\" is set "
                error_message+="to \"\$2\", but must be an integer, i.e., "
                error_message+="comprise only digits and possibly a leading "
                error_message+="sign."

                argparser_translate "Error env var int" "${error_message}" \
                    "${var}" "${!var}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        done
    done

    # Check if all environment variables expected to be unsigned
    # integers are only digits.  Else, output an error message.
    vars=(
        ARGPARSER_MAX_COL_WIDTH_1
        ARGPARSER_MAX_COL_WIDTH_2
        ARGPARSER_MAX_COL_WIDTH_3
        ARGPARSER_MAX_WIDTH
    )
    for var in "${vars[@]}"; do
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a values <<< "${!var}"
        for value in "${values[@]}"; do
            if ! argparser_is_uint "${value}"; then
                error_message="Error: The environment variable \"\$1\" is set "
                error_message+="to \"\$2\", but must be an unsigned integer, "
                error_message+="i.e., comprise only digits and no sign."

                argparser_translate "Error env var uint" "${error_message}" \
                    "${var}" "${!var}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        done
    done

    # Check if all environment variables expected to point to files have
    # the referenced file existing, readable, and with a size greater
    # than 0 bytes.  Else, output an error message.
    vars=(
        ARGPARSER_ARG_DEF_FILE
        ARGPARSER_HELP_FILE
        ARGPARSER_STYLE_FILE
        ARGPARSER_USAGE_FILE
    )
    for var in "${vars[@]}"; do
        argparser_check_file "${!var}"
        if [[ -n "${!var}" && "${file_attributes}" != "0000" ]]; then
            error_message="Error: The environment variable \"\$1\" is set to "
            error_message+="\"\$2\", but the referenced file "
            case "${file_attributes}" in
                0001) error_message+="is empty." ;;
                0010) error_message+="is not readable." ;;
                0011) error_message+="is not readable and empty." ;;
                0100) error_message+="is not a regular file." ;;
                0101) error_message+="is not a regular file and empty." ;;
                0110)
                    error_message+="is not a regular file and not readable."
                    ;;
                0111)
                    error_message+="is not a regular file, not readable, and "
                    error_message+="empty."
                    ;;
                1111) error_message+="does not exist." ;;
            esac

            argparser_translate "Error env var file ${file_attributes}" \
                "${error_message}" "${var}" "${!var}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables with a limited set of allowed
    # values have their values lying in them.  Else, output an error
    # message.
    # First, check that the argument definition delimiters don't use the
    # reserved characters.
    vars=(
        ARGPARSER_ARG_DELIMITER_1
        ARGPARSER_ARG_DELIMITER_2
    )
    for var in "${vars[@]}"; do
        if argparser_in_array "${!var}" "-" "+" "*" "?"; then
            error_message="Error: The environment variable \"\$1\" is set to "
            error_message+="\"\$2\", but hyphens, plus signs, asterisks, and "
            error_message+="question marks are reserved characters."

            argparser_translate "Error env var delimiters reserved" \
                "${error_message}" "${var}" "${!var}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi
    done

    # Then, check if all environment variables for styles only have
    # values supported by argparser_colorize.
    vars=(
        ARGPARSER_ERROR_STYLE
        ARGPARSER_HELP_STYLE
        ARGPARSER_USAGE_STYLE
        ARGPARSER_VERSION_STYLE
        ARGPARSER_WARNING_STYLE
    )
    for var in "${vars[@]}"; do
        if ! argparser_check_color_or_style "${!var}"; then
            error_message="Error: The environment variable \"\$1\" is set to "
            error_message+="\"\$2\", but the values must lie in {black, red, "
            error_message+="green, yellow, blue, magenta, cyan, white} for "
            error_message+="colors and in {normal, bold, faint, italic, "
            error_message+="underline, double, overline, crossed-out, blink, "
            error_message+="reverse} for styles."

            argparser_translate "Error env var styles" "${error_message}" \
                "${var}" "${!var}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi
    done

    # Then, check the option type for usage messages.
    if [[ "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" != "long" \
        && "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" != "short" ]]
    then
        error_message="Error: The environment variable "
        error_message+="\"ARGPARSER_USAGE_MESSAGE_OPTION_TYPE\" must be "
        error_message+="either set to \"long\" or \"short\", but is \"\$1\"."

        argparser_translate "Error env var option type" "${error_message}" \
            "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}"
        error_message="${translation}"
        error_messages+=("${error_message}")
    fi

    # Then, check the orientation for usage messages.
    if [[ "${ARGPARSER_USAGE_MESSAGE_ORIENTATION}" != "row" \
        && "${ARGPARSER_USAGE_MESSAGE_ORIENTATION}" != "column" ]]
    then
        error_message="Error: The environment variable "
        error_message+="\"ARGPARSER_USAGE_MESSAGE_ORIENTATION\" must be "
        error_message+="either set to \"row\" or \"column\", but is \"\$1\"."

        argparser_translate "Error env var orientation" "${error_message}" \
            "${ARGPARSER_USAGE_MESSAGE_ORIENTATION}"
        error_message="${translation}"
        error_messages+=("${error_message}")
    fi

    # Check the environment variables with mutually exclusive values.
    # First, check that the argument definition delimiters are
    # different.
    # shellcheck disable=SC2153  # No misspelling for variable names.
    if [[ "${ARGPARSER_ARG_DELIMITER_1}" == "${ARGPARSER_ARG_DELIMITER_2}" ]]
    then
        error_message="Error: The environment variables "
        error_message+="\"ARGPARSER_ARG_DELIMITER_1\" and "
        error_message+="\"ARGPARSER_ARG_DELIMITER_2\" must have different "
        error_message+="values, but are both \"\$1\"."

        argparser_translate "Error env var delimiters identical" \
            "${error_message}" "${ARGPARSER_ARG_DELIMITER_1}"
        error_message="${translation}"
        error_messages+=("${error_message}")
    fi

    # Then, check the short option names for help, usage, and version
    # messages.
    vars=(
        ARGPARSER_HELP_OPTIONS
        ARGPARSER_USAGE_OPTIONS
        ARGPARSER_VERSION_OPTIONS
    )
    for var in "${vars[@]}"; do
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
            <<< "${!var}"

        # If more than one short option name is given, check if any is
        # the empty string, which must only once be used as placeholder
        # for missing short options.  Then, check if any short option
        # name is longer than one character, and if it is given multiple
        # times in the current environment variable's value or across
        # all yet investigated environment variables' values.  If only
        # one short option name is given, the empty string is a legit
        # value, so don't check this.
        if (( "${#short_options[@]}" > 1 )) \
            && argparser_in_array "" "${short_options[@]}"
        then
            # Check if the empty string is included in the short option
            # names.
            error_message="Error: The environment variable \"\$1\" has an "
            error_message+="empty string given as one of the \$2 short option "
            error_message+="names, instead of a legit name."

            argparser_translate "Error env var short name empty" \
                "${error_message}" "${var}" "${#short_options[@]}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi

        for short_option in "${short_options[@]}"; do
            if [[ -z "${short_option}" ]]; then
                continue
            fi

            # Check if a short option name is more than one character
            # long.
            if (( "${#short_option}" > 1 )); then
                error_message="Error: The environment variable \"\$1\" has "
                error_message+="the short option \"-\$2\" defined with more "
                error_message+="than 1 character length."

                argparser_translate "Error env var short name length" \
                    "${error_message}" "${var}" "${short_option}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi

            # Check if the short option name is given multiple times
            # in the current environment variable's value.
            argparser_count "${short_option}" "${short_options[@]}"
            if (( count > 1 )); then
                error_message="Error: The environment variable \"\$1\" has "
                error_message+="the short option \"-\$2\" given \$3 times."

                argparser_translate "Error env var short name duplication 1" \
                    "${error_message}" "${var}" "${short_option}" "${count}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi

            # Check if the short option name is already given in
            # another environment variable's value.
            if argparser_in_array "${short_option}" \
                "${!checked_short_options[@]}" \
                && [[ "${checked_short_options[${short_option}]}" \
                    != "${var}" ]]
            then
                error_message="Error: The environment variable \"\$1\" has "
                error_message+="the short option \"-\$2\" given, but that is "
                error_message+="already in use by \"\$3\"."

                argparser_translate "Error env var short name duplication 2" \
                    "${error_message}" "${var}" "${short_option}" \
                    "${checked_short_options[${short_option}]}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi

            # Add the short option name to the associative array of
            # all short option names.
            checked_short_options[${short_option}]="${var}"
        done
    done

    # Then, check that the preference for short/long options doesn't
    # collide with them being ignored.
    if [[ "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" == "short" \
        && "${ARGPARSER_USE_SHORT_OPTIONS}" == false ]]
    then
        error_message="Error: The environment variable "
        error_message+="\"ARGPARSER_USAGE_MESSAGE_OPTION_TYPE\" requests the "
        error_message+="usage of short option names, but "
        error_message+="\"ARGPARSER_USE_SHORT_OPTIONS\" turns them off."

        argparser_translate "Error env var short options" "${error_message}"
        error_message="${translation}"
        error_messages+=("${error_message}")
    fi

    if [[ "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" == "long" \
        && "${ARGPARSER_USE_LONG_OPTIONS}" == false ]]
    then
        error_message="Error: The environment variable "
        error_message+="\"ARGPARSER_USAGE_MESSAGE_OPTION_TYPE\" requests the "
        error_message+="usage of long option names, but "
        error_message+="\"ARGPARSER_USE_LONG_OPTIONS\" turns them off."

        argparser_translate "Error env var long options" "${error_message}"
        error_message="${translation}"
        error_messages+=("${error_message}")
    fi

    # Then, check that the arguments definition file, the configuration
    # file, the help file, the style file, the translation file, and the
    # usage file are different from each other, if given.
    vars=(
        ARGPARSER_ARG_DEF_FILE
        ARGPARSER_CONFIG_FILE
        ARGPARSER_HELP_FILE
        ARGPARSER_STYLE_FILE
        ARGPARSER_TRANSLATION_FILE
        ARGPARSER_USAGE_FILE
    )
    for i in "${!vars[@]}"; do
        var_1="${vars[i]}"
        for var_2 in "${vars[@]:i+1}"; do
            if [[ -n "${!var_1}" && "${!var_1}" == "${!var_2}" ]]; then
                error_message="Error: The environment variables \"\$1\" and "
                error_message+="\"\$2\" point to the same file."

                argparser_translate "Error env var files" "${error_message}" \
                    "${var_1}" "${var_2}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        done
    done

    # If there are error messages, sort, filter, colorize, and print
    # them, then exit, as parsing the arguments with a faulty
    # environment variable configuration might be impossible.  If
    # ${ARGPARSER_ERROR_STYLE} is among the faulty variables, the error
    # messages cannot be properly colorized.  Thus, set the style to its
    # default value.  The same holds true for
    # ${ARGPARSER_ERROR_EXIT_CODE}.
    for error_message in "${error_messages[@]}"; do
        if [[ "${error_message}" == *"ARGPARSER_ERROR_EXIT_CODE"* ]]; then
            ARGPARSER_ERROR_EXIT_CODE=1
        elif [[ "${error_message}" == *"ARGPARSER_ERROR_STYLE"* ]]; then
            ARGPARSER_ERROR_STYLE="red,bold,reverse"
        fi
    done

    argparser_print_error_message true true "${error_messages[@]}"
}

# Define the Argparser functions for reading the translation and
# translating strings.
function argparser_read_translation() {
    # Read the translation of the auto-generated text for help and usage
    # messages from the YAML file into an associative array.
    #
    # Nonlocals:
    # - dictionary: the associative array containing the translations
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2
    # - ARGPARSER_CHECK_ENV_VARS
    # - ARGPARSER_ERROR_EXIT_CODE
    # - ARGPARSER_ERROR_STYLE
    # - ARGPARSER_LANGUAGE (read-only)
    # - ARGPARSER_TRANSLATION_FILE (read-only)

    # Define the local variables.
    local -a error_lines
    local error_message
    local -a error_messages
    local file_attributes
    local group
    local is_continued
    local language
    local line
    local -a lines
    local translation

    # Check if the translation file exists and is readable.  Else,
    # output an error message and exit.  Since at this point of
    # invokation, the environment variables aren't checked, yet, set the
    # needed ones to default values, if ${ARGPARSER_CHECK_ENV_VARS}
    # isn't set to "false" (and by this, the checking hasn't been
    # explicitly disabled).
    argparser_check_file "${ARGPARSER_TRANSLATION_FILE}"
    if [[ "${file_attributes}" != "0000" ]]; then
        error_message="Error: The environment variable \"\$1\" is set to "
        error_message+="\"\$2\", but the referenced file "
        case "${file_attributes}" in
            0001) error_message+="is empty." ;;
            0010) error_message+="is not readable." ;;
            0011) error_message+="is not readable and empty." ;;
            0100) error_message+="is not a regular file." ;;
            0101) error_message+="is not a regular file and empty." ;;
            0110) error_message+="is not a regular file and not readable." ;;
            0111)
                error_message+="is not a regular file, not readable, and "
                error_message+="empty."
                ;;
            1111) error_message+="does not exist." ;;
        esac

        error_message="${error_message/"\$1"/"ARGPARSER_TRANSLATION_FILE"}"
        error_message="${error_message/"\$2"/${ARGPARSER_TRANSLATION_FILE}}"

        if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
            ARGPARSER_ARG_DELIMITER_2=","
            ARGPARSER_ERROR_EXIT_CODE=1
            ARGPARSER_ERROR_STYLE="red,bold,reverse"
        fi

        argparser_print_error_message false true "${error_message}"
    fi

    # Read the translation file.  Use "?" as sentinel to denote the
    # absence of a translation, to be overridden by the actual
    # translation, once read.
    mapfile -t lines < "${ARGPARSER_TRANSLATION_FILE}"
    group=""
    language=""
    translation="?"
    is_continued=false
    error_lines=( )
    error_messages=( )

    for line in "${lines[@]}"; do
        if [[ -z "${line}" || "${line}" == \#* ]]; then
            # The line is empty or commented.
            continue
        elif [[ "${line}" == "---" || "${line}" == "..." ]]; then
            # The line denotes the start or end of a YAML block.
            continue
        elif [[ "${line}" == "  ${ARGPARSER_LANGUAGE}: >" ]]; then
            # The line starts the translation to the desired language.
            language="${ARGPARSER_LANGUAGE}"
            translation="?"
            is_continued=true
        elif [[ "${line}" == "  ${ARGPARSER_LANGUAGE}:" ]]; then
            # The line contains the translation to the desired language
            # for an empty translation.
            language="${ARGPARSER_LANGUAGE}"
            translation=""
        elif [[ "${line}" == "  ${ARGPARSER_LANGUAGE}: "* ]]; then
            # The line contains the translation to the desired language.
            language="${ARGPARSER_LANGUAGE}"
            translation="${line#*: }"
        elif [[ "${line}" == "  "*": >" ]]; then
            # The line start the translation to another language, which
            # can be ignored, along all following lines until the start
            # of a new YAML key.
            language="${line#* }"
            language="${language%:*}"
            is_continued=true
        elif [[ "${line}" == "  "*([^ ])":" || "${line}" == "  "*([^ ])": "* ]]
        then
            # The line contains the translation to another language,
            # which can be ignored.
            language="${line#* }"
            language="${language%:*}"
        elif [[ "${line}" == "    "* \
            && "${language}" == "${ARGPARSER_LANGUAGE}" \
            && "${is_continued}" == true ]]
        then
            # The line continues the translation from the previous line.
            if [[ "${translation}" == "?" ]]; then
                translation="${line#    }"
            else
                translation+=" ${line#    }"
            fi
        elif [[ "${line}" == "    "* && "${is_continued}" == true ]]; then
            # The line continues the translation to another language,
            # from the previous line, which can be ignored.
            continue
        elif [[ "${line}" == *: && "${line::1}" != " " ]]; then
            # The line starts a new group of translations.  Save the
            # previous translation under the previous group name, then
            # extract the new one.
            if [[ -n "${group}" ]]; then
                dictionary[${group}]="${translation}"
            fi
            group="${line%:}"
            translation="?"
            is_continued=false
        else
            # The line uses a YAML feature not supported by the
            # Argparser, thus, output an error message.  The message
            # must not yet be translated, as the translation requires
            # translation identifiers that may not have been read, yet.
            # This would lead to a warning message complaining that the
            # identifier would be missing, despite being present.  For
            # the necessary interpolation, below, save the current line.
            error_message="Error: The YAML line \"\$1\" could not be "
            error_message+="recognized."
            error_messages+=("${error_message}")
            error_lines+=("${line}")
        fi
    done

    # Add the last group to the dictionary.
    if [[ -n "${group}" ]]; then
        dictionary[${group}]="${translation}"
    fi

    # Sort, filter, colorize, translate, and print all error messages.
    if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
        ARGPARSER_ARG_DELIMITER_2=","
        ARGPARSER_ERROR_EXIT_CODE=1
        ARGPARSER_ERROR_STYLE="red,bold,reverse"
    fi

    for i in "${!error_messages[@]}"; do
        error_message="${error_messages[i]}"
        line="${error_lines[i]}"
        argparser_translate "Error YAML" "${error_message}" "${line}"
        error_message="${translation}"
        error_messages[i]="${error_message}"
    done

    argparser_print_error_message true false "${error_messages[@]}"
}

function argparser_translate() {
    # Translate the given string.
    #
    # Arguments:
    # - $1: the key (identifier) of the string in the dictionary
    # - $2: the string to use as fallback if no translation file is
    #       given or the key does not exist
    # - $@: the variable names to use for interpolation of "$n" format
    #       specifiers in the string
    #
    # Nonlocals:
    # - dictionary: the associative array containing the translations
    # - translation: the translated string
    #
    # Environment:
    # - ARGPARSER_TRANSLATION_FILE (read-only)

    # Define the local variables.
    local i
    local key
    local string
    local var
    local -a vars

    # Read the arguments.
    key="$1"
    string="$2"
    shift 2
    vars=("$@")

    # If an ${ARGPARSER_TRANSLATION_FILE} was given (and thus the
    # translation was requested), translate the string by fetching its
    # translation from the associative array ${dictionary}.  Else,
    # output the untranslated string.  If the key or string does not
    # exist in ${dictionary}, output a warning message and the
    # untranslated string.  Translate the warning message only if the
    # key is not the one required for translation, else, an infinite
    # loop would arise by trying to fetch the inexistent translation
    # over and over.
    if [[ -n "${ARGPARSER_TRANSLATION_FILE}" ]]; then
        if ! argparser_in_array "${key}" "${!dictionary[@]}"; then
            warning_message="Warning: In the translation file \"\$1\", the "
            warning_message+="identifier \"\$2\" is missing.  For "
            warning_message+="convenience, the untranslated string is used, "
            warning_message+="instead."

            if [[ "${key}" == "Warning no identifier" ]]; then
                warning_message="${warning_message/"\$1"/${ARGPARSER_TRANSLATION_FILE}}"
                warning_message="${warning_message/"\$2"/${key}}"
            else
                argparser_translate "Warning no identifier" \
                    "${warning_message}" "${ARGPARSER_TRANSLATION_FILE}" \
                        "${key}"
                warning_message="${translation}"
            fi

            if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
                ARGPARSER_ARG_DELIMITER_2=","
                ARGPARSER_ERROR_EXIT_CODE=1
                ARGPARSER_ERROR_STYLE="red,bold,reverse"
            fi

            argparser_print_warning_message false "${warning_message}"
        elif [[ "${dictionary[${key}]}" == "?" ]]; then
            warning_message="Warning: In the translation file \"\$1\", the "
            warning_message+="translation to \"\$2\" for the identifier "
            warning_message+="\"\$3\" is missing.  For convenience, the "
            warning_message+="untranslated string is used, instead."

            if [[ "${key}" == "Warning no translation" ]]; then
                warning_message="${warning_message/"\$1"/${ARGPARSER_TRANSLATION_FILE}}"
                warning_message="${warning_message/"\$2"/${ARGPARSER_LANGUAGE}}"
                warning_message="${warning_message/"\$3"/${key}}"
            else
                argparser_translate "Warning no translation" \
                    "${warning_message}" "${ARGPARSER_TRANSLATION_FILE}" \
                    "${ARGPARSER_LANGUAGE}" "${key}"
                warning_message="${translation}"
            fi

            if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
                ARGPARSER_ARG_DELIMITER_2=","
                ARGPARSER_ERROR_EXIT_CODE=1
                ARGPARSER_ERROR_STYLE="red,bold,reverse"
            fi

            argparser_print_warning_message false "${warning_message}"
        else
            string="${dictionary[${key}]}"
        fi
    fi

    # Replace the format specifiers in the string and assign
    # ${translation} to it.
    for i in "${!vars[@]}"; do
        string="${string/"\$$(( i + 1 ))"/"${vars[i]}"}"
    done
    translation="${string}"
}

# Define the Argparser function for reading the styles.
function argparser_read_styles() {
    # Read the styles for the messages from the YAML file into an
    # associative array.
    #
    # Nonlocals:
    # - styles: the associative array containing the styles
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2
    # - ARGPARSER_CHECK_ENV_VARS
    # - ARGPARSER_ERROR_EXIT_CODE
    # - ARGPARSER_ERROR_STYLE
    # - ARGPARSER_STYLE_FILE (read-only)

    # Define the local variables.
    local error_message
    local -a error_messages
    local file_attributes
    local line
    local -a lines
    local name
    local style

    # Check if the style file exists and is readable.  Else, output an
    # error message and exit.  Since at this point of invokation, the
    # environment variables aren't checked, yet, set the needed ones to
    # default values, if ${ARGPARSER_CHECK_ENV_VARS} isn't set to
    # "false" (and by this, the checking hasn't been explicitly
    # disabled).
    argparser_check_file "${ARGPARSER_STYLE_FILE}"
    if [[ "${file_attributes}" != "0000" ]]; then
        error_message="Error: The environment variable \"\$1\" is set to "
        error_message+="\"\$2\", but the referenced file "
        case "${file_attributes}" in
            0001) error_message+="is empty." ;;
            0010) error_message+="is not readable." ;;
            0011) error_message+="is not readable and empty." ;;
            0100) error_message+="is not a regular file." ;;
            0101) error_message+="is not a regular file and empty." ;;
            0110) error_message+="is not a regular file and not readable." ;;
            0111)
                error_message+="is not a regular file, not readable, and "
                error_message+="empty."
                ;;
            1111) error_message+="does not exist." ;;
        esac

        argparser_translate "Error file" "${error_message}" \
            "ARGPARSER_STYLE_FILE" "${ARGPARSER_STYLE_FILE}"
        error_message="${translation}"

        if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
            ARGPARSER_ARG_DELIMITER_2=","
            ARGPARSER_ERROR_EXIT_CODE=1
            ARGPARSER_ERROR_STYLE="red,bold,reverse"
        fi

        argparser_print_error_message false true "${error_message}"
    fi

    # Read the style file.
    mapfile -t lines < "${ARGPARSER_STYLE_FILE}"
    error_messages=( )

    for line in "${lines[@]}"; do
        if [[ -z "${line}" || "${line}" == \#* ]]; then
            # Ignore the empty or commented line.
            continue
        elif [[ "${line}" =~ = ]]; then
            # Get the style name as shortest part before an equals sign
            # ("="), and strip leading and trailing spaces.  Then,
            # extract the style as longest part after the equals sign
            # and strip leading and trailing spaces and a double quote
            # each.
            name="${line%%=*}"
            argparser_trim "${name}"
            name="${trimmed_string}"

            style="${line#*=}"
            argparser_trim "${style}"
            style="${trimmed_string}"
            style="${style#\"}"
            style="${style%\"}"

            styles[${name}]="${style}"
        else
            # Output an error message when the line doesn't contain an
            # equals sign ("=").
            error_message="Error: In the style file \"\$1\", the line \"\$2\" "
            error_message+="doesn't contain an equals sign (\"=\"), nor is it "
            error_message+="empty or commented."

            argparser_translate "Error style file equals sign" \
                "${error_message}" "${ARGPARSER_STYLE_FILE}" "${line}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi
    done

    # Check if styles only have values supported by argparser_colorize.
    for name in "${!styles[@]}"; do
        style="${styles[${name}]}"
        if ! argparser_check_color_or_style "${style}"; then
            error_message="Error: The style \"\$1\" is set to \"\$2\", but "
            error_message+="the values must lie in {black, red, green, "
            error_message+="yellow, blue, magenta, cyan, white} for colors "
            error_message+="and in {normal, bold, faint, italic, underline, "
            error_message+="double, overline, crossed-out, blink, reverse} "
            error_message+="for styles."

            argparser_translate "Error style file styles" "${error_message}" \
                "${name}" "${style}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi
    done

    # Sort, filter, colorize, and print all error messages, then exit.
    if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
        ARGPARSER_ARG_DELIMITER_2=","
        ARGPARSER_ERROR_EXIT_CODE=1
        ARGPARSER_ERROR_STYLE="red,bold,reverse"
    fi

    argparser_print_error_message true true "${error_messages[@]}"
}

# Define the Argparser functions for creating, reading, parsing, and
# checking the arguments definition.
function argparser_create_args_definition() {
    # Create the arguments definition from user input and write it to a
    # file.

    # Define the local variables.
    local arg_group
    local arg_key
    local arg_number
    local -a args
    local -a args_definition
    local choice_values
    local -a col_arg_groups
    local -a col_arg_keys
    local -a col_arg_numbers
    local -a col_choice_values
    local -a col_default_values
    local -a col_help_texts
    local -a col_long_options
    local -a col_notes
    local -a col_short_options
    local -a col_types
    local -a col_value_names
    local default_values
    local delimiter
    local drop_arg_group
    local drop_arg_number
    local drop_choice_values
    local drop_default_values
    local drop_help_text
    local drop_long_options
    local drop_note
    local drop_short_options
    local drop_type
    local drop_value_names
    local file
    local help_text
    local i
    local joined_words
    local largest_col_width
    local line
    local long_options
    local message
    local note
    local -a padded_array
    local separator
    local shell
    local short_options
    local type
    local value_names

    # Set the horizontal separator.
    printf -v separator "%${ARGPARSER_MAX_WIDTH}s" ""
    separator="${separator// /-}"

    # Get the target shell from user input.
    message="Does your script use Bash (y) or only a POSIX-compliant shell "
    message+="(n)?"
    argparser_fold "${message}" "${ARGPARSER_MAX_WIDTH}" 0
    argparser_colorize "blue,bold" "${joined_words}" 1
    printf '\n\n'

    while read -r -p "Bash usage (y/n):  " shell 2>&1; do
        if [[ "${shell}" == "y" ]]; then
            shell="Bash"
            break
        elif [[ "${shell}" == "n" ]]; then
            shell="POSIX"
            break
        fi
        printf 'Please answer with "y" or "n".\n'
    done

    argparser_colorize "green,bold" "${separator}" 1
    printf '\n'

    # Get the target file from user input.
    message="Which file shall the arguments definition be written to?"
    argparser_fold "${message}" "${ARGPARSER_MAX_WIDTH}" 0
    argparser_colorize "blue,bold" "${joined_words}" 1
    printf '\n\n'

    read -r -p "Target file:  " file 2>&1

    argparser_colorize "green,bold" "${separator}" 1
    printf '\n'

    # Get the arguments definition delimiters from user input.
    message="Which character do you want to use as primary arguments "
    message+="definition delimiter?"
    argparser_fold "${message}" "${ARGPARSER_MAX_WIDTH}" 0
    argparser_colorize "blue,bold" "${joined_words}" 1
    printf '\n\n'

    read -r -p "Primary delimiter:  " delimiter 2>&1

    argparser_colorize "green,bold" "${separator}" 1
    printf '\n'

    # Get the arguments definition fields from user input.
    col_arg_keys=("id")
    col_short_options=("short_opts")
    col_long_options=("long_opts")
    col_value_names=("val_names")
    col_default_values=("defaults")
    col_choice_values=("choices")
    col_types=("type")
    col_arg_numbers=("arg_no")
    col_arg_groups=("arg_group")
    col_notes=("notes")
    col_help_texts=("help")

    message="Enter the fields for each argument.  Submit an empty argument "
    message+="identifier to end the input."
    argparser_fold "${message}" "${ARGPARSER_MAX_WIDTH}" 0
    argparser_colorize "blue,bold" "${joined_words}" 1
    printf '\n\n'

    while :; do
        read -r -p "Argument identifier:  " arg_key 2>&1
        if [[ -z "${arg_key}" ]]; then
            break
        fi

        {
            read -r -p "Short option names:   " short_options
            read -r -p "Long option names:    " long_options
            read -r -p "Value names:          " value_names
            read -r -p "Default values:       " default_values
            read -r -p "Choice values:        " choice_values
            read -r -p "Data type:            " type
            read -r -p "Argument number:      " arg_number
            read -r -p "Argument group:       " arg_group
            read -r -p "Notes:                " note
            read -r -p "Help text:            " help_text
        } 2>&1

        col_arg_keys+=("${arg_key}")
        col_short_options+=("${short_options}")
        col_long_options+=("${long_options}")
        col_value_names+=("${value_names}")
        col_default_values+=("${default_values}")
        col_choice_values+=("${choice_values}")
        col_types+=("${type}")
        col_arg_numbers+=("${arg_number}")
        col_arg_groups+=("${arg_group}")
        col_notes+=("${note}")
        col_help_texts+=("${help_text}")

        argparser_colorize "green,bold" "${separator}" 1
        printf '\n'
    done

    # Set each field in a column to the same width by right-padding with
    # spaces.
    argparser_pad "${col_arg_keys[@]}"
    col_arg_keys=("${padded_array[@]}")

    argparser_pad "${col_short_options[@]}"
    col_short_options=("${padded_array[@]}")

    argparser_pad "${col_long_options[@]}"
    col_long_options=("${padded_array[@]}")

    argparser_pad "${col_value_names[@]}"
    col_value_names=("${padded_array[@]}")

    argparser_pad "${col_default_values[@]}"
    col_default_values=("${padded_array[@]}")

    argparser_pad "${col_choice_values[@]}"
    col_choice_values=("${padded_array[@]}")

    argparser_pad "${col_types[@]}"
    col_types=("${padded_array[@]}")

    argparser_pad "${col_arg_numbers[@]}"
    col_arg_numbers=("${padded_array[@]}")

    argparser_pad "${col_arg_groups[@]}"
    col_arg_groups=("${padded_array[@]}")

    argparser_pad "${col_notes[@]}"
    col_notes=("${padded_array[@]}")

    argparser_pad "${col_help_texts[@]}"
    col_help_texts=("${padded_array[@]}")

    # Set flags for empty columns to be dropped.  Thereby, any column
    # but the argument identifier may be empty, i.e., all elements but
    # the header only consist of spaces, there.
    for short_options in in "${col_short_options[@]:1}"; do
        if [[ ! "${short_options}" =~ ^" "+$ ]]; then
            drop_short_options=false
            break
        fi
        drop_short_options=true
    done

    for long_options in in "${col_long_options[@]:1}"; do
        if [[ ! "${long_options}" =~ ^" "+$ ]]; then
            drop_long_options=false
            break
        fi
        drop_long_options=true
    done

    for value_names in in "${col_value_names[@]:1}"; do
        if [[ ! "${value_names}" =~ ^" "+$ ]]; then
            drop_value_names=false
            break
        fi
        drop_value_names=true
    done

    for default_values in in "${col_default_values[@]:1}"; do
        if [[ ! "${default_values}" =~ ^" "+$ ]]; then
            drop_default_values=false
            break
        fi
        drop_default_values=true
    done

    for choice_values in in "${col_choice_values[@]:1}"; do
        if [[ ! "${choice_values}" =~ ^" "+$ ]]; then
            drop_choice_values=false
            break
        fi
        drop_choice_values=true
    done

    for type in in "${col_types[@]:1}"; do
        if [[ ! "${type}" =~ ^" "+$ ]]; then
            drop_type=false
            break
        fi
        drop_type=true
    done

    for arg_number in in "${col_arg_numbers[@]:1}"; do
        if [[ ! "${arg_number}" =~ ^" "+$ ]]; then
            drop_arg_number=false
            break
        fi
        drop_arg_number=true
    done

    for arg_group in in "${col_arg_groups[@]:1}"; do
        if [[ ! "${arg_group}" =~ ^" "+$ ]]; then
            drop_arg_group=false
            break
        fi
        drop_arg_group=true
    done

    for note in in "${col_notes[@]:1}"; do
        if [[ ! "${note}" =~ ^" "+$ ]]; then
            drop_note=false
            break
        fi
        drop_note=true
    done

    for help_text in in "${col_help_texts[@]:1}"; do
        if [[ ! "${help_text}" =~ ^" "+$ ]]; then
            drop_help_text=false
            break
        fi
        drop_help_text=true
    done

    # Join the individual columns to the arguments definition table,
    # dropping the fields of empty columns.
    args=()
    for i in "${!col_arg_keys[@]}"; do
        # shellcheck disable=SC2190  # Indexed, not associative array.
        args+=("${col_arg_keys[i]}")

        if [[ "${drop_short_options}" == false ]]; then
            args[-1]+=" ${delimiter} ${col_short_options[i]}"
        fi

        if [[ "${drop_long_options}" == false ]]; then
            args[-1]+=" ${delimiter} ${col_long_options[i]}"
        fi

        if [[ "${drop_value_names}" == false ]]; then
            args[-1]+=" ${delimiter} ${col_value_names[i]}"
        fi

        if [[ "${drop_default_values}" == false ]]; then
            args[-1]+=" ${delimiter} ${col_default_values[i]}"
        fi

        if [[ "${drop_choice_values}" == false ]]; then
            args[-1]+=" ${delimiter} ${col_choice_values[i]}"
        fi

        if [[ "${drop_type}" == false ]]; then
            args[-1]+=" ${delimiter} ${col_types[i]}"
        fi

        if [[ "${drop_arg_number}" == false ]]; then
            args[-1]+=" ${delimiter} ${col_arg_numbers[i]}"
        fi

        if [[ "${drop_arg_group}" == false ]]; then
            args[-1]+=" ${delimiter} ${col_arg_groups[i]}"
        fi

        if [[ "${drop_note}" == false ]]; then
            args[-1]+=" ${delimiter} ${col_notes[i]}"
        fi

        if [[ "${drop_help_text}" == false ]]; then
            args[-1]+=" ${delimiter} ${col_help_texts[i]}"
        fi
    done

    # Output the arguments definition table either as Bash array or
    # POSIX multi-line string with subsequent help/usage/version flag
    # checking.  Possibly, precede the table with the needed environment
    # variables.
    args_definition=( )
    if [[ "${shell}" == "Bash" ]]; then
        if [[ "${delimiter}" != "${ARGPARSER_ARG_DELIMITER_1}" ]]; then
            args_definition+=("ARGPARSER_ARG_DELIMITER_1=\"${delimiter}\"")
        fi

        args_definition+=('args=(')

        for line in "${args[@]}"; do
            args_definition+=("    \"${line}\"")
        done

        args_definition+=(
            ')'
            'source argparser -- "$@"'
        )
    else
        # shellcheck disable=SC2016  # Intentional single-quoted expressions.
        args_definition+=(
            'export ARGPARSER_SCRIPT_NAME="${0##*/}"'
            'export ARGPARSER_WRITE_ARGS=true'
        )

        if [[ "${delimiter}" != "${ARGPARSER_ARG_DELIMITER_1}" ]]; then
            args_definition+=("export ARGPARSER_ARG_DELIMITER_1=\"${delimiter}\"")
        fi

        args_definition+=('args='\')

        for line in "${args[@]}"; do
            args_definition+=("    ${line}")
        done

        # shellcheck disable=SC1003  # Literal backslash before single quotes.
        # shellcheck disable=SC2016  # Intentional single-quoted expressions.
        args_definition+=(
            \'
            ''
            'if [ "$1" = "-h" ] || [ "$1" = "--help" ] \'
            '    || [ "$1" = "-u" ] || [ "$1" = "--usage" ] \'
            '    || [ "$1" = "-V" ] || [ "$1" = "--version" ]'
            'then'
            '    printf '\''%s'\'' "${args}" | argparser -- "$@"'
            'else'
            '    eval "$(printf '\''%s'\'' "${args}" | argparser -- "$@" | tee /dev/stderr)"'
            'fi'
        )
    fi

    printf '%s\n' "${args_definition[@]}" > "${file}"
}

function argparser_read_args_definition() {
    # Read the arguments definition from the script and arguments
    # definition file, if provided.
    #
    # Arguments:
    # - $@: the arguments known to the script
    #
    # Nonlocals:
    # - messages: the read arguments definition as message or an error
    #   message, starting with "File: ", "Script: ", or "Error: "
    #   (translated), as indexed array
    #
    # Environment:
    # - ARGPARSER_ARG_DEF_FILE (read-only)
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)

    # Define the local variables.
    local arg
    local arg_key
    local -a args
    local error_message
    local header
    local line
    local lines
    local translation
    local trimmed_string

    # Read the arguments.
    # shellcheck disable=SC2190  # Indexed, not associative array.
    args=("$@")

    # Read and output the header for a possible arguments definition in
    # the script.
    header="${args[0]}"
    messages+=("Script: ${header}")

    # If ${ARGPARSER_ARG_DEF_FILE} isn't set to the empty string, read
    # the arguments definition file and output the header.
    if [[ -n "${ARGPARSER_ARG_DEF_FILE}" ]]; then
        mapfile -t lines < "${ARGPARSER_ARG_DEF_FILE}"
        header="${lines[0]}"
        messages+=("File: ${header}")
    fi

    # Get the definition for each argument (excluding the header as
    # zeroth element in ${args}).  These arguments may either be defined
    # in the script, where they're given in the columnar Argparser
    # syntax, or in a separate arguments definition file, so they're
    # only given as their key.  If the structure differs, and no header
    # is given (so columns may be omitted), output an error message.
    for arg in "${args[@]:1}"; do
        if [[ "${arg}" != *"${ARGPARSER_ARG_DELIMITER_1}"* \
            && -n "${ARGPARSER_ARG_DEF_FILE}" ]]
        then
            # The argument contains no ${ARGPARSER_ARG_DELIMITER_1} and
            # thus only the key, and an arguments definition file is
            # given. Iterate over all arguments definition lines from
            # the file.  When the argument key in one line matches the
            # given key, output the key and definition, then continue
            # the outer loop (with index 2).  If the inner loop doesn't
            # get aborted by the continuation, it means that no fitting
            # argument definition has been found.  Thus, output an error
            # message.
            for line in "${lines[@]:1}"; do
                arg_key="${line%%"${ARGPARSER_ARG_DELIMITER_1}"*}"
                argparser_trim "${arg_key}"
                arg_key="${trimmed_string}"

                if [[ "${arg_key}" == "${arg}" ]]; then
                    messages+=("File: ${line}")
                    continue 2
                fi
            done
            error_message="Error: No argument definition for \"\$1\"."
            argparser_translate "Error no arg def" "${error_message}" "${arg}"
            error_message="${translation}"
            messages+=("${error_message}")
        else
            # The argument contains an ${ARGPARSER_ARG_DELIMITER_1} and
            # thus potentially an entire definition.  Output this.
            messages+=("Script: ${arg}")
        fi
    done
}

function argparser_parse_args_definition() {
    # Parse the arguments definition into an associative array per CSV
    # column.
    #
    # Arguments:
    # - $1: the origin of the arguments definition ("script" or "file")
    # - $@: the indexed array holding the arguments definition, the
    #       first line of which being the header
    #
    # Nonlocals:
    # - all_arg_groups: the associative array holding the argument
    #   groups
    # - all_arg_numbers: the associative array holding the argument
    #   numbers
    # - all_choice_values: the associative array holding the choice
    #   values
    # - all_default_values: the associative array holding the default
    #   values
    # - all_help_texts: the associative array holding the help texts
    # - all_long_options: the associative array holding the long option
    #   names
    # - all_notes: the associative array holding the notes
    # - all_positional_args: the indexed array holding the positional
    #   argument names
    # - all_short_options: the associative array holding the short
    #   option names
    # - all_types: the associative array holding the argument types
    # - all_value_names: the associative array holding the value names
    #
    # Environment:
    # - ARGPARSER_ARG_DEF_FILE (read-only)
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_POSITIONAL_ARG_GROUP (read-only)
    # - ARGPARSER_SCRIPT_NAME (read-only)

    # Define the local variables.
    local arg_group
    local arg_key
    local arg_number
    local -a args_definition
    local choice_value
    local -a choice_values
    local -a choice_values_arr
    local choice_values_range
    local choice_values_str
    local column_index
    local -A column_indices
    local default_values
    local definition_type
    local error_message
    local -a error_messages
    local field
    local -a fields
    local -a header
    local help_text
    local i
    local joined_array
    local -a line
    local long_options
    local notes
    local range_start
    local range_step
    local range_stop
    local sequence
    local short_options
    local translation
    local trimmed_string
    local type
    local value_names

    # Read the arguments.
    definition_type="$1"
    shift
    args_definition=("$@")

    # Read the first line (the header) of ${args_definition} to get the
    # column indices for the fields.  Strip leading and trailing spaces.
    IFS="${ARGPARSER_ARG_DELIMITER_1}" read -r -a header \
        <<< "${args_definition[0]}"
    for column_index in "${!header[@]}"; do
        argparser_trim "${header[column_index]}"
        header[column_index]="${trimmed_string}"
    done

    # Get the column indices of all fields.
    column_indices=(
        [id]=""
        [short_opts]=""
        [long_opts]=""
        [val_names]=""
        [defaults]=""
        [choices]=""
        [type]=""
        [arg_no]=""
        [arg_group]=""
        [notes]=""
        [help]=""
    )

    for field in "${!column_indices[@]}"; do
        for column_index in "${!header[@]}"; do
            if [[ "${header[column_index]}" == "${field}" ]]; then
                column_indices[${field}]="${column_index}"
            fi
        done
    done

    # If the column with the argument identifiers isn't given, output an
    # error message.
    error_messages=( )
    if [[ -z "${column_indices[id]}" ]]; then
        if [[ "${definition_type}" == "script" ]]; then
            error_message="Error: In the arguments definition in \"\$1\", "
            error_message+="the column \"id\" is missing."

            argparser_translate "Error arg def id" "${error_message}" \
                "${ARGPARSER_SCRIPT_NAME}"
            error_message="${translation}"
        else
            error_message="Error: In the arguments definition file "
            error_message+="\"\$1\", the column \"\$2\" is missing."

            argparser_translate "Error arg def file id" \
                "${error_message}" "${ARGPARSER_ARG_DEF_FILE}"
            error_message="${translation}"
        fi
        error_messages+=("${error_message}")
    fi

    # If there are error messages, sort, colorize, and print them, then
    # exit.
    argparser_print_error_message false true "${error_messages[@]}"

    # Read all lines of the arguments definition and save the fields in
    # an associative array per column, using the argument identifier as
    # key and the definition in the field (or a default value) as value.
    # If neither a short nor a long option name is given, interpret the
    # argument as positional and add it to the respective indexed array.
    # If only short or long option names shall be accepted, set the
    # respective other value to the empty string, indicating absence of
    # an option name.  Skip arguments that have no short or long option
    # name, if only the other one is accepted, since these can never be
    # given.
    for line in "${args_definition[@]:1}"; do
        IFS="${ARGPARSER_ARG_DELIMITER_1}" read -r -a fields <<< "${line}"

        # If the line has more or less columns than the header, output
        # an error message.
        if [[ "${#fields[@]}" != "${#header[@]}" ]]; then
            if [[ "${definition_type}" == "script" ]]; then
                error_message="Error: In the arguments definition in \"\$1\", "
                error_message+="the field count of the line \"\$2\" (\$3) "
                error_message+="doesn't match the header's field count (\$4)."

                argparser_translate "Error arg def field count" \
                    "${error_message}" "${ARGPARSER_SCRIPT_NAME}" "${line}" \
                    "${#fields[@]}" "${#header[@]}"
                error_message="${translation}"
            else
                error_message="Error: In the arguments definition file "
                error_message+="\"\$1\", the field count of the line \"\$2\" "
                error_message+="(\$3) doesn't match the header's field count "
                error_message+="(\$4)."

                argparser_translate "Error arg def file field count" \
                    "${error_message}" "${ARGPARSER_ARG_DEF_FILE}" "${line}" \
                    "${#fields[@]}" "${#header[@]}"
                error_message="${translation}"
            fi
            error_messages+=("${error_message}")
        fi

        # Get the argument identifier.
        argparser_trim "${fields[${column_indices["id"]}]}"
        arg_key="${trimmed_string}"

        # Get the short option names.
        if [[ -n "${column_indices["short_opts"]}" ]]; then
            argparser_trim "${fields[${column_indices["short_opts"]}]}"
            short_options="${trimmed_string}"
        else
            short_options=""
        fi

        # Get the long option names.
        if [[ -n "${column_indices["long_opts"]}" ]]; then
            argparser_trim "${fields[${column_indices["long_opts"]}]}"
            long_options="${trimmed_string}"
        else
            long_options=""
        fi

        # Save the option names.
        if [[ -z "${short_options}" && -z "${long_options}" ]]; then
            all_positional_args+=("${arg_key}")
        elif [[ "${ARGPARSER_USE_LONG_OPTIONS}" == true \
            && "${ARGPARSER_USE_SHORT_OPTIONS}" == true ]]
        then
            all_short_options[${arg_key}]="${short_options}"
            all_long_options[${arg_key}]="${long_options}"
        elif [[ -n "${short_options}" \
            && "${ARGPARSER_USE_SHORT_OPTIONS}" == true ]]
        then
            all_short_options[${arg_key}]="${short_options}"
            all_long_options[${arg_key}]=""
        elif [[ -n "${long_options}" \
            && "${ARGPARSER_USE_LONG_OPTIONS}" == true ]]
        then
            all_short_options[${arg_key}]=""
            all_long_options[${arg_key}]="${long_options}"
        else
            continue
        fi

        # Get the value names.
        if [[ -n "${column_indices["val_names"]}" ]]; then
            argparser_trim "${fields[${column_indices["val_names"]}]}"
            value_names="${trimmed_string}"
        else
            value_names=""
        fi
        all_value_names[${arg_key}]="${value_names}"

        # Get the default values.
        if [[ -n "${column_indices["defaults"]}" ]]; then
            argparser_trim "${fields[${column_indices["defaults"]}]}"
            default_values="${trimmed_string}"
        else
            default_values=""
        fi
        all_default_values[${arg_key}]="${default_values}"

        # Get the choice values.  Resolve ranges in the individual
        # elements.
        if [[ -n "${column_indices["choices"]}" ]]; then
            argparser_trim "${fields[${column_indices["choices"]}]}"
            choice_values_str="${trimmed_string}"

            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values_arr \
                <<< "${choice_values_str}"
            choice_values=( )
            for choice_values_range in "${choice_values_arr[@]}"; do
                if [[ "${choice_values_range}" == *-*-*-* ]]; then
                    error_message="Error: The argument with the identifier "
                    error_message+="\"\$1\" has more hyphens in the choice "
                    error_message+="values given than supported (2)."

                    argparser_translate "Error arg def choice range hyphens" \
                        "${error_message}" "${arg_key}"
                    error_messages+=("${error_message}")
                elif [[ "${choice_values_range}" == *-*-* ]]; then
                    range_start="${choice_values_range%%-*}"
                    range_stop="${choice_values_range#*-}"
                    range_step="${range_stop#*-}"
                    range_stop="${range_stop%%-*}"

                    argparser_seq "${arg_key}" "${range_start}" \
                        "${range_stop}" "${range_step}"

                    for choice_value in "${sequence[@]}"; do
                        choice_values+=("${choice_value}")
                    done
                elif [[ "${choice_values_range}" == *-* ]]; then
                    range_start="${choice_values_range%%-*}"
                    range_stop="${choice_values_range#*-}"

                    argparser_seq "${arg_key}" "${range_start}" "${range_stop}"

                    for choice_value in "${sequence[@]}"; do
                        choice_values+=("${choice_value}")
                    done
                else
                    choice_values+=("${choice_values_range}")
                fi
            done
        else
            choice_values=( )
        fi

        argparser_join false "" "" "${choice_values[@]}"
        all_choice_values[${arg_key}]="${joined_array}"

        # Get the data type.
        if [[ -n "${column_indices["type"]}" ]]; then
            argparser_trim "${fields[${column_indices["type"]}]}"
            type="${trimmed_string}"
        else
            type="str"
        fi
        all_types[${arg_key}]="${type}"

        # Get the argument number.
        if [[ -n "${column_indices["arg_no"]}" ]]; then
            argparser_trim "${fields[${column_indices["arg_no"]}]}"
            arg_number="${trimmed_string}"
        else
            arg_number=1
        fi
        all_arg_numbers[${arg_key}]="${arg_number}"

        # Get the argument group.
        if [[ -n "${column_indices["arg_group"]}" ]]; then
            argparser_trim "${fields[${column_indices["arg_group"]}]}"
            arg_group="${trimmed_string}"
        else
            arg_group="${ARGPARSER_POSITIONAL_ARG_GROUP}"
        fi
        all_arg_groups[${arg_key}]="${arg_group}"

        # Get the notes.
        if [[ -n "${column_indices["notes"]}" ]]; then
            argparser_trim "${fields[${column_indices["notes"]}]}"
            notes="${trimmed_string}"
        else
            notes=""
        fi
        all_notes[${arg_key}]="${notes}"

        # Get the help text.
        if [[ -n "${column_indices["help"]}" ]]; then
            argparser_trim "${fields[${column_indices["help"]}]}"
            help_text="${trimmed_string}"
        else
            help_text=""
        fi
        all_help_texts[${arg_key}]="${help_text}"
    done

    # If there are error messages, sort, colorize, and print them, then
    # exit.
    argparser_print_error_message false true "${error_messages[@]}"
}

function argparser_check_args_definition_names() {
    # Check if the script's arguments' definition is consistent
    # regarding the short and long option names.  This should always be
    # true for production scripts, but maybe not while testing.
    #
    # Nonlocals:
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - error_messages: the error messages, starting with "Error: "
    #   (translated), as indexed array
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_HELP_OPTIONS (read-only)
    # - ARGPARSER_USAGE_OPTIONS (read-only)
    # - ARGPARSER_USE_LONG_OPTIONS (read-only)
    # - ARGPARSER_USE_SHORT_OPTIONS (read-only)
    # - ARGPARSER_VERSION_OPTIONS (read-only)

    # Define the local variables.
    local arg_key
    local -a arg_keys
    local count
    local -A checked_long_options
    local -A checked_short_options
    local error_message
    local -a help_options
    local long_option
    local -a long_options
    local short_option
    local -a short_options
    local -a sorted_array
    local translation
    local -a usage_options
    local -a version_options

    # Read the short help, usage, and version option names.
    IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a help_options \
        <<< "${ARGPARSER_HELP_OPTIONS}"
    IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a usage_options \
        <<< "${ARGPARSER_USAGE_OPTIONS}"
    IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a version_options \
        <<< "${ARGPARSER_VERSION_OPTIONS}"

    # Get and sort all argument keys (identifiers), such that the
    # following loop is performed in alphabetical order of the
    # arguments, such that the error messages for duplicate option names
    # refer to the lexicographically earlier argument.
    argparser_sort false "${!all_short_options[@]}"
    arg_keys=("${sorted_array[@]}")

    # Check that no short or long option is given twice for the same
    # argument or among multiples.
    for arg_key in "${arg_keys[@]}"; do
        # Read the argument's definition.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
            <<< "${all_short_options[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
            <<< "${all_long_options[${arg_key}]}"

        # If more than one short option name is given, check if any is
        # the empty string, which must only once be used as placeholder
        # for missing short options.  Then, check if any short option
        # name is longer than one character, and if it is given multiple
        # times in the current argument's definition or across all yet
        # investigated arguments' definitions.  If only one short option
        # name is given, the empty string is a legit value, so don't
        # check this.
        if (( "${#short_options[@]}" > 1 )) \
            && argparser_in_array "" "${short_options[@]}"
        then
            # Check if the empty string is included in the short option
            # names.
            error_message="Error: The short option with the identifier "
            error_message+="\"\$1\" has an empty string given as one of the "
            error_message+="\$2 short option names, instead of a legit name."

            argparser_translate "Error arg def short name empty" \
                "${error_message}" "${arg_key}" "${#short_options[@]}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi

        for short_option in "${short_options[@]}"; do
            if [[ "${ARGPARSER_ADD_HELP}" == true \
                && "${ARGPARSER_USE_SHORT_OPTIONS}" == true ]] \
                && argparser_in_array "${short_option}" "${help_options[@]}"
            then
                # Check if a short option name uses the reserved flag
                # for the help message.
                error_message="Error: The short option with the identifier "
                error_message+="\"\$1\" has the short option \"-\$2\" "
                error_message+="defined, which is reserved for invoking the "
                error_message+="help message."

                argparser_translate "Error arg def short name help" \
                    "${error_message}" "${arg_key}" "${short_option}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${ARGPARSER_ADD_USAGE}" == true \
                && "${ARGPARSER_USE_SHORT_OPTIONS}" == true ]] \
                && argparser_in_array "${short_option}" "${usage_options[@]}"
            then
                # Check if a short option name uses the reserved flag
                # for the usage message.
                error_message="Error: The short option with the identifier "
                error_message+="\"\$1\" has the short option \"-\$2\" "
                error_message+="defined, which is reserved for invoking the "
                error_message+="usage message."

                argparser_translate "Error arg def short name usage" \
                    "${error_message}" "${arg_key}" "${short_option}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${ARGPARSER_ADD_VERSION}" == true \
                && "${ARGPARSER_USE_SHORT_OPTIONS}" == true ]] \
                && argparser_in_array "${short_option}" "${version_options[@]}"
            then
                # Check if a short option name uses the reserved flag
                # for the version message.
                error_message="Error: The short option with the identifier "
                error_message+="\"\$1\" has the short option \"-\$2\" "
                error_message+="defined, which is reserved for invoking the "
                error_message+="version message."

                argparser_translate "Error arg def short name version" \
                    "${error_message}" "${arg_key}" "${short_option}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ -n "${short_option}" ]]; then
                # Check if a short option name is more than one
                # character long.
                if (( "${#short_option}" > 1 )); then
                    error_message="Error: The short option with the "
                    error_message+="identifier \"\$1\" has the short option "
                    error_message+="\"-\$2\" defined with more than 1 "
                    error_message+="character length."

                    argparser_translate "Error arg def short name length" \
                        "${error_message}" "${arg_key}" "${short_option}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi

                # Check if the short option name is given multiple times
                # in the current argument's definition.
                argparser_count "${short_option}" "${short_options[@]}"
                if (( count > 1 )); then
                    error_message="Error: The short option with the "
                    error_message+="identifier \"\$1\" has the short option "
                    error_message+="\"-\$2\" given \$3 times."

                    argparser_translate \
                        "Error arg def short name duplication 1" \
                        "${error_message}" "${arg_key}" "${short_option}" \
                        "${count}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi

                # Check if the short option name is already given in
                # another argument's definition.
                if argparser_in_array "${short_option}" \
                    "${!checked_short_options[@]}" \
                    && [[ "${checked_short_options[${short_option}]}" \
                        != "${arg_key}" ]]
                then
                    error_message="Error: The short option with the "
                    error_message+="identifier \"\$1\" has the short option "
                    error_message+="\"-\$2\" given, but that is already in "
                    error_message+="use by \"\$3\"."

                    argparser_translate \
                        "Error arg def short name duplication 2" \
                        "${error_message}" "${arg_key}" "${short_option}" \
                        "${checked_short_options[${short_option}]}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi

                # Add the short option name to the associative array of
                # all short option names.
                checked_short_options[${short_option}]="${arg_key}"
            fi
        done

        # Perform the same tests for the long option names for having
        # the empty string among the long option names or if any long
        # option name is shorter than two characters, and if it is given
        # multiple times in the current argument's definition or across
        # all yet investigated arguments' definitions.
        if (( "${#long_options[@]}" > 1 )) \
            && argparser_in_array "" "${long_options[@]}"
        then
            # Check if the empty string is included in the long option
            # names.
            error_message="Error: The long option with the identifier \"\$1\" "
            error_message+="has an empty string given as one of the \$2 long "
            error_message+="option names, instead of a legit name."

            argparser_translate "Error arg def long name empty" \
                "${error_message}" "${arg_key}" "${#long_options[@]}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi

        for long_option in "${long_options[@]}"; do
            if [[ "${ARGPARSER_ADD_HELP}" == true \
                && "${ARGPARSER_USE_LONG_OPTIONS}" == true \
                && "${long_option}" == "help" ]]
            then
                # Check if a long option name uses the reserved flag for
                # the help message.
                error_message="Error: The long option with the identifier "
                error_message+="\"\$1\" has the long option \"--help\" "
                error_message+="defined, which is reserved for invoking the "
                error_message+="help message."

                argparser_translate "Error arg def long name help" \
                    "${error_message}" "${arg_key}" "${long_option}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${ARGPARSER_ADD_USAGE}" == true \
                && "${ARGPARSER_USE_LONG_OPTIONS}" == true \
                && "${long_option}" == "usage" ]]
            then
                # Check if a long option name uses the reserved flag for
                # the usage message.
                error_message="Error: The long option with the identifier "
                error_message+="\"\$1\" has the long option \"--usage\" "
                error_message+="defined, which is reserved for invoking the "
                error_message+="usage message."

                argparser_translate "Error arg def long name usage" \
                    "${error_message}" "${arg_key}" "${long_option}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${ARGPARSER_ADD_VERSION}" == true \
                && "${ARGPARSER_USE_LONG_OPTIONS}" == true \
                && "${long_option}" == "version" ]]
            then
                # Check if a long option name uses the reserved flag for
                # the version message.
                error_message="Error: The long option with the identifier "
                error_message+="\"\$1\" has the long option \"--version\" "
                error_message+="defined, which is reserved for invoking the "
                error_message+="version message."

                argparser_translate "Error arg def long name version" \
                    "${error_message}" "${arg_key}" "${long_option}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ -n "${long_option}" ]]; then
                # Check if a long option name is less than two
                # characters long.
                if (( "${#long_option}" < 2 )); then
                    error_message="Error: The long option with the identifier "
                    error_message+="\"\$1\" has the long option \"--\$2\" "
                    error_message+="defined with less than 2 characters "
                    error_message+="length."

                    argparser_translate "Error arg def long name length" \
                        "${error_message}" "${arg_key}" "${long_option}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi

                # Check if the long option name is given multiple times
                # in the current argument's definition.
                argparser_count "${long_option}" "${long_options[@]}"
                if (( count > 1 )); then
                    error_message="Error: The long option with the identifier "
                    error_message+="\"\$1\" has the long option \"--\$2\" "
                    error_message+="given \$3 times."

                    argparser_translate \
                        "Error arg def long name duplication 1" \
                        "${error_message}" "${arg_key}" "${long_option}" \
                        "${count}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi

                # Check if the long option name is already given in
                # another argument's definition.
                if argparser_in_array "${long_option}" \
                    "${!checked_long_options[@]}" \
                    && [[ "${checked_long_options[${long_option}]}" \
                        != "${arg_key}" ]]
                then
                    error_message="Error: The long option with the identifier "
                    error_message+="\"\$1\" has the long option \"--\$2\" "
                    error_message+="given, but that is already in use by "
                    error_message+="\"\$3\"."

                    argparser_translate \
                        "Error arg def long name duplication 2" \
                        "${error_message}" "${arg_key}" "${long_option}" \
                        "${checked_long_options[${long_option}]}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi

                # Add the long option name to the associative array of
                # all long option names.
                checked_long_options[${long_option}]="${arg_key}"
            fi
        done
    done
}

function argparser_check_args_definition_positional_values() {
    # Check if the script's arguments' definition is consistent
    # regarding the default and choice values, as well as the number of
    # arguments for positional arguments.  This should always be true
    # for production scripts, but maybe not while testing.
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_choice_values: the associative array holding the choice
    #   values (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_notes: the associative array holding the notes (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    # - all_types: the associative array holding the argument types
    #   (read-only)
    # - error_messages: the error messages, starting with "Error: "
    #   (translated), as indexed array
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)

    # Define the local variables.
    local arg_key
    local arg_number
    local choice_value
    local -a choice_values_arr
    local choice_values_str
    local default_value
    local -a default_values_arr
    local default_values_str
    local error_message
    local infinite_arg_number_arg
    local joined_array
    local note
    local -a notes
    local optional_arg
    local translation
    local type

    # Check the consistency of all positional arguments.
    infinite_arg_number_arg=""
    optional_arg=""
    for arg_key in "${all_positional_args[@]}"; do
        # Read the argument's definition.
        default_values_str="${all_default_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a default_values_arr \
            <<< "${default_values_str}"
        choice_values_str="${all_choice_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values_arr \
            <<< "${choice_values_str}"
        type="${all_types[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a notes \
            <<< "${all_notes[${arg_key}]}"

        # Check if the default value for arguments that can be used as
        # flags, if given, is either "true" or "false".
        if argparser_in_array "${arg_number}" "*" "?" \
            && [[ -n "${default_values_str}" ]] \
            && ! argparser_in_array "${default_values_str}" true false
        then
            error_message="Error: The positional argument with the identifier "
            error_message+="\"\$1\" must be \"true\" or \"false\", but has "
            error_message+="{\$2} given as default."

            argparser_translate "Error arg def pos default flag" \
                "${error_message}" "${arg_key}" "${default_values_str}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi

        # Check if the number of default values equals the number of
        # required values.  Else, output an error message.
        if ! argparser_in_array "${arg_number}" "+" "*" "?" \
            && [[ -n "${default_values_str}" \
            && "${#default_values_arr[@]}" != "${arg_number}" ]]
        then
            if [[ "${arg_number}" == 1 ]]; then
                error_message="Error: The positional argument with the "
                error_message+="identifier \"\$1\" requires 1 value, but has "
                error_message+="\$2 given as default."

                argparser_translate "Error arg def pos default 1" \
                    "${error_message}" "${arg_key}" "${#default_values_arr[@]}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            else
                error_message="Error: The positional argument with the "
                error_message+="identifier \"\$1\" requires \$2 values, but "
                error_message+="has \$3 given as default."

                argparser_translate "Error arg def pos default 2" \
                    "${error_message}" "${arg_key}" "${arg_number}" \
                    "${#default_values_arr[@]}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        fi

        # Check if the default values accord to the choice values, i.e.,
        # if each default value lies within the array of choice values.
        # Else, output an error message.
        if [[ -n "${choice_values_str}" ]]; then
            # Check that "true" and "false" aren't choice values.
            for choice_value in "${choice_values_arr[@]}"; do
                if [[ "${choice_value}" == true \
                    || "${choice_value}" == false ]]
                then
                    error_message="Error: The positional argument with the "
                    error_message+="identifier \"\$1\" has {\$2} given as "
                    error_message+="choice values, while \"true\" and "
                    error_message+="\"false\" cannot be any."

                    argparser_translate "Error arg def pos choice true" \
                        "${error_message}" "${arg_key}" "${choice_values_str}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                    break
                fi
            done

            # Check the default values, separately for flag-like and
            # "normal" arguments.
            for default_value in "${default_values_arr[@]}"; do
                if [[ -z "${default_value}" ]]; then
                    continue
                fi

                if argparser_in_array "${arg_number}" "*" "?"; then
                    if ! argparser_in_array "${default_value}" \
                        "${choice_values_arr[@]}" true false
                    then
                        error_message="Error: The positional argument with "
                        error_message+="the identifier \"\$1\" accepts only "
                        error_message+="the choice values {\$2}, but has "
                        error_message+="{\$3} given as default."

                        argparser_translate \
                            "Error arg def pos choice default" \
                            "${error_message}" "${arg_key}" \
                            "${choice_values_str}" "${default_values_str}"
                        error_message="${translation}"
                        error_messages+=("${error_message}")
                        break
                    fi
                else
                    if ! argparser_in_array "${default_value}" \
                        "${choice_values_arr[@]}"
                    then
                        error_message="Error: The positional argument with "
                        error_message+="the identifier \"\$1\" accepts only "
                        error_message+="the choice values {\$2}, but has "
                        error_message+="{\$3} given as default."

                        argparser_translate \
                            "Error arg def pos choice default" \
                            "${error_message}" "${arg_key}" \
                            "${choice_values_str}" "${default_values_str}"
                        error_message="${translation}"
                        error_messages+=("${error_message}")
                        break
                    fi
                fi
            done
        fi

        # Check the number of arguments with default values.
        if [[ -n "${default_values_str}" ]]; then
            # Check that no two positional arguments are optional, which
            # would be impossible to parse.
            if [[ -n "${optional_arg}" ]]; then
                error_message="Error: The positional argument with the "
                error_message+="identifier \"\$1\" is optional, as is "
                error_message+="\"\$2\", which renders parsing impossible."

                argparser_translate "Error arg def pos optionals" \
                    "${error_message}" "${arg_key}" "${optional_arg}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            else
                optional_arg="${arg_key}"
            fi

            # Likewise, check that there is no positional argument
            # accepting an infinite number of values along the optional
            # one, which would also be impossible to parse.
            if [[ -n "${infinite_arg_number_arg}" ]]; then
                error_message="Error: The positional argument with the "
                error_message+="identifier \"\$1\" is optional, while \"\$2\" "
                error_message+="accepts an infinite number of values, which "
                error_message+="renders parsing impossible."

                argparser_translate "Error arg def pos optional infinite" \
                    "${error_message}" "${arg_key}" \
                    "${infinite_arg_number_arg}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        fi

        # Check the number of arguments.
        if [[ "${arg_number}" == 0 ]]; then
            # Since positional arguments can't be flags, output an error
            # message.
            error_message="Error: The positional argument with the identifier "
            error_message+="\"\$1\" accepts 0 arguments and thus can never be "
            error_message+="given on the command line."

            argparser_translate "Error arg def pos flag" "${error_message}" \
                "${arg_key}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        elif [[ "${arg_number}" == "+" || "${arg_number}" == "*" ]]; then
            # Check that no two positional arguments accept an infinite
            # number of values, which would be impossible to parse.
            if [[ -n "${infinite_arg_number_arg}" ]]; then
                error_message="Error: The positional argument with the "
                error_message+="identifier \"\$1\" accepts an infinite number "
                error_message+="of values, as does \"\$2\", which renders "
                error_message+="parsing impossible."

                argparser_translate "Error arg def pos infinites" \
                    "${error_message}" "${arg_key}" \
                    "${infinite_arg_number_arg}"
                error_messages+=("${error_message}")
            else
                infinite_arg_number_arg="${arg_key}"
            fi

            # Likewise, check that there is no optional positional
            # argument along the one accepting an infinite number of
            # values, which would also be impossible to parse.
            if [[ -n "${optional_arg}" ]]; then
                if [[ "${optional_arg}" == "${arg_key}" ]]; then
                    # The argument being both optional and accepting an
                    # infinite number of values is the same (the current
                    # one), which is not supported.
                    error_message="Error: The positional argument with the "
                    error_message+="identifier \"\$1\" accepts an infinite "
                    error_message+="number of values, while being optional, "
                    error_message+="which is not supported."

                    argparser_translate \
                        "Error arg def pos infinite optional 1" \
                        "${error_message}" "${arg_key}"
                    error_message="${translation}"
                else
                    # Both arguments are different, which is impossible
                    # to parse.
                    error_message="Error: The positional argument with the "
                    error_message+="identifier \"\$1\" accepts an infinite "
                    error_message+="number of values, while \"\$2\" is "
                    error_message+="optional, which renders parsing "
                    error_message+="impossible."

                    argparser_translate \
                        "Error arg def pos infinite optional 2" \
                        "${error_message}" "${arg_key}" "${optional_arg}"
                    error_message="${translation}"
                fi
                error_messages+=("${error_message}")
            fi
        fi

        # Check the data type.
        if ! argparser_in_array "${type}" "bool" "char" "float" "file" "int" \
            "str" "uint"
        then
            error_message="Error: The positional argument with the identifier "
            error_message+="\"\$1\" has \"\$2\" given as data type, but only "
            error_message+="\"bool\", \"char\", \"float\", \"file\", \"int\", "
            error_message+="\"str\", and \"uint\" are supported."

            argparser_translate "Error arg def pos type" "${error_message}" \
                "${arg_key}" "${type}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi

        # Check if the choice values accord to the type.
        for choice_value in "${choice_values_arr[@]}"; do
            if [[ -z "${choice_value}" ]]; then
                # No choice value is given, so abort the loop.
                break
            fi

            if [[ "${type}" == "bool" ]] \
                && ! argparser_is_bool "${choice_value}"
            then
                # Check if the choice value is a Boolean.
                error_message="Error: The positional argument with the "
                error_message+="identifier \"\$1\" has \"\$2\" given as "
                error_message+="choice value, which must be a Boolean, i.e., "
                error_message+="\"true\" or \"false\"."

                argparser_translate "Error arg def pos bool" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${type}" == "char" ]] \
                && ! argparser_is_char "${choice_value}"
            then
                # Check if the choice value is a character.
                error_message="Error: The positional argument with the "
                error_message+="identifier \"\$1\" has \"\$2\" given as "
                error_message+="choice value, which must be a character, "
                error_message+="i.e., a string comprising one printable ASCII "
                error_message+="character."

                argparser_translate "Error arg def pos char" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${type}" == "float" ]] \
                && ! argparser_is_float "${choice_value}"
            then
                # Check if the choice value is a floating-point number.
                error_message="Error: The positional argument with the "
                error_message+="identifier \"\$1\" has \"\$2\" given as "
                error_message+="choice value, which must be a floating-point "
                error_message+="number, i.e., comprise only digits, a dot, "
                error_message+="and possibly a leading sign."

                argparser_translate "Error arg def pos float" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${type}" == "int" ]] \
                && ! argparser_is_int "${choice_value}"
            then
                # Check if the choice value is an integer.
                error_message="Error: The positional argument with the "
                error_message+="identifier \"\$1\" has \"\$2\" given as "
                error_message+="choice value, which must be an integer, i.e., "
                error_message+="comprise only digits and possibly a leading "
                error_message+="sign."

                argparser_translate "Error arg def pos int" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${type}" == "uint" ]] \
                && ! argparser_is_uint "${choice_value}"
            then
                # Check if the choice value is an unsigned integer.
                error_message="Error: The positional argument with the "
                error_message+="identifier \"\$1\" has \"\$2\" given as "
                error_message+="choice value, which must be an unsigned "
                error_message+="integer, i.e., comprise only digits and no "
                error_message+="sign."

                argparser_translate "Error arg def pos uint" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        done

        # Check the notes.
        for note in "${notes[@]}"; do
            if [[ -n "${note}" && "${note}" != "deprecated" ]]; then
                error_message="Error: The positional argument with the "
                error_message+="identifier \"\$1\" has \"\$2\" given as note, "
                error_message+="but only \"deprecated\" is supported."

                argparser_translate "Error arg def pos note" \
                    "${error_message}" "${arg_key}" "${note}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        done
    done
}

function argparser_check_args_definition_option_values() {
    # Check if the script's arguments' definition is consistent
    # regarding the default and choice values, as well as the number of
    # arguments for options (keyword arguments).  This should always be
    # true for production scripts, but maybe not while testing.
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_choice_values: the associative array holding the choice
    #   values (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_notes: the associative array holding the notes (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - all_types: the associative array holding the argument types
    #   (read-only)
    # - error_messages: the error messages, starting with "Error: "
    #   (translated), as indexed array
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)

    # Define the local variables.
    local arg_key
    local arg_number
    local choice_value
    local -a choice_values_arr
    local choice_values_str
    local default_value
    local -a default_values_arr
    local default_values_str
    local error_message
    local joined_array
    local note
    local -a notes
    local translation
    local type

    # Check the consistency of all keyword arguments.
    for arg_key in "${!all_short_options[@]}"; do
        # Read the argument's definition.
        default_values_str="${all_default_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a default_values_arr \
            <<< "${default_values_str}"
        choice_values_str="${all_choice_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values_arr \
            <<< "${choice_values_str}"
        type="${all_types[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a notes \
            <<< "${all_notes[${arg_key}]}"

        # Check if the default value for flags (or arguments that can be
        # used as such), if given, is either "true" or "false".
        if argparser_in_array "${arg_number}" "*" "?" 0 \
            && [[ -n "${default_values_str}" ]] \
            && ! argparser_in_array "${default_values_str}" true false
        then
            error_message="Error: The option with the identifier \"\$1\" must "
            error_message+="be \"true\" or \"false\", but has {\$2} given as "
            error_message+="default."

            argparser_translate "Error arg def option default flag" \
                "${error_message}" "${arg_key}" "${default_values_str}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi

        # Check if the number of default values equals the number of
        # required values.  Else, output an error message.
        if ! argparser_in_array "${arg_number}" "+" "*" "?" 0 \
            && [[ -n "${default_values_str}" \
                && "${#default_values_arr[@]}" != "${arg_number}" ]]
        then
            if [[ "${arg_number}" == 1 ]]; then
                error_message="Error: The option with the identifier \"\$1\" "
                error_message+="requires 1 value, but has \$2 given as "
                error_message+="default."

                argparser_translate "Error arg def option default 1" \
                    "${error_message}" "${arg_key}" "${#default_values_arr[@]}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            else
                error_message="Error: The option with the identifier \"\$1\" "
                error_message+="requires \$2 values, but has \$3 given as "
                error_message+="default."

                argparser_translate "Error arg def option default 2" \
                    "${error_message}" "${arg_key}" "${arg_number}" \
                    "${#default_values_arr[@]}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        fi

        # Check if the default values accord to the choice values, i.e.,
        # if each default value lies within the array of choice values.
        # Else, output an error message.
        if [[ -n "${choice_values_str}" ]]; then
            # Check that flags have no choice value and that "true" and
            # "false" aren't choice values.
            if [[ "${arg_number}" == 0 ]]; then
                error_message="Error: The option with the identifier \"\$1\" "
                error_message+="accepts no choice values, but has {\$2} given."

                argparser_translate "Error arg def option choice flag" \
                    "${error_message}" "${arg_key}" "${choice_values_str}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            else
                for choice_value in "${choice_values_arr[@]}"; do
                    if [[ "${choice_value}" == true \
                        || "${choice_value}" == false ]]
                    then
                        error_message="Error: The option with the identifier "
                        error_message+="\"\$1\" has {\$2} given as choice "
                        error_message+="values, while \"true\" and \"false\" "
                        error_message+="cannot be any."

                        argparser_translate \
                            "Error arg def option choice true" \
                            "${error_message}" "${arg_key}" \
                            "${choice_values_str}"
                        error_message="${translation}"
                        error_messages+=("${error_message}")
                        break
                    fi
                done

            fi

            # Check the default values, separately for flag-like and
            # "normal" arguments.
            for default_value in "${default_values_arr[@]}"; do
                if [[ -z "${default_value}" ]]; then
                    continue
                fi

                if argparser_in_array "${arg_number}" "*" "?"; then
                    if ! argparser_in_array "${default_value}" \
                        "${choice_values_arr[@]}" true false
                    then
                        error_message="Error: The option with the identifier "
                        error_message+="\"\$1\" accepts only the choice "
                        error_message+="values {\$2}, but has {\$3} given as "
                        error_message+="default."

                        argparser_translate \
                            "Error arg def option choice default" \
                            "${error_message}" "${arg_key}" \
                            "${choice_values_str}" "${default_values_str}"
                        error_message="${translation}"
                        error_messages+=("${error_message}")
                        break
                    fi
                else
                    if ! argparser_in_array "${default_value}" \
                        "${choice_values_arr[@]}"
                    then
                        error_message="Error: The option with the identifier "
                        error_message+="\"\$1\" accepts only the choice "
                        error_message+="values {\$2}, but has {\$3} given as "
                        error_message+="default."

                        argparser_translate \
                            "Error arg def option choice default" \
                            "${error_message}" "${arg_key}" \
                            "${choice_values_str}" "${default_values_str}"
                        error_message="${translation}"
                        error_messages+=("${error_message}")
                        break
                    fi
                fi
            done
        fi

        # Check the data type.
        if ! argparser_in_array "${type}" "bool" "char" "float" "file" "int" \
            "str" "uint"
        then
            error_message="Error: The option with the identifier \"\$1\" has "
            error_message+="\"\$2\" given as data type, but only \"bool\", "
            error_message+="\"char\", \"float\", \"file\", \"int\", \"str\", "
            error_message+="and \"uint\" are supported."

            argparser_translate "Error arg def option type" \
                "${error_message}" "${arg_key}" "${type}"
            error_message="${translation}"
            error_messages+=("${error_message}")
        fi

        # Check if the choice values accord to the type.
        for choice_value in "${choice_values_arr[@]}"; do
            if [[ -z "${choice_value}" ]]; then
                # No choice value is given, so abort the loop.
                break
            fi

            if [[ "${type}" == "bool" ]] \
                && ! argparser_is_bool "${choice_value}"
            then
                # Check if the choice value is a Boolean.
                error_message="Error: The option with the identifier \"\$1\" "
                error_message+="has \"\$2\" given as choice value, which must "
                error_message+="be a Boolean, i.e., \"true\" or \"false\"."

                argparser_translate "Error arg def option bool" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${type}" == "char" ]] \
                && ! argparser_is_char "${choice_value}"
            then
                # Check if the choice value is a character.
                error_message="Error: The option with the identifier \"\$1\" "
                error_message+="has \"\$2\" given as choice value, which must "
                error_message+="be a character, i.e., a string comprising one "
                error_message+="printable ASCII character."

                argparser_translate "Error arg def option char" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${type}" == "float" ]] \
                && ! argparser_is_float "${choice_value}"
            then
                # Check if the choice value is a floating-point number.
                error_message="Error: The option with the identifier \"\$1\" "
                error_message+="has \"\$2\" given as choice value, which must "
                error_message+="be a floating-point number, i.e., comprise "
                error_message+="only digits, a dot, and possibly a leading "
                error_message+="sign."

                argparser_translate "Error arg def option float" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${type}" == "int" ]] \
                && ! argparser_is_int "${choice_value}"
            then
                # Check if the choice value is an integer.
                error_message="Error: The option with the identifier \"\$1\" "
                error_message+="has \"\$2\" given as choice value, which must "
                error_message+="be an integer, i.e., comprise only digits and "
                error_message+="possibly a leading sign."

                argparser_translate "Error arg def option int" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            elif [[ "${type}" == "uint" ]] \
                && ! argparser_is_uint "${choice_value}"
            then
                # Check if the choice value is an unsigned integer.
                error_message="Error: The option with the identifier \"\$1\" "
                error_message+="has \"\$2\" given as choice value, which must "
                error_message+="be an unsigned integer, i.e., comprise only "
                error_message+="digits and no sign."

                argparser_translate "Error arg def option uint" \
                    "${error_message}" "${arg_key}" "${choice_value}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        done

        # Check the notes.
        for note in "${notes[@]}"; do
            if [[ -n "${note}" && "${note}" != "deprecated" ]]; then
                error_message="Error: The option with the identifier \"\$1\" "
                error_message+="has \"\$2\" given as note, but only "
                error_message+="\"deprecated\" is supported."

                argparser_translate "Error arg def option note" \
                    "${error_message}" "${arg_key}" "${note}"
                error_message="${translation}"
                error_messages+=("${error_message}")
            fi
        done
    done
}

function argparser_add_args_definition_help_options() {
    # Add the help, usage, and/or version message options to the
    # arguments definition's associative arrays.
    #
    # Nonlocals:
    # - all_arg_groups: the associative array holding the argument
    #   groups
    # - all_arg_numbers: the associative array holding the argument
    #   numbers
    # - all_choice_values: the associative array holding the choice
    #   values
    # - all_default_values: the associative array holding the default
    #   values
    # - all_help_texts: the associative array holding the help texts
    # - all_long_options: the associative array holding the long option
    #   names
    # - all_notes: the associative array holding the notes
    # - all_short_options: the associative array holding the short
    #   option names
    # - all_types: the associative array holding the argument types
    # - all_value_names: the associative array holding the value names
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    # - ARGPARSER_HELP_ARG_GROUP (read-only)
    # - ARGPARSER_HELP_OPTIONS (read-only)
    # - ARGPARSER_USAGE_OPTIONS (read-only)
    # - ARGPARSER_USE_LONG_OPTIONS (read-only)
    # - ARGPARSER_USE_SHORT_OPTIONS (read-only)
    # - ARGPARSER_VERSION_OPTIONS (read-only)

    # Define the local variables.
    local arg_key
    local -a arg_keys
    local -a help_texts
    local i
    local -a long_options
    local -a short_options
    local translation
    local value
    local var
    local -a vars

    # Set the definition fields for the help, usage, and version message
    # options.  Translate the strings for the help texts.
    arg_keys=(
        "help"
        "usage"
        "version"
    )
    short_options=(
        "${ARGPARSER_HELP_OPTIONS}"
        "${ARGPARSER_USAGE_OPTIONS}"
        "${ARGPARSER_VERSION_OPTIONS}"
    )
    long_options=(
        "help"
        "usage"
        "version"
    )

    help_texts=()
    argparser_translate "--help" "display this help and exit"
    help_texts+=("${translation}")

    argparser_translate "--usage" "display the usage and exit"
    help_texts+=("${translation}")

    argparser_translate "--version" "display the version and exit"
    help_texts+=("${translation}")

    # If requested, add the help, usage, and version message options to
    # the arguments definition's associative arrays.
    vars=(
        ARGPARSER_ADD_HELP
        ARGPARSER_ADD_USAGE
        ARGPARSER_ADD_VERSION
    )
    for i in "${!vars[@]}"; do
        var="${vars[i]}"
        value="${!var}"
        if [[ "${value}" == true ]]; then
            arg_key="${arg_keys[i]}"

            if [[ "${ARGPARSER_USE_LONG_OPTIONS}" == true \
                && "${ARGPARSER_USE_SHORT_OPTIONS}" == true ]]
            then
                all_short_options[${arg_key}]="${short_options[i]}"
                all_long_options[${arg_key}]="${long_options[i]}"
            elif [[ "${ARGPARSER_USE_SHORT_OPTIONS}" == true ]]; then
                all_short_options[${arg_key}]="${short_options[i]}"
                all_long_options[${arg_key}]=""
            elif [[ "${ARGPARSER_USE_LONG_OPTIONS}" == true ]]; then
                all_short_options[${arg_key}]=""
                all_long_options[${arg_key}]="${long_options[i]}"
            fi

            all_value_names[${arg_key}]=""
            all_default_values[${arg_key}]="false"
            all_choice_values[${arg_key}]=""
            all_types[${arg_key}]="bool"
            all_arg_numbers[${arg_key}]="0"
            all_arg_groups[${arg_key}]="${ARGPARSER_HELP_ARG_GROUP}"
            all_notes[${arg_key}]=""
            all_help_texts[${arg_key}]="${help_texts[i]}"
        fi
    done
}

# Define the Argparser functions for the argument parsing.
function argparser_get_arg_key() {
    # Get the argument identifier (key) for a given short or long option
    # name.
    #
    # Arguments:
    # - $1: whether the option is expected to be a short or long option
    #   ("short" or "long")
    # - $2: the option name
    #
    # Nonlocals:
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - arg_key: the argument identifier, if the key exists, or the
    #   empty string, else (when the option name is erroneous)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)

    # Define the local variables.
    local long_option
    local -a long_options
    local mode
    local option_name
    local short_option
    local -a short_options

    # Read the arguments.
    mode="$1"
    option_name="$2"

    # Get the argument identifier.
    if [[ "${mode}" == "short" ]]; then
        for arg_key in "${!all_short_options[@]}"; do
            # Read the argument's definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
                <<< "${all_short_options[${arg_key}]}"

            # Ignore arguments without a short option name.
            if [[ -z "${short_options[0]}" ]]; then
                continue
            fi

            # Check the short options.
            for short_option in "${short_options[@]}"; do
                if [[ "${option_name}" == "${short_option}" ]]; then
                    return
                fi
            done
        done
    else
        for arg_key in "${!all_long_options[@]}"; do
            # Read the argument's definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
                <<< "${all_long_options[${arg_key}]}"

            # Ignore arguments without a long option name.
            if [[ -z "${long_options[0]}" ]]; then
                continue
            fi

            # Check the long options.
            for long_option in "${long_options[@]}"; do
                if [[ "${option_name}" == "${long_option}" ]]; then
                    return
                fi
            done
        done
    fi

    arg_key=""
}

function argparser_get_option_names() {
    # Concatenate the name of all short and long options.
    #
    # Arguments:
    # - $1: the argument's name (key)
    # - $2: the order of the options ("short-long", "long-short",
    #       "short", or "long")
    # - $3: whether to colorize the option names by argparser_colorize
    #
    # Nonlocals:
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - all_value_names: the associative array holding the value names
    #   (read-only)
    # - option_names: the name of all short and long options as
    #   ${ARGPARSER_ARG_DELIMITER_2}-separated string
    # - styles: the associative array containing the styles
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)

    # Define the local variables.
    local arg_key
    local colorize
    local joined_array
    local long_option_names
    local long_option
    local -a long_options
    local order
    local short_option_names
    local short_option
    local -a short_options
    local value_names

    # Read the arguments.
    arg_key="$1"
    order="$2"
    colorize="$3"

    # Read the argument's definition.  As positional arguments aren't
    # included in ${all_short_options} and ${all_long_options}, assign
    # them the default value of the empty string, indicating absence.
    # For the option name below, use the value name, of which positional
    # arguments can only have one (thus using a string, not an array).
    if argparser_in_array "${arg_key}" "${!all_short_options[@]}"; then
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
            <<< "${all_short_options[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
            <<< "${all_long_options[${arg_key}]}"
    else
        short_options=("")
        long_options=("")
    fi
    value_names="${all_value_names[${arg_key}]}"

    # Concatenate the names of all short and long options, including the
    # leading hyphen(s).  Possibly, colorize them, including the value
    # names.
    if [[ "${colorize}" == true ]]; then
        argparser_join true "${styles["short_options"]}" 1 \
            "${short_options[@]/#/-}"
        short_option_names="${joined_array}"

        argparser_join true "${styles["long_options"]}" 1 \
            "${long_options[@]/#/--}"
        long_option_names="${joined_array}"

        argparser_colorize "${styles["value_names"]}" "${value_names}" 1 \
            value_names
    else
        argparser_join false "" "" "${short_options[@]/#/-}"
        short_option_names="${joined_array}"

        argparser_join false "" "" "${long_options[@]/#/--}"
        long_option_names="${joined_array}"
    fi


    # Merge the names of all short and long options, if any is given, or
    # use the value names as fallback.
    if [[ -n "${short_options[0]}" && -n "${long_options[0]}" ]]; then
        if [[ "${order}" == "short-long" ]]; then
            option_names="${short_option_names}${ARGPARSER_ARG_DELIMITER_2}"
            option_names+="${long_option_names}"
        elif [[ "${order}" == "long-short" ]]; then
            option_names="${long_option_names}${ARGPARSER_ARG_DELIMITER_2}"
            option_names+="${short_option_names}"
        elif [[ "${order}" == "short" ]]; then
            option_names="${short_option_names}"
        elif [[ "${order}" == "long" ]]; then
            option_names="${long_option_names}"
        fi
    elif [[ -n "${short_options[0]}" ]]; then
        option_names="${short_option_names}"
    elif [[ -n "${long_options[0]}" ]]; then
        option_names="${long_option_names}"
    else
        option_names="${value_names}"
    fi
}

function argparser_parse_arg() {
    # Parse an argument given to the script.
    #
    # Arguments:
    # - $1: the argument to parse
    #
    # Nonlocals:
    # - is_positional_only: whether the positional arguments delimiter
    #   "--" has already been set and has not been unset by "++"
    #   (read-only)
    # - is_self_parsing: whether the Argparser currently parses its own
    #   arguments (read-only)
    # - messages: the parsed argument as message or an error message,
    #   starting with "Help", "Usage", "Version", "Logo",
    #   "Positional_Start", "Positional_End", "Error: " (translated),
    #   "Argument: ", "Prefix: ", or "Value: ", as indexed array
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    # - ARGPARSER_ALLOW_FLAG_INVERSION (read-only)
    # - ARGPARSER_USE_LONG_OPTIONS (read-only)
    # - ARGPARSER_USE_SHORT_OPTIONS (read-only)

    # Define the local variables.
    local error_message
    local given_arg
    local translation

    # Read the argument.
    given_arg="$1"

    # Output the argument, split into option names and values, or an
    # error message.  In the latter case, output also the given
    # argument, such that values following the unknown argument are
    # assigned to this argument, not the last known one that got parsed.
    if [[ "${given_arg}" != "++"* \
        && ("${given_arg}" != [-+]* || "${is_positional_only}" == true) ]]
    then
        # The argument doesn't start with a hyphen ("-") or plus sign
        # ("+"), so deem it a value to a previous keyword argument or a
        # positional argument.  Likewise, if the positional arguments
        # delimiter "--" has already been set and has neither been unset
        # by "++" nor the current argument is this "++", then deem any
        # value a positional argument.
        messages+=("Value: ${given_arg}")
    elif [[ "${given_arg}" == "--" ]]; then
        # The argument is the positional arguments delimiter "--".
        messages+=("Positional_Start")
    elif [[ "${given_arg}" == "--="* ]]; then
        # The argument is the positional arguments delimiter "--", but
        # followed by an illegal equals sign ("=").
        error_message="Error: The special option \"--\" takes no value."
        argparser_translate "Error arg double hyphen" "${error_message}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    elif [[ "${given_arg}" == "++" ]]; then
        # The argument is the positional arguments delimiter "++".
        messages+=("Positional_End")
    elif [[ "${given_arg}" == "++="* ]]; then
        # The argument is the positional arguments delimiter "++", but
        # followed by an illegal equals sign ("=").
        error_message="Error: The special option \"++\" takes no value."
        argparser_translate "Error arg double plus" "${error_message}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    elif [[ "${given_arg}" == "--argparser" && "${is_self_parsing}" == true ]]
    then
        # The argument is the magic string for the Argparser, which was
        # directly called and not run from another script.  Since the
        # Argparser accepts only long options by design, no test for
        # ${ARGPARSER_USE_LONG_OPTIONS} is necessary.
        messages+=("Logo")
    elif [[ "${ARGPARSER_USE_LONG_OPTIONS}" == true \
        && ("${given_arg::2}" == "--" \
            || ("${ARGPARSER_ALLOW_FLAG_INVERSION}" == true \
                && "${given_arg::2}" == "++")) ]]
    then
        # The argument is a long option, with a double hyphen or an
        # activated doubled plus sign as prefix, so check whether the
        # given argument is defined.
        argparser_parse_long_option "${given_arg}"
    elif [[ "${ARGPARSER_USE_SHORT_OPTIONS}" == true \
        && ("${given_arg::2}" == -[!-+] \
            || ("${ARGPARSER_ALLOW_FLAG_INVERSION}" == true \
                && "${given_arg::2}" == +[!-+])) ]]
    then
        # The argument is a short option, so check whether the given
        # argument is defined.
        argparser_parse_short_option "${given_arg}"
    elif [[ "${given_arg::2}" == +[!-] ]]; then
        # The argument is given with a deactivated plus sign (possibly
        # doubled) as prefix.
        error_message="Error: Inverting flags with a \"+\" prefix is "
        error_message+="deactivated."
        argparser_translate "Error arg inversion" "${error_message}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    else
        # The argument hasn't been matched by any condition, so deem it
        # unknown.  This is true if the prefix is neither "--", "++", a
        # single "-" nor a single "+", but e.g. "+-" or "-+".  This is
        # also true if the argument is a short option, but only long
        # options shall be accepted, or vice versa.
        error_message="Error: The argument \"\$1\" is unknown."
        argparser_translate "Error arg unknown" "${error_message}" \
            "${given_arg%%=*}"
        error_message="${translation}"
        messages+=("${error_message}")
        messages+=("Argument: ${given_arg}")
    fi
}

function argparser_parse_long_option() {
    # Parse a long-option argument given to the script.
    #
    # Arguments:
    # - $1: the argument to parse
    #
    # Nonlocals:
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - messages: the parsed argument as message or an error message,
    #   starting with "Error: " (translated), "Argument: ", "Prefix: ",
    #   or "Value: ", as indexed array
    #
    # Environment:
    # - ARGPARSER_ALLOW_FLAG_NEGATION (read-only)
    # - ARGPARSER_ALLOW_OPTION_ABBREVIATION (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)

    # Define the local variables.
    local abbr_long_option
    local -a abbr_long_options
    local actual_prefix
    local arg_key
    local count
    local error_message
    local given_arg
    local is_negated
    local long_option
    local -a long_options
    local option_name
    local prefix
    local translation
    local value
    local -a values

    # Read the argument.
    given_arg="$1"

    # Get the prefix, option name, and possibly values for the given
    # argument.
    prefix="${given_arg::1}"
    option_name="${given_arg:2}"
    if [[ "${given_arg}" =~ "=" ]]; then
        option_name="${option_name%%=*}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a values \
            <<< "${given_arg#*=}"
    else
        values=("")
    fi
    argparser_get_arg_key "long" "${option_name}"

    # If no argument identifier for the entire option name has been
    # found, the option name starts with "no-", and flag negation is
    # enabled, trim the "no-" prefix, convert it to a "+", and set the
    # option name's remainder as new option name.
    if [[ "${ARGPARSER_ALLOW_FLAG_NEGATION}" == true \
        && -z "${arg_key}" \
        && "${option_name::3}" == "no-" ]]
    then
        is_negated=true
        option_name="${option_name:3}"
        argparser_get_arg_key "long" "${option_name}"

        actual_prefix="${prefix}"
        if [[ "${prefix}" == "-" ]]; then
            prefix="+"
        else
            prefix="-"
        fi
    fi

    # Output the argument, split into the option name and values, or an
    # error message.  In the latter case, output also the given
    # argument, such that values following the unknown argument are
    # assigned to this argument, not the last known one that got parsed.
    if [[ "${ARGPARSER_ALLOW_OPTION_ABBREVIATION}" == true \
        && -z "${arg_key}" ]]
    then
        # Check if the argument is an abbreviated long option, since no
        # argument identifier for the entire option name has been found.
        abbr_long_options=( )
        for arg_key in "${!all_long_options[@]}"; do
            # Read the argument's definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
                <<< "${all_long_options[${arg_key}]}"

            # Abbreviate the long option names by shortening them to the
            # length of the given option name and add them to the
            # indexed array.  Ignore arguments without long option name.
            for long_option in "${long_options[@]}"; do
                if [[ -n "${long_option}" ]]; then
                    abbr_long_options+=("${long_option::${#option_name}}")
                fi
            done
        done

        # Count the number of matches of the argument among the
        # abbreviated long option names. If it matches once, output the
        # argument identifier and possibly the values following the
        # equals sign ("=").  If multiple or no option names are
        # matched, output an error message, instead.
        argparser_count "${option_name}" "${abbr_long_options[@]}"
        if (( count == 1 )); then
            # Get the argument identifier for the abbreviated argument.
            for arg_key in "${!all_long_options[@]}"; do
                # Read the argument's definition.
                IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
                    <<< "${all_long_options[${arg_key}]}"

                # Abbreviate the long option names by shortening them to
                # the length of the given option name.  Ignore arguments
                # without long option name.  As soon as the abbreviated
                # option name matches the given one, the argument
                # identifier has been found, so break both loops.
                for long_option in "${long_options[@]}"; do
                    if [[ -z "${long_option}" ]]; then
                        continue
                    fi

                    abbr_long_option="${long_option::${#option_name}}"
                    if [[ "${option_name}" == "${abbr_long_option}"* ]]; then
                        break 2
                    fi
                done
            done

            if [[ -n "${values[0]}" ]]; then
                # Output the argument identifier, the prefix, and the
                # values.
                messages+=("Argument: ${arg_key}")
                messages+=("Prefix: ${prefix}")
                for value in "${values[@]}"; do
                    messages+=("Value: ${value}")
                done
            else
                # Output the argument identifier and the prefix.
                messages+=("Argument: ${arg_key}")
                messages+=("Prefix: ${prefix}")
            fi
        elif (( count > 1 )); then
            # Since multiple option names have been found in the
            # definition, output an error message and the argument.
            error_message="Error: The long option \"\$1\" matches multiple "
            error_message+="long options."

            argparser_translate "Error long option match" "${error_message}" \
                "${given_arg%%=*}"
            error_message="${translation}"
            messages+=("${error_message}")
            messages+=("Argument: ${given_arg}")
        else
            # Since the argument hasn't been found in the definition,
            # output an error message and the argument.
            if [[ "${is_negated}" == true ]]; then
                error_message="Error: The long option \"\$1\" is negated, but "
                error_message+="its affirmative version \"\$2\" is unknown."
                argparser_translate "Error long option negation" \
                    "${error_message}" "${given_arg%%=*}" \
                    "${actual_prefix}${actual_prefix}${option_name}"
                error_message="${translation}"
                messages+=("${error_message}")
                messages+=("Argument: ${given_arg}")
            else
                error_message="Error: The long option \"\$1\" is unknown."
                argparser_translate "Error long option unknown" \
                    "${error_message}" "${given_arg%%=*}"
                error_message="${translation}"
                messages+=("${error_message}")
                messages+=("Argument: ${given_arg}")
            fi
        fi
    else
        if [[ -n "${arg_key}" ]]; then
            if [[ -n "${values[0]}" ]]; then
                # Output the argument identifier, the prefix, and the
                # values.
                messages+=("Argument: ${arg_key}")
                messages+=("Prefix: ${prefix}")
                for value in "${values[@]}"; do
                    messages+=("Value: ${value}")
                done
            else
                # Output the argument identifier and the prefix.
                messages+=("Argument: ${arg_key}")
                messages+=("Prefix: ${prefix}")
            fi
        else
            # Since the argument hasn't been found in the definition,
            # output an error message and the argument.
            if [[ "${is_negated}" == true ]]; then
                error_message="Error: The long option \"\$1\" is negated, but "
                error_message+="its affirmative version \"\$2\" is unknown."
                argparser_translate "Error long option negation" \
                    "${error_message}" "${given_arg%%=*}" \
                    "${actual_prefix}${actual_prefix}${option_name}"
                error_message="${translation}"
                messages+=("${error_message}")
                messages+=("Argument: ${given_arg}")
            else
                error_message="Error: The long option \"\$1\" is unknown."
                argparser_translate "Error long option unknown" \
                    "${error_message}" "${given_arg%%=*}"
                error_message="${translation}"
                messages+=("${error_message}")
                messages+=("Argument: ${given_arg}")
            fi
        fi
    fi
}

function argparser_parse_short_option() {
    # Parse a short-option argument given to the script.
    #
    # Arguments:
    # - $1: the argument to parse
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - messages: the parsed argument as message or an error message,
    #   starting with "Error: " (translated), "Argument: ", "Prefix: ",
    #   or "Value: ", as indexed array
    #
    # Environment:
    # - ARGPARSER_ALLOW_OPTION_MERGING (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)

    # Define the local variables.
    local arg_key
    local arg_number
    local char
    local given_arg
    local i
    local option_name
    local prefix
    local translation
    local value
    local -a values

    # Read the argument.
    given_arg="$1"

    # Get the prefix, option name, and possibly values for the given
    # argument.
    prefix="${given_arg::1}"
    option_name="${given_arg:1}"
    if [[ "${given_arg}" =~ "=" ]]; then
        option_name="${option_name%%=*}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a values \
            <<< "${given_arg#*=}"
    else
        values=("")
    fi
    argparser_get_arg_key "short" "${option_name}"

    # Get the argument identifier for the given (and perhaps merged)
    # argument and output it, possibly along with the values following
    # the equals sign ("=").
    if [[ "${ARGPARSER_ALLOW_OPTION_MERGING}" == true ]]; then
        # Split the combined short option name, which may end in a
        # merged value, after any character.
        for (( i = 0; i < "${#option_name}"; i++ )); do
            char="${option_name:i:1}"
            argparser_get_arg_key "short" "${char}"
            if [[ -z "${arg_key}" ]]; then
                # Since the argument hasn't been found in the
                # definition, output an error message and the argument.
                error_message="Error: The short option \"\$1\$2\" is unknown."
                argparser_translate "Error short option merge" \
                    "${error_message}" "${prefix}" "${char}"
                error_message="${translation}"
                messages+=("${error_message}")
                messages+=("Argument: ${given_arg}")
                return
            fi

            # Output the argument identifier and the prefix for the
            # short option name character.
            messages+=("Argument: ${arg_key}")
            messages+=("Prefix: ${prefix}")

            # Get the number of required arguments to judge whether the
            # following character is an argument to the current option
            # or another option (i.e., the current option is a flag).
            # If there is no following character, the value must have
            # been given as next whitespace-delimited argument, thus
            # don't output anything.
            arg_number="${all_arg_numbers[${arg_key}]}"
            if [[ "${arg_number}" != 0 ]] && (( i < "${#option_name}" - 1 ))
            then
                # Output the value, which is the argument's rest.
                messages+=("Value: ${option_name:i+1}")
                return
            fi
        done

        if [[ -n "${values[0]}" ]]; then
            # Output the values, which are given after an equals sign
            # ("=").
            for value in "${values[@]}"; do
                messages+=("Value: ${value}")
            done
        fi
    else
        if [[ -n "${arg_key}" ]]; then
            if [[ -n "${values[0]}" ]]; then
                # Output the argument identifier, the prefix, and the
                # values.
                messages+=("Argument: ${arg_key}")
                messages+=("Prefix: ${prefix}")
                for value in "${values[@]}"; do
                    messages+=("Value: ${value}")
                done
            else
                # Output the argument identifier and the prefix.
                messages+=("Argument: ${arg_key}")
                messages+=("Prefix: ${prefix}")
            fi
        else
            # Since the argument hasn't been found in the definition,
            # output an error message and the argument.
            error_message="Error: The short option \"\$1\" is unknown."
            argparser_translate "Error short option unknown" \
                "${error_message}" "${given_arg%%=*}"
            error_message="${translation}"
            messages+=("${error_message}")
            messages+=("Argument: ${given_arg}")
        fi
    fi
}

function argparser_parse_positional_args() {
    # Parse all positional arguments given to the script.
    #
    # Arguments:
    # - $@: the arguments to parse
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    # - messages: the parsed argument as message or an error message,
    #   starting with "Error: " (translated), "Argument: ", or
    #   "Value: ", as indexed array
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)

    # Define the local variables.
    local arg_key
    local arg_number
    local args_count
    local default_args_count
    local -a default_values_arr
    local default_values_str
    local error_message
    local given_arg
    local -a given_args
    local i
    local index
    local required_args_count
    local translation
    local -a values

    # Read the arguments and split the values on
    # ${ARGPARSER_ARG_DELIMITER_2} characters.
    values=( )
    for given_arg in "$@"; do
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a given_args \
            <<< "${given_arg}"
        values+=("${given_args[@]}")
    done

    # Count the defined positional arguments with default values and
    # those without.
    default_args_count=0
    required_args_count=0
    for arg_key in "${all_positional_args[@]}"; do
        # Read the argument's definition.
        default_values_str="${all_default_values[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # For the counting, consider the number of values for "+" as 1
        # and for "*" or "?" as 0, i.e., the minimum number that can be
        # given in each case.
        if [[ "${arg_number}" == "+" ]]; then
            arg_number=1
        elif [[ "${arg_number}" == "*" ||  "${arg_number}" == "?" ]]; then
            arg_number=0
        fi

        # Increment the respective count.
        if [[ -z "${default_values_str}" ]]; then
            (( required_args_count += arg_number ))
        else
            (( default_args_count += arg_number ))
        fi
    done

    # Based on the number of given, default, and required positional
    # arguments, judge whether values for arguments with default values
    # are given.  Since there cannot be arguments with an arbitrary
    # number of values defined when there are arguments with default
    # values defined, a higher number of given values than required
    # means that either some values for arguments with default values
    # are given (then, their count exceeds zero), or that an argument
    # accepting an arbitrary number of values is given as last once
    # (then, the count of default arguments is zero).  This allows to
    # distinguish these two cases.
    args_count="${#values[@]}"
    if (( args_count > required_args_count && default_args_count > 0 )); then
        # There are arguments having default values given.  Get the
        # argument identifiers for all given arguments and output them,
        # along with the values.
        index=0
        for arg_key in "${all_positional_args[@]}"; do
            # Read the argument's definition.
            arg_number="${all_arg_numbers[${arg_key}]}"

            # Output as many given arguments as requested.
            messages+=("Argument: ${arg_key}")
            for (( i = index; i < arg_number + index && i < args_count; i++ ))
            do
                messages+=("Value: ${values[i]}")
            done
            (( index += arg_number ))
        done
    else
        # There are no arguments having default values given.  Get the
        # argument identifiers for all given arguments and output them,
        # along with the values.
        index=0
        for arg_key in "${all_positional_args[@]}"; do
            # Read the argument's definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a default_values_arr \
                <<< "${all_default_values[${arg_key}]}"
            arg_number="${all_arg_numbers[${arg_key}]}"

            # Skip the defined arguments having default values, but
            # which aren't given.
            if [[ -n "${default_values_arr[0]}" ]]; then
                continue
            fi

            # If the positional argument accepts an arbitrary number of
            # values, output all remaining given arguments.  For "?",
            # output one argument, if existing, or else zero.  Else,
            # output only as many arguments as requested.
            messages+=("Argument: ${arg_key}")
            if [[ "${arg_number}" == "+" || "${arg_number}" == "*" ]]; then
                for (( i = index; i < args_count; i++ )); do
                    messages+=("Value: ${values[i]}")
                done
                index="${args_count}"

                break
            elif [[ "${arg_number}" == "?" ]]; then
                if (( index < args_count)); then
                    messages+=("Value: ${values[index]}")
                    (( index++ ))
                fi
            else
                for (( i = index; i < arg_number + index && i < args_count; \
                    i++ ))
                do
                    messages+=("Value: ${values[i]}")
                done
                (( index += arg_number ))
            fi
        done
    fi

    # If there are positional arguments remaining that haven't been
    # consumed by a defined argument, output an error message.
    if (( index < args_count )); then
        if (( index == 1 )); then
            error_message="Error: 1 positional argument is required, but \$1 "
            error_message+="are given."

            argparser_translate "Error pos arg count 1" "${error_message}" \
                "${args_count}"
            error_message="${translation}"
        else
            error_message="Error: \$1 positional arguments are required, but "
            error_message+="\$2 are given."

            argparser_translate "Error pos arg count 2" "${error_message}" \
                "${index}" "${args_count}"
            error_message="${translation}"
        fi
        messages+=("${error_message}")
    fi
}

function argparser_check_arg_values() {
    # Check if a script's argument accords to its definition.
    #
    # Arguments:
    # - $1: the argument's name (key)
    # - $2: the argument's prefixes ("-", "+", or "")
    # - $3: the argument's values
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_choice_values: the associative array holding the choice
    #   values (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_notes: the associative array holding the notes (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    # - all_types: the associative array holding the argument types
    #   (read-only)
    # - messages: the parsed argument as message or an error or warning
    #   message, starting with "Error: " (translated), "Warning: "
    #   (translated), or "Value: ", as indexed array
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_COUNT_FLAGS (read-only)

    # Define the local variables.
    local arg_key
    local arg_number
    local choice_value
    local -a choice_values_arr
    local choice_values_str
    local count
    local count_hyphen
    local count_plus
    local default_value
    local -a default_values_arr
    local default_values_str
    local error_message
    local i
    local joined_array
    local note
    local -a notes
    local option_names
    local prefix
    local -a prefixes
    local translation
    local type
    local value
    local -a values_arr
    local values_str
    local warning_message

    # Read the arguments.  Since positional arguments have no prefix,
    # use an empty array as default value, such that testing on its
    # value is possible, below.
    arg_key="$1"
    if argparser_in_array "${arg_key}" "${all_positional_args[@]}"; then
        prefixes=( )
    else
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a prefixes <<< "$2"
    fi

    if [[ "${arg_key}" == "ARGPARSER_ARG_DELIMITER_2" ]]; then
        if [[ -n "$3" ]]; then
            values_str="$3"
            values_arr=("${values_str}")
        else
            values_str=""
            values_arr=( )
        fi

        # Read the argument's definition.
        default_values_str="${all_default_values[${arg_key}]}"
        default_values_arr=("${default_values_str}")
        choice_values_str="${all_choice_values[${arg_key}]}"
        choice_values_arr=("${choice_values_str}")
        type="${all_types[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"
        notes=("${all_notes[${arg_key}]}")
    else
        values_str="$3"
        if [[ "${values_str}" == "${ARGPARSER_ARG_DELIMITER_2}" ]]; then
            # If there is no actual value for the argument, i.e., just
            # the ${ARGPARSER_ARG_DELIMITER_2} character introduced to
            # discern non-flag arguments given multiple times and partly
            # without value, remove it.  This allows non-flag-like
            # arguments given without any value not to raise the error
            # of being used as flag, but as missing a value, below.
            values_str=""
        fi
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a values_arr \
            <<< "${values_str}"

        # Read the argument's definition.
        default_values_str="${all_default_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a default_values_arr \
            <<< "${default_values_str}"
        choice_values_str="${all_choice_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values_arr \
            <<< "${choice_values_str}"
        type="${all_types[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a notes \
            <<< "${all_notes[${arg_key}]}"
    fi

    # Concatenate the name of all short and long options for the error
    # and warning messages.
    argparser_get_option_names "${arg_key}" "short-long" false

    # Check the notes.
    for note in "${notes[@]}"; do
        if [[ "${note}" == "deprecated" && "${#prefixes[@]}" != 0 ]]; then
            # Only output a deprecation warning if the argument had been
            # given (and thus the prefix is non-empty), not when its
            # default value will be used.
            warning_message="Warning: The argument \"\$1\" is deprecated and "
            warning_message+="will be removed in the future."

            argparser_translate "Warning deprecation" "${warning_message}" \
                "${option_names}"
            warning_message="${translation}"
            messages+=("${warning_message}")
        fi
    done

    # If the argument is used as flag, but is none (nor can be used as
    # such), output an error message.  In this case, there are empty
    # strings among the values.
    for value in "${values_arr[@]}"; do
        if ! argparser_in_array "${arg_number}" "*" "?" 0 \
            && [[ -z "${value}" ]]
        then
            error_message="Error: The option \"\$1\" is no flag and thus "
            error_message+="needs a value after the option name."

            argparser_translate "Error arg no flag 1" "${error_message}" \
                "${option_names}"
            error_message="${translation}"
            messages+=("${error_message}")
            messages+=("${error_message}")
            return
        fi
    done

    # Remove the empty fields.  This is necessary to allow true flags to
    # be given multiple times without considering the empty field an
    # (illegal) value.
    for i in "${!values_arr[@]}"; do
        if [[ -z "${values_arr[i]}" ]]; then
            unset 'values_arr[i]'
        fi
    done

    values_arr=("${values_arr[@]}")
    argparser_join false "" "" "${values_arr[@]}"
    values_str="${joined_array}"

    # If a "+" (or equivalent "no-") prefix is given and the argument is
    # no flag (or not used as such), output an error message.
    for prefix in "${prefixes[@]}"; do
        if [[ "${prefix}" == "-" || "${arg_number}" == 0 ]]; then
            continue
        fi

        if [[ "${arg_number}" == "*" || "${arg_number}" == "?" ]] \
            && (( "${#values_arr[@]}" > 0 ))
        then
            error_message="Error: The option \"\$1\" is not used as a flag "
            error_message+="(it has a value given) and thus cannot be given "
            error_message+="with a \"+\" or \"no-\" prefix."

            argparser_translate "Error arg no flag 2" "${error_message}" \
                "${option_names}"
            error_message="${translation}"
            messages+=("${error_message}")
            return
        elif ! argparser_in_array "${arg_number}" "*" "?" 0; then
            error_message="Error: The option \"\$1\" is no flag and thus "
            error_message+="cannot be given with a \"+\" or \"no-\" prefix."

            argparser_translate "Error arg no flag 3" "${error_message}" \
                "${option_names}"
            error_message="${translation}"
            messages+=("${error_message}")
            return
        fi
    done

    # Check if the correct number of values is given.  If an argument
    # hadn't been given, both its value and prefix are empty, but if it
    # was given without value, the prefix is non-empty, allowing to
    # distinguish both cases.
    if (( "${#values_arr[@]}" == 0 && "${#prefixes[@]}" == 0 )); then
        if [[ -z "${default_values_str}" ]]; then
            # The argument is not given, but must have been since it
            # doesn't have a default value.  Hence, output an error
            # message.
            error_message="Error: The argument \"\$1\" is mandatory, but not "
            error_message+="given."

            argparser_translate "Error mandatory arg" "${error_message}" \
                "${option_names}"
            error_message="${translation}"
            messages+=("${error_message}")
            return
        elif [[ "${ARGPARSER_COUNT_FLAGS}" == true ]] \
            && argparser_in_array "${arg_number}" "*" "?" 0
        then
            # The argument is not given, but is a flag (or may be used
            # as such) with a default value of "true" or "false".  Since
            # the flags shall be counted, set the value to 1 for "true"
            # and to -1 for "false", which are the same values as would
            # be when the flags would be given with a hyphen ("-",
            # "true") or plus sign ("+", "false").  Output the values.
            # Since the default values are used, further checking isn't
            # necessary.
            if [[ "${default_values_str}" == true ]]; then
                messages+=("Value: 1")
            else
                messages+=("Value: -1")
            fi
            return
        else
            # The argument is not given, but it has default values.
            # Hence, read and output them.  This is required for
            # optional arguments, which don't need to be set.  Since the
            # default values are used, further checking isn't necessary.
            messages+=("Value: ${default_values_str}")
            return
        fi
    elif [[ "${arg_number}" == "+" && "${#values_arr[@]}" == 0 ]]; then
        # The number of values doesn't equal the number of required
        # values, so check if some default values are given.
        if [[ -z "${default_values_str}" ]]; then
            # No default value is given, so output an error message
            # indicating the number of required and given arguments.
            error_message="Error: The argument \"\$1\" requires at least 1 "
            error_message+="value, but has \$2 given."

            argparser_translate "Error wrong arg number 1" "${error_message}" \
                "${option_names}" "${#values_arr[@]}"
            error_message="${translation}"
            messages+=("${error_message}")
        else
            # As some default values are given, print a similar warning
            # message as for the absence case, but set the values to the
            # default values and output them.  Since the default values
            # are used, further checking isn't necessary.
            warning_message="Warning: The argument \"\$1\" requires at least "
            warning_message+="1 value, but has \$2 given.  For convenience, "
            warning_message+="the default (\$3) is used."

            argparser_translate "Warning wrong arg number 1" \
                "${warning_message}" "${option_names}" "${#values_arr[@]}" \
                "${default_values_str}"
            warning_message="${translation}"
            messages+=("${warning_message}")

            messages+=("Value: ${default_values_str}")
            return
        fi
    elif [[ "${arg_number}" == "?" ]] && (( "${#values_arr[@]}" > 1 )); then
        # The number of values doesn't equal the number of required
        # values, so check if some default values are given.
        if [[ -z "${default_values_str}" ]]; then
            # No default value is given, so output an error message
            # indicating the number of required and given arguments.
            error_message="Error: The argument \"\$1\" requires 0 or 1 value, "
            error_message+="but has \$2 given."

            argparser_translate "Error wrong arg number 2" \
                "${error_message}" "${option_names}" "${#values_arr[@]}"
            error_message="${translation}"
            messages+=("${error_message}")
        else
            # As some default values are given, print a similar warning
            # message as for the absence case, but set the values to the
            # default values and output them.  Since the default values
            # are used, further checking isn't necessary.
            warning_message="Warning: The argument \"\$1\" requires 0 or 1 "
            warning_message+="value, but has \$2 given.  For convenience, the "
            warning_message+="default (\$3) is used."

            argparser_translate "Warning wrong arg number 2" \
                "${warning_message}" "${option_names}" "${#values_arr[@]}" \
                "${default_values_str}"
            warning_message="${translation}"
            messages+=("${warning_message}")

            messages+=("Value: ${default_values_str}")
            return
        fi
    elif [[ "${arg_number}" == 1 && "${#values_arr[@]}" != 1 ]]; then
        # The number of values doesn't equal the number of required
        # values, so check if some default values are given.
        if [[ -z "${default_values_str}" ]]; then
            # No default value is given, so output an error message
            # indicating the number of required and given arguments.
            error_message="Error: The argument \"\$1\" requires 1 value, but "
            error_message+="has \$2 given."

            argparser_translate "Error wrong arg number 3" \
                "${error_message}" "${option_names}" "${#values_arr[@]}"
            error_message="${translation}"
            messages+=("${error_message}")
        else
            # As some default values are given, print a similar warning
            # message as for the absence case, but set the values to the
            # default values and output them.  Since the default values
            # are used, further checking isn't necessary.
            warning_message="Warning: The argument \"\$1\" requires 1 value, "
            warning_message+="but has \$2 given.  For convenience, the "
            warning_message+="default (\$3) is used."

            argparser_translate "Warning wrong arg number 3" \
                "${warning_message}" "${option_names}" "${#values_arr[@]}" \
                "${default_values_str}"
            warning_message="${translation}"
            messages+=("${warning_message}")

            messages+=("Value: ${default_values_str}")
            return
        fi
    elif argparser_in_array "${arg_number}" "*" "?" 0 \
        && [[ ! -v values_arr || -z "${values_arr[0]}" ]]
    then
        # No value is required nor given, so the argument is a flag.  As
        # it is set (present), set the value to "true" for a "-" prefix
        # and to "false" for a "+" prefix.  Thereby, the last given
        # prefix determines the value, implicitly overriding any prefix
        # given before.  Alternatively, count the number of "-" and "+"
        # prefixes, then take their difference as actual count.
        # Finally, output the values.  Since the default values are
        # used, further checking isn't necessary.
        if [[ "${ARGPARSER_COUNT_FLAGS}" == true ]]; then
            argparser_count "-" "${prefixes[@]}"
            count_hyphen="${count}"

            argparser_count "+" "${prefixes[@]}"
            count_plus="${count}"

            (( count = count_hyphen - count_plus ))
            messages+=("Value: ${count}")
        else
            if [[ "${prefixes[-1]}" == "-" ]]; then
                messages+=("Value: true")
            else
                messages+=("Value: false")
            fi
        fi
        return
    elif argparser_is_int "${arg_number}" \
        && [[ "${#values_arr[@]}" != "${arg_number}" ]]
    then
        # The number of values doesn't equal the number of required
        # values, so check if some default values are given.
        if [[ -z "${default_values_str}" ]]; then
            # No default value is given, so output an error message
            # indicating the number of required and given arguments.
            error_message="Error: The argument \"\$1\" requires \$2 values, "
            error_message+="but has \$3 given."

            argparser_translate "Error wrong arg number 4" "${error_message}" \
                "${option_names}" "${arg_number}" "${#values_arr[@]}"
            error_message="${translation}"
            messages+=("${error_message}")
            return
        else
            # As some default values are given, print a similar warning
            # message as for the absence case, but set the values to the
            # default values and output them.  Since the default values
            # are used, further checking isn't necessary.
            warning_message="Warning: The argument \"\$1\" requires \$2 "
            warning_message+="values, but has \$3 given.  For convenience, "
            warning_message+="the default (\$4) is used."

            argparser_translate "Warning wrong arg number 4" \
                "${warning_message}" "${option_names}" "${arg_number}" \
                "${#values_arr[@]}" "${default_values_str}"
            warning_message="${translation}"
            messages+=("${warning_message}")

            messages+=("Value: ${default_values_str}")
            return
        fi
    fi

    # Check if the given values accord to the choice values, i.e., if
    # each given value lies within the array of choice values.  Else,
    # output an error message.
    if [[ -n "${choice_values_str}" ]]; then
        for value in "${values_arr[@]}"; do
            if ! argparser_in_array "${value}" "${choice_values_arr[@]}"; then
                error_message="Error: The argument \"\$1\" must be in {\$2}, "
                error_message+="but is {\$3}."

                argparser_translate "Error arg choice" "${error_message}" \
                    "${option_names}" "${choice_values_str}" "${values_str}"
                error_message="${translation}"
                messages+=("${error_message}")
                return
            fi
        done
    fi

    # Check if the given values accord to the type.
    for value in "${values_arr[@]}"; do
        if [[ "${type}" == "bool" ]] && ! argparser_is_bool "${value}"; then
            # Check if the value is a Boolean.
            error_message="Error: The argument \"\$1\" is set to \"\$2\", but "
            error_message+="must be a Boolean, i.e., \"true\" or \"false\"."

            argparser_translate "Error arg bool" "${error_message}" \
                "${option_names}" "${value}"
            error_message="${translation}"
            messages+=("${error_message}")
            return
        elif [[ "${type}" == "char" ]] && ! argparser_is_char "${value}"; then
            # Check if the value is a character.
            error_message="Error: The argument \"\$1\" is set to \"\$2\", but "
            error_message+="must be a character, i.e., a string comprising "
            error_message+="one printable ASCII character."

            argparser_translate "Error arg char" "${error_message}" \
                "${option_names}" "${value}"
            error_message="${translation}"
            messages+=("${error_message}")
            return
        elif [[ "${type}" == "float" ]] && ! argparser_is_float "${value}"
        then
            # Check if the value is a floating-point number.
            error_message="Error: The argument \"\$1\" is set to \"\$2\", but "
            error_message+="must be a floating-point number, i.e., comprise "
            error_message+="only digits, a dot, and possibly a leading sign."

            argparser_translate "Error arg float" "${error_message}" \
                "${option_names}" "${value}"
            error_message="${translation}"
            messages+=("${error_message}")
            return
        elif [[ "${type}" == "int" ]] && ! argparser_is_int "${value}"; then
            # Check if the value is an integer.
            error_message="Error: The argument \"\$1\" is set to \"\$2\", but "
            error_message+="must be an integer, i.e., comprise only digits "
            error_message+="and possibly a leading sign."

            argparser_translate "Error arg int" "${error_message}" \
                "${option_names}" "${value}"
            error_message="${translation}"
            messages+=("${error_message}")
            return
        elif [[ "${type}" == "uint" ]] && ! argparser_is_uint "${value}"; then
            # Check if the value is an unsigned integer.
            error_message="Error: The argument \"\$1\" is set to \"\$2\", but "
            error_message+="must be an unsigned integer, i.e., comprise only "
            error_message+="digits and no sign."

            argparser_translate "Error arg uint" "${error_message}" \
                "${option_names}" "${value}"
            error_message="${translation}"
            messages+=("${error_message}")
            return
        fi
    done

    # Output the checked values.
    argparser_join false "" "" "${values_arr[@]}"
    messages+=("Value: ${joined_array}")
}

function argparser_parse_args() {
    # Parse the script's given arguments and check if they accord to
    # their definition.  Give proper error messages for wrongly set
    # arguments and assign the values to the respective variables.
    # Possibly, create and print a help message.
    #
    # Arguments:
    # - $@: the arguments to parse
    #
    # Nonlocals:
    # - all_arg_groups: the associative array holding the argument
    #   groups (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names
    # - all_short_options: the associative array holding the short
    #   option names
    # - is_self_parsing: whether the Argparser currently parses its own
    #   arguments (read-only)
    # - is_sourced: whether the Argparser has been sourced (read-only)
    #
    # Globals:
    # - ${ARGPARSER_ARG_ARRAY_NAME}: the parsed and checked arguments
    #   with key and value as associative array
    #
    # Environment:
    # - ARGPARSER_ALLOW_ARG_INTERMIXING (read-only)
    # - ARGPARSER_ARG_ARRAY_NAME (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_CHECK_ARG_DEF (read-only)
    # - ARGPARSER_ERROR_EXIT_CODE (read-only)
    # - ARGPARSER_HELP_ARG_GROUP (read-only)
    # - ARGPARSER_SILENCE_ERRORS (read-only)

    # Define the local variables.  If the variable that
    # ${ARGPARSER_ARG_ARRAY_NAME} refers to is undefined, all variables
    # prefixed with "arg" are searched, later.  In order to not shadow
    # them by local variables, all locals starting with "arg" are
    # defined later.
    local -a arg_prefixes
    local error_message
    local -a error_messages
    local given_arg
    local -a given_args
    local -a given_positional_args
    local -A help_message_groups
    local i
    local is_help
    local is_logo
    local is_positional
    local is_positional_only
    local is_usage
    local is_version
    local message
    local -a messages
    local name
    local names
    local prefix
    local -A prefixes
    local translated_error
    local translated_warning
    local translation
    local -A usage_message_groups
    local value
    local values
    local warning_message
    local -a warning_messages

    # Read the arguments.
    given_args=("$@")

    # If the Argparser is run as standalone script and not sourced, read
    # the arguments definition from STDIN into ${args} and remove
    # leading blank lines.  If STDIN is empty, output an error message.
    # If the Argparser is sourced, check if the variable that
    # ${ARGPARSER_ARG_ARRAY_NAME} refers to is defined.  If not, guess
    # how it may be called by searching the set variables for a variable
    # name starting with "arg" to give a clearer error message.  If no
    # such variable name is found, skip that part of the message.
    if [[ "${is_sourced}" == false && "${is_self_parsing}" == false ]]; then
        ARGPARSER_ARG_ARRAY_NAME="args"
        local -a args
        if read -t 0 -u 0; then
            IFS=$'\n' read -r -d "" -t 0.1 -u 0 -a args

            # shellcheck disable=SC2190  # Indexed, not associative array.
            while (( "${#args[@]}" > 0 )) && [[ -z "${args[0]}" ]]; do
                args=("${args[@]:1}")
            done

            if (( "${#args[@]}" == 0 )); then
                error_message="Error: Calling (instead of sourcing) the "
                error_message+="Argparser requires the arguments definition "
                error_message+="to be provided through STDIN, separated by "
                error_message+="newlines.  Either pipe to the Argparser or "
                error_message+="use process substitution to give input.  "
                error_message+="Alternatively, try \"\$1 --help\" to get a "
                error_message+="help message with further information."

                argparser_translate "Error arg array 1" "${error_message}" \
                    "${ARGPARSER_SCRIPT_NAME}"
                error_message="${translation}"

                argparser_print_error_message false true "${error_message}"
            fi
        else
            error_message="Error: Calling (instead of sourcing) the Argparser "
            error_message+="requires the arguments definition to be provided "
            error_message+="through STDIN, separated by newlines.  Either "
            error_message+="pipe to the Argparser or use process substitution "
            error_message+="to give input.  Alternatively, try \"\$1 --help\" "
            error_message+="to get a help message with further information."

            argparser_translate "Error arg array 1" "${error_message}" \
                "${ARGPARSER_SCRIPT_NAME}"
            error_message="${translation}"

            argparser_print_error_message false true "${error_message}"
        fi
    elif [[ ! -v "${ARGPARSER_ARG_ARRAY_NAME}" ]]; then
        mapfile -t names < <(compgen -v)
        for name in "${names[@]}"; do
            if [[ "${name}" == "arg"* ]]; then
                name="${name%%=*}"
                break
            else
                name=""
            fi
        done

        if [[ -n "${name}" ]]; then
            error_message="Error: The variable ARGPARSER_ARG_ARRAY_NAME "
            error_message+="refers to \"\$1\", but this variable is not "
            error_message+="defined.  Either you have given your arguments "
            error_message+="array another name (maybe \"\$2\" -- then change "
            error_message+="ARGPARSER_ARG_ARRAY_NAME accordingly) or you "
            error_message+="forgot defining the array at all (then define it)."

            argparser_translate "Error arg array 2" "${error_message}" \
                "${ARGPARSER_ARG_ARRAY_NAME}"
            error_message="${translation}"
        else
            error_message="Error: The variable ARGPARSER_ARG_ARRAY_NAME "
            error_message+="refers to \"\$1\", but this variable is not "
            error_message+="defined.  Either you have given your arguments "
            error_message+="array another name (then change "
            error_message+="ARGPARSER_ARG_ARRAY_NAME accordingly) or you "
            error_message+="forgot defining the array at all (then define it)."

            argparser_translate "Error arg array 3" "${error_message}" \
                "${ARGPARSER_ARG_ARRAY_NAME}"
            error_message="${translation}"
        fi

        argparser_print_error_message false true "${error_message}"
    fi

    # Define the remaining local variables that start with "arg".
    local arg
    local arg_key
    local arg_number
    local -A arg_numbers
    local -a args_definition_file
    local -a args_definition_script

    # Read in the requested arguments.  ${ARGPARSER_ARG_ARRAY_NAME} is
    # set to the name of the indexed array holding the arguments in the
    # script.  If it is already "args" (the default name), nothing needs
    # to be done, but other variable names need to be mapped to "args"
    # to be able to refer to the variable by name.  Thus, declare prints
    # the array contents stored in the variable
    # ${ARGPARSER_ARG_ARRAY_NAME} refers to, which then gets stripped
    # from the leading assignment (before the equals sign ("=")) and set
    # to the new indexed array ${args}.  Since later, the variable
    # ${ARGPARSER_ARG_ARRAY_NAME} refers to is assigned an associative
    # array, while being an indexed array, unset it.
    if [[ "${ARGPARSER_ARG_ARRAY_NAME}" != "args" ]]; then
        local args
        args="$(declare -p "${ARGPARSER_ARG_ARRAY_NAME}")"
        local -a args="${args#*=}"

        unset "${ARGPARSER_ARG_ARRAY_NAME}"
    fi

    # Read the arguments definition.
    args_definition_file=( )
    args_definition_script=( )
    error_messages=( )

    argparser_translate "Error" "Error"
    translated_error="${translation}"

    argparser_translate "Warning" "Warning"
    translated_warning="${translation}"

    messages=( )
    argparser_read_args_definition "${args[@]}"
    for message in "${messages[@]}"; do
        # Append the arguments definition to those for the file or
        # script, respectively.
        case "${message}" in
            File*) args_definition_file+=("${message#File: }") ;;
            Script*) args_definition_script+=("${message#Script: }") ;;
            ${translated_error}*)
                error_messages+=("${message}")
            ;;
        esac
    done

    # If there are error messages, sort, colorize, and print them, then
    # exit, as parsing the arguments definition with missing parts is
    # useless.
    argparser_print_error_message false true "${error_messages[@]}"

    # Parse the arguments definition.
    all_positional_args=( )
    if (( "${#args_definition_file[@]}" > 0 )); then
        argparser_parse_args_definition "file" "${args_definition_file[@]}"
    fi
    if (( "${#args_definition_script[@]}" > 0 )); then
        argparser_parse_args_definition "script" "${args_definition_script[@]}"
    fi

    # If ${ARGPARSER_CHECK_ARG_DEF} is set to "true", check the
    # consistency of the arguments definition.
    error_messages=( )
    if [[ "${ARGPARSER_CHECK_ARG_DEF}" == true ]]; then
        # Check the arguments definition, first the short and long
        # option names, then the default and choice values.
        argparser_check_args_definition_names
        argparser_check_args_definition_positional_values
        argparser_check_args_definition_option_values

        # If there are error messages, sort, filter, colorize, and print
        # them, then exit, as parsing the arguments with a faulty
        # definition is useless or even impossible.
        argparser_print_error_message true true "${error_messages[@]}"
    fi

    # Possibly, add the help, usage, and version message options to the
    # arguments definition.
    argparser_add_args_definition_help_options

    # Parse the script's given arguments.
    is_logo=false
    is_positional=true
    is_positional_only=false
    error_messages=( )

    unset args
    local -A args

    for given_arg in "${given_args[@]}"; do
        # Parse the argument.
        messages=( )
        argparser_parse_arg "${given_arg}"

        # Read the output message and either set the help, usage, or
        # version message for printing and stop parsing, append the
        # message to the previous error messages or set the argument's
        # value or prefix. In case of arguments given multiple times,
        # i.e., when the key already exists in ${!args[@]}, add the new
        # value or prefix to the previously given ones.
        for message in "${messages[@]}"; do
            case "${message}" in
                ${translated_error}*) error_messages+=("${message}") ;;
                Positional_Start)
                    # Set the flag that the positional-only arguments
                    # delimiter "--" has been set, such that all
                    # following arguments are interpreted as positional.
                    is_positional=true
                    is_positional_only=true
                    ;;
                Positional_End)
                    # Set the flag that the positional-only arguments
                    # delimiter "++" has been set (and thus "--" has
                    # been unset), such that all following arguments are
                    # interpreted as usual.
                    is_positional=true
                    is_positional_only=false
                    ;;
                Argument*)
                    # Set the current argument name, and the first value
                    # to the empty string (by ending it with an
                    # ${ARGPARSER_ARG_DELIMITER_2} character).  This
                    # allows for discerning non-flag arguments given
                    # multiple times, but partly without value.
                    is_positional=false
                    arg_key="${message#Argument: }"
                    if ! argparser_in_array "${arg_key}" "${!args[@]}"; then
                        args[${arg_key}]="${ARGPARSER_ARG_DELIMITER_2}"
                    else
                        args[${arg_key}]+="${ARGPARSER_ARG_DELIMITER_2}"
                    fi
                    arg_numbers[${arg_key}]=0
                    ;;
                Prefix*)
                    # Set the current argument's prefix ("-" or "+").
                    prefix="${message#Prefix: }"
                    if ! argparser_in_array "${arg_key}" "${!prefixes[@]}"
                    then
                        prefixes[${arg_key}]="${prefix}"
                    else
                        prefixes[${arg_key}]+="${ARGPARSER_ARG_DELIMITER_2}"
                        prefixes[${arg_key}]+="${prefix}"
                    fi
                    ;;
                Value*)
                    # Set the current argument's value.  For values to
                    # keyword arguments, merge the value with the
                    # previous empty string value, iff the previous
                    # value is indeed empty.
                    value="${message#Value: }"
                    if [[ "${is_positional}" == true ]]; then
                        # The value is given in a positional-only
                        # location.
                        given_positional_args+=("${value}")
                    elif [[ "${ARGPARSER_ALLOW_ARG_INTERMIXING}" == true ]]
                    then
                        # The value may be either a value to the
                        # previous keyword argument or a positional
                        # argument.  Treat it as positional argument
                        # only if the previous keyword argument has
                        # already taken as many values as required.  For
                        # numerical argument counts, this is directly
                        # this count, for [0, 1] values, this is true
                        # when there is already 1 value, and for
                        # [1, inf) and [0, inf) values, this is never
                        # true since all values shall be taken.  Then,
                        # and in all other cases, treat the value as
                        # value for the previous keyword argument.
                        arg_number="${all_arg_numbers[${arg_key}]}"
                        if [[ "${arg_numbers[${arg_key}]}" == 1 \
                            && "${arg_number}" == "?" ]]
                        then
                            # The value is a positional argument.
                            given_positional_args+=("${value}")
                        elif [[ "${arg_numbers[${arg_key}]}" == "${arg_number}" \
                            && "${arg_number}" != "+" \
                            && "${arg_number}" != "*" ]]
                        then
                            # The value is a positional argument.
                            given_positional_args+=("${value}")
                        elif [[ "${args[${arg_key}]}" \
                            == "${ARGPARSER_ARG_DELIMITER_2}" ]]
                        then
                            # The value is the first value to the
                            # current keyword argument.
                            args[${arg_key}]="${value}"
                            args[${arg_key}]+="${ARGPARSER_ARG_DELIMITER_2}"
                            (( arg_numbers[${arg_key}]++ ))
                        elif (( "${#args[${arg_key}]}" >= 2 )) \
                            && [[ "${args[${arg_key}]: -2}" \
                                == "${ARGPARSER_ARG_DELIMITER_2}${ARGPARSER_ARG_DELIMITER_2}" ]]
                        then
                            # The value is not the first one, but the
                            # previous argument was one of the current
                            # keyword argument's option names, which
                            # added an empty string needing to be
                            # merged.
                            args[${arg_key}]="${args[${arg_key}]::-1}"
                            args[${arg_key}]+="${value}"
                            args[${arg_key}]+="${ARGPARSER_ARG_DELIMITER_2}"
                            (( arg_numbers[${arg_key}]++ ))
                        else
                            # The value is at least on the second place
                            # after one of the current keyword
                            # argument's option names.
                            args[${arg_key}]+="${value}"
                            args[${arg_key}]+="${ARGPARSER_ARG_DELIMITER_2}"
                            (( arg_numbers[${arg_key}]++ ))
                        fi
                    else
                        if [[ "${args[${arg_key}]}" \
                            == "${ARGPARSER_ARG_DELIMITER_2}" ]]
                        then
                            # The value is the first value to the
                            # current keyword argument.
                            args[${arg_key}]="${value}"
                            args[${arg_key}]+="${ARGPARSER_ARG_DELIMITER_2}"
                        elif (( "${#args[${arg_key}]}" >= 2 )) \
                            && [[ "${args[${arg_key}]: -2}" \
                                == "${ARGPARSER_ARG_DELIMITER_2}${ARGPARSER_ARG_DELIMITER_2}" ]]
                        then
                            # The value is not the first one, but the
                            # previous argument was one of the current
                            # keyword argument's option names, which
                            # added an empty string needing to be
                            # merged.
                            args[${arg_key}]="${args[${arg_key}]::-1}"
                            args[${arg_key}]+="${value}"
                            args[${arg_key}]+="${ARGPARSER_ARG_DELIMITER_2}"
                        else
                            # The value is at least on the second place
                            # after one of the current keyword
                            # argument's option names.
                            args[${arg_key}]+="${value}"
                            args[${arg_key}]+="${ARGPARSER_ARG_DELIMITER_2}"
                        fi
                        (( arg_numbers[${arg_key}]++ ))
                    fi
                    ;;
                Logo) is_logo=true ;;
            esac
        done
    done

    # If the help, usage, or version message, or the logo was requested
    # (in this order of priority), print it.  To this end, check whether
    # the respective argument identifier (except for the logo, which was
    # parsed earlier) is given and has a prefix of "-", since "+" should
    # deactivate it.  To respect the priority of help > usage > version,
    # use intermediate variables as flags to be assigned to "true", and
    # check their values afterwards in the intended order (while the
    # associative array ${prefixes[@]} is unordered, just as the
    # command-line arguments may be).
    is_help=false
    is_usage=false
    is_version=false
    for arg_key in "${!prefixes[@]}"; do
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a arg_prefixes \
            <<< "${prefixes[${arg_key}]}"

        for prefix in "${arg_prefixes[@]}"; do
            if [[ "${prefix}" != "-" ]]; then
                continue
            elif [[ "${arg_key}" == "help" ]]; then
                is_help=true
            elif [[ "${arg_key}" == "usage" ]]; then
                is_usage=true
            elif [[ "${arg_key}" == "version" ]]; then
                is_version=true
            fi
        done
    done

    if [[ "${is_help}" == true ]]; then
        argparser_print_help_or_usage_message "help" true 1
    elif [[ "${is_usage}" == true ]]; then
        argparser_print_help_or_usage_message "usage" true 1
    elif [[ "${is_version}" == true ]]; then
        argparser_print_version_message true 1
    elif [[ "${is_logo}" == true ]]; then
        argparser_print_logo
        exit 0
    fi

    # Parse the script's given positional arguments, that are yet only
    # assigned to a single indexed array.
    messages=( )
    argparser_parse_positional_args "${given_positional_args[@]}"

    # Read the output message and either append the message to the
    # previous error messages or set the argument's value.  Again, in
    # case of arguments given multiple times, i.e., when the key already
    # exists in ${!args[@]}, add the new value to the previously given
    # ones.
    for message in "${messages[@]}"; do
        case "${message}" in
            ${translated_error}*) error_messages+=("${message}") ;;
            Argument*) arg_key="${message#Argument: }" ;;
            Value*)
                # Set the current argument's value.
                value="${message#Value: }"
                if ! argparser_in_array "${arg_key}" "${!args[@]}"; then
                    args[${arg_key}]="${value}"
                else
                    args[${arg_key}]+="${ARGPARSER_ARG_DELIMITER_2}"
                    args[${arg_key}]+="${value}"
                fi
                ;;
        esac
    done

    # Sort, filter, colorize, and print all error messages.
    argparser_print_error_message true false "${error_messages[@]}"

    # If any argument was not or wrongly given (i.e., there were
    # errors), print a blank line and the usage message and abort the
    # script.
    if (( "${#error_messages[@]}" > 0 )); then
        if [[ "${ARGPARSER_SILENCE_ERRORS}" == false ]]; then
            {
                printf '\n'
                argparser_print_help_or_usage_message "usage" false 2
            } >&2
        fi
        exit "${ARGPARSER_ERROR_EXIT_CODE}"
    fi

    # Check the arguments' values.
    error_messages=( )
    warning_messages=( )
    for arg_key in "${!all_short_options[@]}" "${all_positional_args[@]}"; do
        # Check which defined argument is given to the script.  Omitted
        # arguments or those without value are assigned the empty string
        # as prefix and/or value. This is then interpreted as hint for
        # the argument's or value's absence.
        if argparser_in_array "${arg_key}" "${!prefixes[@]}"; then
            prefix="${prefixes[${arg_key}]}"
        else
            prefix=""
        fi

        if argparser_in_array "${arg_key}" "${!args[@]}"; then
            values="${args[${arg_key}]}"
        else
            values=""
        fi

        # Check the argument's values.
        messages=( )
        argparser_check_arg_values "${arg_key}" "${prefix}" "${values}"

        # Read the output message and either append the message to the
        # previous error or warning messages or set the argument's
        # values.
        values=""
        for message in "${messages[@]}"; do
            case "${message}" in
                ${translated_error}*) error_messages+=("${message}") ;;
                ${translated_warning}*) warning_messages+=("${message}") ;;
                Value*) values="${message#Value: }" ;;
            esac
        done

        # Assign the checked values to the argument.
        args[${arg_key}]="${values}"
    done

    # Sort, filter, colorize, and print all error and warning messages.
    argparser_print_error_message true false "${error_messages[@]}"
    argparser_print_warning_message true "${warning_messages[@]}"

    # If any argument was not or wrongly given (i.e., there were errors
    # and not just warnings), print a blank line and the usage message
    # and abort the script.
    if (( "${#error_messages[@]}" > 0 )); then
        if [[ "${ARGPARSER_SILENCE_ERRORS}" == false ]]; then
            {
                printf '\n'
                argparser_print_help_or_usage_message "usage" false 2
            } >&2
        fi
        exit "${ARGPARSER_ERROR_EXIT_CODE}"
    fi

    # Remove the help options from the associative array ${args}.
    for arg_key in "${!args[@]}"; do
        if [[
            "${all_arg_groups[${arg_key}]}" == "${ARGPARSER_HELP_ARG_GROUP}"
        ]]
        then
            unset 'args[${arg_key}]'
        fi
    done

    # Copy the values of the associative array ${args} to the variable
    # ${ARGPARSER_ARG_ARRAY_NAME} refers to.  Thereby, declare prints
    # the array contents stored in ${args}, which then gets stripped
    # from the leading assignment (before the equals sign ("=")) and set
    # to the new associative array with the name of
    # ${ARGPARSER_ARG_ARRAY_NAME}.

    # shellcheck disable=SC2178  # Intentional string, not array.
    args="$(declare -p args)"
    declare -g -A "${ARGPARSER_ARG_ARRAY_NAME}"="${args#*=}"

    if [[ "${ARGPARSER_ARG_ARRAY_NAME}" != "args" ]]; then
        unset args
    fi
}

function argparser_set_args() {
    # Set the keyword and positional arguments to global variables.
    #
    # Globals:
    # - ${${ARGPARSER_ARG_ARRAY_NAME}[@]}: the parsed and checked
    #   arguments with key and value as associative array, which
    #   ${ARGPARSER_ARG_ARRAY_NAME} refers to (read-only)
    # - ${!${ARGPARSER_ARG_ARRAY_NAME}[@]}: all argument identifiers
    #   found in ${${ARGPARSER_ARG_ARRAY_NAME}[@]}
    #
    # Environment:
    # - ARGPARSER_ARG_ARRAY_NAME (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_SET_ARRAYS (read-only)

    # Define the local variable.
    local arg_key

    # Get the associative array ${ARGPARSER_ARG_ARRAY_NAME} refers to.
    # If it is already "args" (the default name), nothing needs to be
    # done, but other variable names need to be mapped to "args" to be
    # able to refer to the variable by name.  Thus, declare prints the
    # array contents stored in the variable ${ARGPARSER_ARG_ARRAY_NAME}
    # refers to, which then gets stripped from the leading assignment
    # (before the equals sign ("=")) and set to the new associative
    # array ${args}.
    if [[ "${ARGPARSER_ARG_ARRAY_NAME}" != "args" ]]; then
        local args
        args="$(declare -p "${ARGPARSER_ARG_ARRAY_NAME}")"
        local -A args="${args#*=}"
    fi

    # Set the arguments.
    for arg_key in "${!args[@]}"; do
        if [[ "${args[${arg_key}]}" == *"${ARGPARSER_ARG_DELIMITER_2}"*
            && "${ARGPARSER_SET_ARRAYS}" == true ]]
        then
            # Set the argument, which includes the
            # ${ARGPARSER_ARG_DELIMITER_2} and hence is a sequence of
            # elements, as indexed array variable, while keeping it in
            # ${args} for usage by the calling script.
            declare -g -a "${arg_key}"

            # shellcheck disable=SC2229  # Indirect variable reference.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a "${arg_key}" \
                <<< "${args[${arg_key}]}"
        else
            # Set the argument as variable, while keeping it in ${args}
            # for potential usage by the calling script.
            declare -g "${arg_key}"="${args[${arg_key}]}"
        fi
    done
}

function argparser_write_args() {
    # Write the keyword and positional arguments to STDOUT.
    #
    # Globals:
    # - ${${ARGPARSER_ARG_ARRAY_NAME}[@]}: the parsed and checked
    #   arguments with key and value as associative array, which
    #   ${ARGPARSER_ARG_ARRAY_NAME} refers to (read-only)
    # - ${!${ARGPARSER_ARG_ARRAY_NAME}[@]}: all argument identifiers
    #   found in ${${ARGPARSER_ARG_ARRAY_NAME}[@]}
    #
    # Environment:
    # - ARGPARSER_ARG_ARRAY_NAME (read-only)

    # Define the local variables.
    local arg_key
    local -a args_repr

    # Get the associative array ${ARGPARSER_ARG_ARRAY_NAME} refers to.
    # If it is already "args" (the default name), nothing needs to be
    # done, but other variable names need to be mapped to "args" to be
    # able to refer to the variable by name.  Thus, declare prints the
    # array contents stored in the variable ${ARGPARSER_ARG_ARRAY_NAME}
    # refers to, which then gets stripped from the leading assignment
    # (before the equals sign ("=")) and set to the new associative
    # array ${args}.
    if [[ "${ARGPARSER_ARG_ARRAY_NAME}" != "args" ]]; then
        local args
        args="$(declare -p "${ARGPARSER_ARG_ARRAY_NAME}")"
        local -A args="${args#*=}"
    fi

    # Sort and print the arguments.
    args_repr=( )
    for arg_key in "${!args[@]}"; do
        args_repr+=("${arg_key}=${args[${arg_key}]}")
    done
    argparser_sort false "${args_repr[@]}"
    printf '%s\n' "${sorted_array[@]}"
}

# Define the Argparser functions for creating and printing the help,
# usage, and version messages, as well as for printing error and warning
# messages, and the Argparser logo.
function argparser_create_help_message() {
    # Create a help message for the script's arguments.
    #
    # Nonlocals:
    # - all_arg_groups: the associative array holding the argument
    #   groups (read-only)
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_choice_values: the associative array holding the choice
    #   values (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_help_texts: the associative array holding the help texts
    #   (read-only)
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - all_notes: the associative array holding the notes (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - all_value_names: the associative array holding the value names
    #   (read-only)
    # - help_message_groups: the associative array holding the help
    #   message's groups usable as include directive
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_HELP_ARG_GROUP (read-only)
    # - ARGPARSER_HELP_DESCRIPTION (read-only)
    # - ARGPARSER_HELP_OPTIONS (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_1 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_2 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_3 (read-only)
    # - ARGPARSER_MAX_WIDTH (read-only)
    # - ARGPARSER_POSITIONAL_ARG_GROUP (read-only)
    # - ARGPARSER_SCRIPT_NAME (read-only)
    # - ARGPARSER_USAGE_OPTIONS (read-only)
    # - ARGPARSER_USE_LONG_OPTIONS (read-only)
    # - ARGPARSER_USE_SHORT_OPTIONS (read-only)
    # - ARGPARSER_VERSION_OPTIONS (read-only)

    # Define the local variables.
    local -a all_option_names
    local arg_group
    local -a arg_groups
    local arg_key
    local arg_number
    local choice_values
    local -a col_1
    local -a col_2
    local -a col_3
    local col_width_1
    local col_width_2
    local col_width_3
    local count
    local default_value
    local -a default_values_arr
    local default_values_str
    local has_default_args
    local has_required_args
    local help_message
    local help_text
    local i
    local index
    local is_deprecated
    local is_overlong
    local j
    local joined_words
    local largest_col_width
    local line
    local line_count_1
    local line_count_2
    local line_count_3
    local lines_col_1
    local lines_col_2
    local lines_col_3
    local long_option
    local -a long_options
    local max_col_width_3
    local max_line_count
    local -a new_col_1
    local new_col_1_value
    local -a new_col_2
    local new_col_2_value
    local -a new_col_3
    local new_col_3_value
    local newline_count_1
    local newline_count_2
    local newline_count_3
    local note
    local -a notes
    local -a option_names
    local remark
    local short_option
    local -a short_options
    local -a sorted_array
    local -A sorted_col_1
    local -A sorted_col_2
    local -A sorted_col_3
    local translation
    local type
    local usage
    local -a value_names
    local -a whitespace_1
    local -a whitespace_2
    local whitespace_len_1
    local whitespace_len_2

    # Read the arguments' groups to sort the keyword arguments by group
    # in the help message.  To this end, compare each argument's group
    # later upon iterating over them.
    arg_groups=( )
    for arg_group in "${all_arg_groups[@]}"; do
        if [[ "${arg_group}" != "${ARGPARSER_POSITIONAL_ARG_GROUP}" \
            && "${arg_group}" != "${ARGPARSER_HELP_ARG_GROUP}" ]] \
            && ! argparser_in_array "${arg_group}" "${arg_groups[@]}"
        then
            arg_groups+=("${arg_group}")
        fi
    done

    # The help message is structured in three columns: short options,
    # long options and the help text.  Populate these columns with the
    # entries for each argument.
    col_1=( )
    col_2=( )
    col_3=( )

    has_default_args=false
    has_required_args=false

    # Compute the columns for the positional arguments.
    for arg_key in "${all_positional_args[@]}"; do
        # Read the argument's definition.
        value_names="${all_value_names[${arg_key}]}"
        default_values_str="${all_default_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a default_values_arr \
            <<< "${default_values_str}"
        choice_values="${all_choice_values[${arg_key}]}"
        type="${all_types[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a notes \
            <<< "${all_notes[${arg_key}]}"
        help_text="${all_help_texts[${arg_key}]}"

        # Set a flag whether the argument is deprecated.
        is_deprecated=false
        for note in "${notes[@]}"; do
            if [[ "${note}" == "deprecated" ]]; then
                is_deprecated=true
            fi
        done

        # Define the columns' next line, for the current argument.  The
        # argument may have some default and some choice values or an
        # arbitrary argument number, with the existence of each changing
        # the look of the first or second column (depending on whether
        # there are short options, so the first column may or may not be
        # used).
        if [[ "${ARGPARSER_USE_SHORT_OPTIONS}" == true ]]; then
            # Set the first column's value.
            if [[ "${arg_number}" == "+" || "${arg_number}" == "*" ]]; then
                # [1, inf) or [0, inf) values.
                if [[ -n "${choice_values}" && -n "${default_values_str}" ]]
                then
                    # Choice and default.
                    col_1+=("[${value_names}={${choice_values}}...]")
                elif [[ -n "${choice_values}" ]]; then
                    # Choice only.
                    col_1+=("${value_names}={${choice_values}}...")
                elif [[ -n "${default_values_str}" ]]; then
                    # Default only.
                    col_1+=("[${value_names}...]")
                else
                    # No choice nor default.
                    col_1+=("${value_names}...")
                fi
            else
                # Integer-count or [0, 1] values.
                if [[ -n "${choice_values}" && -n "${default_values_str}" ]]
                then
                    # Choice and default.
                    col_1+=("[${value_names}={${choice_values}}]")
                elif [[ -n "${choice_values}" ]]; then
                    # Choice only.
                    col_1+=("${value_names}={${choice_values}}")
                elif [[ -n "${default_values_str}" ]]; then
                    # Default only.
                    col_1+=("[${value_names}]")
                else
                    # No choice nor default.
                    col_1+=("${value_names}")
                fi
            fi

            # Set the second column's value.
            col_2+=("")
        else
            # Set the first column's value.
            col_1+=("")

            # Set the second column's value.
            if [[ "${arg_number}" == "+" || "${arg_number}" == "*" ]]; then
                # [1, inf) or [0, inf) values.
                if [[ -n "${choice_values}" && -n "${default_values_str}" ]]
                then
                    # Choice and default.
                    col_2+=("[${value_names}={${choice_values}}...]")
                elif [[ -n "${choice_values}" ]]; then
                    # Choice only.
                    col_2+=("${value_names}={${choice_values}}...")
                elif [[ -n "${default_values_str}" ]]; then
                    # Default only.
                    col_2+=("[${value_names}...]")
                else
                    # No choice nor default.
                    col_2+=("${value_names}...")
                fi
            else
                # Integer-count or [0, 1] values.
                if [[ -n "${choice_values}" && -n "${default_values_str}" ]]
                then
                    # Choice and default.
                    col_2+=("[${value_names}={${choice_values}}]")
                elif [[ -n "${choice_values}" ]]; then
                    # Choice only.
                    col_2+=("${value_names}={${choice_values}}")
                elif [[ -n "${default_values_str}" ]]; then
                    # Default only.
                    col_2+=("[${value_names}]")
                else
                    # No choice nor default.
                    col_2+=("${value_names}")
                fi
            fi
        fi

        # Set the third column's value.
        if [[ -n "${default_values_str}" && "${is_deprecated}" == true ]]; then
            # Default and deprecated.
            argparser_translate "Deprecated" "DEPRECATED"
            new_col_3_value="(${translation}) "
            new_col_3_value+="${help_text} ("
            argparser_translate "Default" "default"
            new_col_3_value+="${translation}: "
            if argparser_in_array "${type}" "char" "file" "str"; then
                new_col_3_value+="\""
                for default_value in "${default_values_arr[@]}"; do
                    new_col_3_value+="${default_value},"
                done
                new_col_3_value="${new_col_3_value%,}\""
            else
                new_col_3_value+="${default_values_str}"
            fi
            new_col_3_value+=")"
            col_3+=("${new_col_3_value}")
        elif [[ -n "${default_values_str}" ]]; then
            # Default only.
            new_col_3_value="${help_text} ("
            argparser_translate "Default" "default"
            new_col_3_value+="${translation}: "
            if argparser_in_array "${type}" "char" "file" "str"; then
                new_col_3_value+="\""
                for default_value in "${default_values_arr[@]}"; do
                    new_col_3_value+="${default_value},"
                done
                new_col_3_value="${new_col_3_value%,}\""
            else
                new_col_3_value+="${default_values_str}"
            fi
            new_col_3_value+=")"
            col_3+=("${new_col_3_value}")
        elif [[ "${is_deprecated}" == true ]]; then
            # Deprecated only.
            argparser_translate "Deprecated" "DEPRECATED"
            new_col_3_value="(${translation}) "
            new_col_3_value+="${help_text}"
            col_3+=("${new_col_3_value}")
        else
            # No default nor deprecated.
            col_3+=("${help_text}")
        fi
    done

    # To mark the end of an argument group later upon printing, add an
    # empty line in all three columns.  This cannot appear by chance,
    # whereas empty lines for single columns emerge from the line break
    # insertion when they are differently long.  Thus, a completely
    # empty line can be used as safe argument group delimiter.
    if (( "${#all_positional_args[@]}" > 0 )); then
        col_1+=("")
        col_2+=("")
        col_3+=("")
    fi

    # Compute the columns for the keyword arguments, with the help
    # options last.
    for arg_group in "${arg_groups[@]}" "${ARGPARSER_HELP_ARG_GROUP}"; do
        new_col_1=( )
        new_col_2=( )
        new_col_3=( )
        all_option_names=( )

        for arg_key in "${!all_short_options[@]}"; do
            # Read the argument's group to check whether it belongs to
            # the current group.
            if [[ "${all_arg_groups[${arg_key}]}" != "${arg_group}" ]]; then
                continue
            fi

            # Read the argument's remaining definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
                <<< "${all_short_options[${arg_key}]}"
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
                <<< "${all_long_options[${arg_key}]}"
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a value_names \
                <<< "${all_value_names[${arg_key}]}"
            if [[ "${arg_key}" == "ARGPARSER_ARG_DELIMITER_2" ]]; then
                default_values_arr=("${all_default_values[${arg_key}]}")
            else
                IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a \
                    default_values_arr \
                        <<< "${all_default_values[${arg_key}]}"
            fi
            default_values_str="${all_default_values[${arg_key}]}"
            choice_values="${all_choice_values[${arg_key}]}"
            type="${all_types[${arg_key}]}"
            arg_number="${all_arg_numbers[${arg_key}]}"
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a notes \
                <<< "${all_notes[${arg_key}]}"
            help_text="${all_help_texts[${arg_key}]}"

            # Concatenate the name of all short and long options for the
            # sorting of all arguments, later.
            argparser_get_option_names "${arg_key}" "long-short" false
            all_option_names+=("${option_names}")

            # Set a flag whether the option has default values for
            # adjustment of the help message header, later.
            if [[ "${arg_group}" != "${ARGPARSER_HELP_ARG_GROUP}" ]]; then
                if [[ -n "${default_values_str}" ]]; then
                    has_default_args=true
                else
                    has_required_args=true
                fi
            fi

            # Set a flag whether the option is deprecated.
            is_deprecated=false
            for note in "${notes[@]}"; do
                if [[ "${note}" == "deprecated" ]]; then
                    is_deprecated=true
                fi
            done

            # Define the columns' next line, for the current argument.
            # The argument may have some short and long options, along
            # with value names, some default and some choice values or
            # an arbitrary argument number, with the existence of each
            # changing the look of the respective column.  If either no
            # short or no long option is given, use the empty string
            # instead.
            # Set the first column's value.
            if [[ -z "${short_options[0]}" ]]; then
                # No short option.
                new_col_1_value=""
            elif [[ -z "${long_options[0]}" ]]; then
                # No long option.
                if [[ "${arg_number}" == 0 ]]; then
                    # Flag.
                    if [[ -n "${default_values_str}" ]]; then
                        # Default.
                        new_col_1_value="["
                        for short_option in "${short_options[@]}"; do
                            new_col_1_value+="-${short_option}, "
                        done
                        new_col_1_value="${new_col_1_value%, }"
                        new_col_1_value+="]"
                    else
                        # No default.
                        new_col_1_value=""
                        for short_option in "${short_options[@]}"; do
                            new_col_1_value+="-${short_option}, "
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    fi
                elif [[ "${arg_number}" == "+" ]]; then
                    # [1, inf) values.
                    if [[ -n "${choice_values}" \
                        && -n "${default_values_str}" ]]
                    then
                        # Choice and default.
                        new_col_1_value=""
                        for short_option in "${short_options[@]}"; do
                            new_col_1_value+="[-${short_option}"
                            new_col_1_value+="={${choice_values}}...], "
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    elif [[ -n "${choice_values}" ]]; then
                        # Choice only.
                        new_col_1_value=""
                        for short_option in "${short_options[@]}"; do
                            new_col_1_value+="-${short_option}"
                            new_col_1_value+="={${choice_values}}..., "
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    elif [[ -n "${default_values_str}" ]]; then
                        # Default only.
                        new_col_1_value=""
                        for i in "${!short_options[@]}"; do
                            short_option="${short_options[i]}"
                            new_col_1_value+="[-${short_option}"
                            if [[ -z "${value_names[0]}" ]] \
                                || (( "${#value_names[@]}" < i + 1 ))
                            then
                                short_option="${short_option//-/_}"
                                short_option="${short_option^^}"
                                new_col_1_value+="=${short_option}...], "
                            else
                                new_col_1_value+="=${value_names[i]}...], "
                            fi
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    else
                        # No choice nor default.
                        new_col_1_value=""
                        for i in "${!short_options[@]}"; do
                            short_option="${short_options[i]}"
                            new_col_1_value+="-${short_option}"
                            if [[ -z "${value_names[0]}" ]] \
                                || (( "${#value_names[@]}" < i + 1 ))
                            then
                                short_option="${short_option//-/_}"
                                short_option="${short_option^^}"
                                new_col_1_value+="=${short_option}..., "
                            else
                                new_col_1_value+="=${value_names[i]}..., "
                            fi
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    fi
                elif [[ "${arg_number}" == "*" ]]; then
                    # [0, inf) values.
                    if [[ -n "${choice_values}" \
                        && -n "${default_values_str}" ]]
                    then
                        # Choice and default.
                        new_col_1_value=""
                        for short_option in "${short_options[@]}"; do
                            new_col_1_value+="[-${short_option}"
                            new_col_1_value+="[={${choice_values}}...]], "
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    elif [[ -n "${choice_values}" ]]; then
                        # Choice only.
                        new_col_1_value=""
                        for short_option in "${short_options[@]}"; do
                            new_col_1_value+="-${short_option}"
                            new_col_1_value+="[={${choice_values}}...], "
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    elif [[ -n "${default_values_str}" ]]; then
                        # Default only.
                        new_col_1_value=""
                        for i in "${!short_options[@]}"; do
                            short_option="${short_options[i]}"
                            new_col_1_value+="[-${short_option}"
                            if [[ -z "${value_names[0]}" ]] \
                                || (( "${#value_names[@]}" < i + 1 ))
                            then
                                short_option="${short_option//-/_}"
                                short_option="${short_option^^}"
                                new_col_1_value+="[=${short_option}...]], "
                            else
                                new_col_1_value+="[=${value_names[i]}...]], "
                            fi
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    else
                        # No choice nor default.
                        new_col_1_value=""
                        for i in "${!short_options[@]}"; do
                            short_option="${short_options[i]}"
                            new_col_1_value+="-${short_option}"
                            if [[ -z "${value_names[0]}" ]] \
                                || (( "${#value_names[@]}" < i + 1 ))
                            then
                                short_option="${short_option//-/_}"
                                short_option="${short_option^^}"
                                new_col_1_value+="[=${short_option}...], "
                            else
                                new_col_1_value+="[=${value_names[i]}...], "
                            fi
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    fi
                elif [[ "${arg_number}" == "?" ]]; then
                    # [0, 1] values.
                    if [[ -n "${choice_values}" \
                        && -n "${default_values_str}" ]]
                    then
                        # Choice and default.
                        new_col_1_value=""
                        for short_option in "${short_options[@]}"; do
                            new_col_1_value+="[-${short_option}"
                            new_col_1_value+="[={${choice_values}}]], "
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    elif [[ -n "${choice_values}" ]]; then
                        # Choice only.
                        new_col_1_value=""
                        for short_option in "${short_options[@]}"; do
                            new_col_1_value+="-${short_option}"
                            new_col_1_value+="[={${choice_values}}], "
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    elif [[ -n "${default_values_str}" ]]; then
                        # Default only.
                        new_col_1_value=""
                        for i in "${!short_options[@]}"; do
                            short_option="${short_options[i]}"
                            new_col_1_value+="[-${short_option}"
                            if [[ -z "${value_names[0]}" ]] \
                                || (( "${#value_names[@]}" < i + 1 ))
                            then
                                short_option="${short_option//-/_}"
                                short_option="${short_option^^}"
                                new_col_1_value+="[=${short_option}]], "
                            else
                                new_col_1_value+="[=${value_names[i]}]], "
                            fi
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    else
                        # No choice nor default.
                        new_col_1_value=""
                        for i in "${!short_options[@]}"; do
                            short_option="${short_options[i]}"
                            new_col_1_value+="-${short_option}"
                            if [[ -z "${value_names[0]}" ]] \
                                || (( "${#value_names[@]}" < i + 1 ))
                            then
                                short_option="${short_option//-/_}"
                                short_option="${short_option^^}"
                                new_col_1_value+="[=${short_option}], "
                            else
                                new_col_1_value+="[=${value_names[i]}], "
                            fi
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    fi
                else
                    # Integer-count values.
                    if [[ -n "${choice_values}" \
                        && -n "${default_values_str}" ]]
                    then
                        # Choice and default.
                        new_col_1_value=""
                        for short_option in "${short_options[@]}"; do
                            new_col_1_value+="[-${short_option}"
                            new_col_1_value+="={${choice_values}}], "
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    elif [[ -n "${choice_values}" ]]; then
                        # Choice only.
                        new_col_1_value=""
                        for short_option in "${short_options[@]}"; do
                            new_col_1_value+="-${short_option}"
                            new_col_1_value+="={${choice_values}}, "
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    elif [[ -n "${default_values_str}" ]]; then
                        # Default only.
                        new_col_1_value=""
                        for i in "${!short_options[@]}"; do
                            short_option="${short_options[i]}"
                            new_col_1_value+="[-${short_option}"
                            if [[ -z "${value_names[0]}" ]] \
                                || (( "${#value_names[@]}" < i + 1 ))
                            then
                                short_option="${short_option//-/_}"
                                short_option="${short_option^^}"
                                new_col_1_value+="=${short_option}], "
                            else
                                new_col_1_value+="=${value_names[i]}], "
                            fi
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    else
                        # No choice nor default.
                        new_col_1_value=""
                        for i in "${!short_options[@]}"; do
                            short_option="${short_options[i]}"
                            new_col_1_value+="-${short_option}"
                            if [[ -z "${value_names[0]}" ]] \
                                || (( "${#value_names[@]}" < i + 1 ))
                            then
                                short_option="${short_option//-/_}"
                                short_option="${short_option^^}"
                                new_col_1_value+="=${short_option}, "
                            else
                                new_col_1_value+="=${value_names[i]}, "
                            fi
                        done
                        new_col_1_value="${new_col_1_value%, }"
                    fi
                fi
            elif [[ -n "${default_values_str}" ]]; then
                # Long option, default.
                new_col_1_value="["
                for short_option in "${short_options[@]}"; do
                    new_col_1_value+="-${short_option}, "
                done
                new_col_1_value="${new_col_1_value%, }"
                new_col_1_value+="],"
            else
                # Long option, no default.
                new_col_1_value=""
                for short_option in "${short_options[@]}"; do
                    new_col_1_value+="-${short_option}, "
                done
            fi
            new_col_1+=("${new_col_1_value}")

            # Set the second column's value.
            if [[ -z "${long_options[0]}" ]]; then
                # No long option.
                new_col_2_value=""
            elif [[ "${arg_number}" == 0 ]]; then
                # Flag.
                if [[ -n "${default_values_str}" ]]; then
                    # Default.
                    new_col_2_value="["
                    for long_option in "${long_options[@]}"; do
                        new_col_2_value+="--${long_option}, "
                    done
                    new_col_2_value="${new_col_2_value%, }"
                    new_col_2_value+="]"
                else
                    # No default.
                    new_col_2_value=""
                    for long_option in "${long_options[@]}"; do
                        new_col_2_value+="--${long_option}, "
                    done
                    new_col_2_value="${new_col_2_value%, }"
                fi
            elif [[ "${arg_number}" == "+" ]]; then
                # [1, inf) values.
                if [[ -n "${choice_values}" && -n "${default_values_str}" ]]
                then
                    # Choice and default.
                    new_col_2_value=""
                    for long_option in "${long_options[@]}"; do
                        new_col_2_value+="[--${long_option}"
                        new_col_2_value+="={${choice_values}}...], "
                    done
                    new_col_2_value="${new_col_2_value%, }"
                elif [[ -n "${choice_values}" ]]; then
                    # Choice only.
                    new_col_2_value=""
                    for long_option in "${long_options[@]}"; do
                        new_col_2_value+="--${long_option}"
                        new_col_2_value+="={${choice_values}}..., "
                    done
                    new_col_2_value="${new_col_2_value%, }"
                elif [[ -n "${default_values_str}" ]]; then
                    # Default only.
                    new_col_2_value=""
                    for i in "${!long_options[@]}"; do
                        long_option="${long_options[i]}"
                        new_col_2_value+="[--${long_option}"
                        if [[ -z "${value_names[0]}" ]] \
                            || (( "${#value_names[@]}" < i + 1 ))
                        then
                            long_option="${long_option//-/_}"
                            long_option="${long_option^^}"
                            new_col_2_value+="=${long_option}...], "
                        else
                            new_col_2_value+="=${value_names[i]}...], "
                        fi
                    done
                    new_col_2_value="${new_col_2_value%, }"
                else
                    # No choice nor default.
                    new_col_2_value=""
                    for i in "${!long_options[@]}"; do
                        long_option="${long_options[i]}"
                        new_col_2_value+="--${long_option}"
                        if [[ -z "${value_names[0]}" ]] \
                            || (( "${#value_names[@]}" < i + 1 ))
                        then
                            long_option="${long_option//-/_}"
                            long_option="${long_option^^}"
                            new_col_2_value+="=${long_option}..., "
                        else
                            new_col_2_value+="=${value_names[i]}..., "
                        fi
                    done
                    new_col_2_value="${new_col_2_value%, }"
                fi
            elif [[ "${arg_number}" == "*" ]]; then
                # [0, inf) values.
                if [[ -n "${choice_values}" && -n "${default_values_str}" ]]
                then
                    # Choice and default.
                    new_col_2_value=""
                    for long_option in "${long_options[@]}"; do
                        new_col_2_value+="[--${long_option}"
                        new_col_2_value+="[={${choice_values}}...]], "
                    done
                    new_col_2_value="${new_col_2_value%, }"
                elif [[ -n "${choice_values}" ]]; then
                    # Choice only.
                    new_col_2_value=""
                    for long_option in "${long_options[@]}"; do
                        new_col_2_value+="--${long_option}"
                        new_col_2_value+="={${choice_values}}...], "
                    done
                    new_col_2_value="${new_col_2_value%, }"
                elif [[ -n "${default_values_str}" ]]; then
                    # Default only.
                    new_col_2_value=""
                    for i in "${!long_options[@]}"; do
                        long_option="${long_options[i]}"
                        new_col_2_value+="[--${long_option}"
                        if [[ -z "${value_names[0]}" ]] \
                            || (( "${#value_names[@]}" < i + 1 ))
                        then
                            long_option="${long_option//-/_}"
                            long_option="${long_option^^}"
                            new_col_2_value+="[=${long_option}...]], "
                        else
                            new_col_2_value+="[=${value_names[i]}...]], "
                        fi
                    done
                    new_col_2_value="${new_col_2_value%, }"
                else
                    # No choice nor default.
                    new_col_2_value=""
                    for i in "${!long_options[@]}"; do
                        long_option="${long_options[i]}"
                        new_col_2_value+="--${long_option}"
                        if [[ -z "${value_names[0]}" ]] \
                            || (( "${#value_names[@]}" < i + 1 ))
                        then
                            long_option="${long_option//-/_}"
                            long_option="${long_option^^}"
                            new_col_2_value+="[=${long_option}...], "
                        else
                            new_col_2_value+="[=${value_names[i]}...], "
                        fi
                    done
                    new_col_2_value="${new_col_2_value%, }"
                fi
            elif [[ "${arg_number}" == "?" ]]; then
                # [0, 1] values.
                if [[ -n "${choice_values}" && -n "${default_values_str}" ]]
                then
                    # Choice and default.
                    new_col_2_value=""
                    for long_option in "${long_options[@]}"; do
                        new_col_2_value+="[--${long_option}"
                        new_col_2_value+="[={${choice_values}}]], "
                    done
                    new_col_2_value="${new_col_2_value%, }"
                elif [[ -n "${choice_values}" ]]; then
                    # Choice only.
                    new_col_2_value=""
                    for long_option in "${long_options[@]}"; do
                        new_col_2_value+="--${long_option}"
                        new_col_2_value+="[={${choice_values}}], "
                    done
                    new_col_2_value="${new_col_2_value%, }"
                elif [[ -n "${default_values_str}" ]]; then
                    # Default only.
                    new_col_2_value=""
                    for i in "${!long_options[@]}"; do
                        long_option="${long_options[i]}"
                        new_col_2_value+="[--${long_option}"
                        if [[ -z "${value_names[0]}" ]] \
                            || (( "${#value_names[@]}" < i + 1 ))
                        then
                            long_option="${long_option//-/_}"
                            long_option="${long_option^^}"
                            new_col_2_value+="[=${long_option}]], "
                        else
                            new_col_2_value+="[=${value_names[i]}]], "
                        fi
                    done
                    new_col_2_value="${new_col_2_value%, }"
                else
                    # No choice nor default.
                    new_col_2_value=""
                    for i in "${!long_options[@]}"; do
                        long_option="${long_options[i]}"
                        new_col_2_value+="--${long_option}"
                        if [[ -z "${value_names[0]}" ]] \
                            || (( "${#value_names[@]}" < i + 1 ))
                        then
                            long_option="${long_option//-/_}"
                            long_option="${long_option^^}"
                            new_col_2_value+="[=${long_option}], "
                        else
                            new_col_2_value+="[=${value_names[i]}], "
                        fi
                    done
                    new_col_2_value="${new_col_2_value%, }"
                fi
            else
                # Integer-count values.
                if [[ -n "${choice_values}" && -n "${default_values_str}" ]]
                then
                    # Choice and default.
                    new_col_2_value=""
                    for long_option in "${long_options[@]}"; do
                        new_col_2_value+="[--${long_option}={${choice_values}}], "
                    done
                    new_col_2_value="${new_col_2_value%, }"
                elif [[ -n "${choice_values}" ]]; then
                    # Choice only.
                    new_col_2_value=""
                    for long_option in "${long_options[@]}"; do
                        new_col_2_value+="--${long_option}={${choice_values}}, "
                    done
                    new_col_2_value="${new_col_2_value%, }"
                elif [[ -n "${default_values_str}" ]]; then
                    # Default only.
                    new_col_2_value=""
                    for i in "${!long_options[@]}"; do
                        long_option="${long_options[i]}"
                        new_col_2_value+="[--${long_option}"
                        if [[ -z "${value_names[0]}" ]] \
                            || (( "${#value_names[@]}" < i + 1 ))
                        then
                            long_option="${long_option//-/_}"
                            long_option="${long_option^^}"
                            new_col_2_value+="=${long_option}], "
                        else
                            new_col_2_value+="=${value_names[i]}], "
                        fi
                    done
                    new_col_2_value="${new_col_2_value%, }"
                else
                    # No choice nor default.
                    new_col_2_value=""
                    for i in "${!long_options[@]}"; do
                        long_option="${long_options[i]}"
                        new_col_2_value+="--${long_option}"
                        if [[ -z "${value_names[0]}" ]] \
                            || (( "${#value_names[@]}" < i + 1 ))
                        then
                            long_option="${long_option//-/_}"
                            long_option="${long_option^^}"
                            new_col_2_value+="=${long_option}, "
                        else
                            new_col_2_value+="=${value_names[i]}, "
                        fi
                    done
                    new_col_2_value="${new_col_2_value%, }"
                fi
            fi
            new_col_2+=("${new_col_2_value}")

            # Set the third column's value.
            if [[ "${arg_number}" == 0 && "${is_deprecated}" == true ]]; then
                # Flag and deprecated.
                argparser_translate "Deprecated" "DEPRECATED"
                new_col_3_value="(${translation}) "
                new_col_3_value+="${help_text} ("
                argparser_translate "Default" "default"
                new_col_3_value+="${translation}: "
                argparser_translate "${default_values_str}" \
                    "${default_values_str}"
                new_col_3_value+="${translation})"
            elif [[ "${arg_number}" == 0 ]]; then
                # Flag only.
                new_col_3_value="${help_text} ("
                argparser_translate "Default" "default"
                new_col_3_value+="${translation}: "
                argparser_translate "${default_values_str}" \
                    "${default_values_str}"
                new_col_3_value+="${translation})"
            elif [[ -n "${default_values_str}" && "${is_deprecated}" == true ]]
            then
                # Default and deprecated.
                argparser_translate "Deprecated" "DEPRECATED"
                new_col_3_value="(${translation}) "
                new_col_3_value+="${help_text} ("
                argparser_translate "Default" "default"
                new_col_3_value+="${translation}: "
                if argparser_in_array "${type}" "char" "file" "str"; then
                    new_col_3_value+="\""
                    for default_value in "${default_values_arr[@]}"; do
                        new_col_3_value+="${default_value},"
                    done
                    new_col_3_value="${new_col_3_value%,}\""
                else
                    new_col_3_value+="${default_values_str}"
                fi
                new_col_3_value+=")"
            elif [[ -n "${default_values_str}" ]]; then
                # Default only.
                new_col_3_value="${help_text} ("
                argparser_translate "Default" "default"
                new_col_3_value+="${translation}: "
                if argparser_in_array "${type}" "char" "file" "str"; then
                    new_col_3_value+="\""
                    for default_value in "${default_values_arr[@]}"; do
                        new_col_3_value+="${default_value},"
                    done
                    new_col_3_value="${new_col_3_value%,}\""
                else
                    new_col_3_value+="${default_values_str}"
                fi
                new_col_3_value+=")"
            elif [[ "${is_deprecated}" == true ]]; then
                # Deprecated only.
                argparser_translate "Deprecated" "DEPRECATED"
                new_col_3_value="(${translation}) "
                new_col_3_value+="${help_text}"
            else
                # No default nor deprecated.
                new_col_3_value="${help_text}"
            fi
            new_col_3+=("${new_col_3_value}")
        done

        # Sort the arguments by the option names.  To this end, three
        # associative arrays are defined that use the option names as
        # keys and the first, second, or third column's values as
        # values.  Then, the option names' indexed array gets sorted and
        # the indexed arrays for the first, second, and third columns
        # are re-populated using the values from the associative array,
        # such that the sorted option names define the order of the yet
        # unsorted columns.  As a consequence, all columns are sorted as
        # if they would have been sorted together (which appears not be
        # feasible).
        for i in "${!all_option_names[@]}"; do
            sorted_col_1[${all_option_names[i]}]="${new_col_1[i]}"
            sorted_col_2[${all_option_names[i]}]="${new_col_2[i]}"
            sorted_col_3[${all_option_names[i]}]="${new_col_3[i]}"
        done

        argparser_sort false "${all_option_names[@]}"
        all_option_names=("${sorted_array[@]}")

        for i in "${!all_option_names[@]}"; do
            col_1+=("${sorted_col_1[${all_option_names[i]}]}")
            col_2+=("${sorted_col_2[${all_option_names[i]}]}")
            col_3+=("${sorted_col_3[${all_option_names[i]}]}")
        done

        # To mark the end of an argument group later upon printing, add
        # an empty line in all three columns.  This cannot appear by
        # chance, whereas empty lines for single columns emerge from the
        # line break insertion when they are differently long.  Thus, a
        # completely empty line can be used as safe argument group
        # delimiter.
        col_1+=("")
        col_2+=("")
        col_3+=("")
    done

    # Limit the width of the first two columns of the help message to
    # ${ARGPARSER_MAX_COL_WIDTH_*}, and of the third column to
    # ${ARGPARSER_MAX_WIDTH} or ${ARGPARSER_MAX_COL_WIDTH_3} (if given)
    # by inserting line breaks.
    # Split the element of column 1.
    col_width_1=0
    for i in "${!col_1[@]}"; do
        argparser_fold "${col_1[i]}" "${ARGPARSER_MAX_COL_WIDTH_1}" \
            "${col_width_1}"
        col_1[i]="${joined_words}"
        col_width_1="${largest_col_width}"
    done

    # Split the element of column 2.
    col_width_2=0
    for i in "${!col_2[@]}"; do
        argparser_fold "${col_2[i]}" "${ARGPARSER_MAX_COL_WIDTH_2}" \
            "${col_width_2}"
        col_2[i]="${joined_words}"
        col_width_2="${largest_col_width}"
    done

    # Split the element of column 3.
    if (( ARGPARSER_MAX_COL_WIDTH_3 == 0 )); then
        if (( col_width_1 > 0 && col_width_2 > 0 )); then
            (( max_col_width_3 = ARGPARSER_MAX_WIDTH - col_width_1 \
                - col_width_2 - 2 ))
        elif (( col_width_1 > 0 )); then
            (( max_col_width_3 = ARGPARSER_MAX_WIDTH - col_width_1 - 1 ))
        elif (( col_width_2 > 0 )); then
            (( max_col_width_3 = ARGPARSER_MAX_WIDTH - col_width_2 - 1 ))
        else
            (( max_col_width_3 = ARGPARSER_MAX_WIDTH ))
        fi
    else
        max_col_width_3="${ARGPARSER_MAX_COL_WIDTH_3}"
    fi

    col_width_3=0
    for i in "${!col_3[@]}"; do
        argparser_fold "${col_3[i]}" "${max_col_width_3}" "${col_width_3}"
        col_3[i]="${joined_words}"
        col_width_3="${largest_col_width}"
    done

    # Adjust the number of line breaks between each column's rows, such
    # that each element shares the same number of rows.
    for i in "${!col_1[@]}"; do
        # Count the number of rows for each element.
        mapfile -t lines_col_1 <<< "${col_1[i]}"
        line_count_1="${#lines_col_1[@]}"

        mapfile -t lines_col_2 <<< "${col_2[i]}"
        line_count_2="${#lines_col_2[@]}"

        mapfile -t lines_col_3 <<< "${col_3[i]}"
        line_count_3="${#lines_col_3[@]}"

        # Get the largest line count.
        if (( line_count_1 >= line_count_2 )); then
            if (( line_count_1 >= line_count_3 )); then
                max_line_count="${line_count_1}"
            else
                max_line_count="${line_count_3}"
            fi
        else
            if (( line_count_2 >= line_count_3 )); then
                max_line_count="${line_count_2}"
            else
                max_line_count="${line_count_3}"
            fi
        fi

        # Set the number of required line breaks to align each line.  If
        # the line count is 0, 1 is subtracted from the maximum line
        # count, such that the last line does not end in a line break.
        # The same holds true for a line count of greater than 0, where
        # normally 1 would have to be added.  This trailing newline
        # character gets added by the here string upon re-reading the
        # arrays, below.
        if (( line_count_1 == 0 )); then
            (( newline_count_1 = max_line_count - 1 ))
        else
            (( newline_count_1 = max_line_count - line_count_1 ))
        fi

        if (( line_count_2 == 0 )); then
            (( newline_count_2 = max_line_count - 1 ))
        else
            (( newline_count_2 = max_line_count - line_count_2 ))
        fi

        if (( line_count_3 == 0 )); then
            (( newline_count_3 = max_line_count - 1 ))
        else
            (( newline_count_3 = max_line_count - line_count_3 ))
        fi

        # To each element, add as many line breaks as computed.
        for (( j = 0; j < newline_count_1; j++ )); do
            col_1[i]+=$'\n'
        done

        for (( j = 0; j < newline_count_2; j++ )); do
            col_2[i]+=$'\n'
        done

        for (( j = 0; j < newline_count_3; j++ )); do
            col_3[i]+=$'\n'
        done
    done

    # Re-read in the columns' lines, such that each line makes up one
    # element of the array.  To this end, split the lines on newline
    # characters (that get stripped off the lines).  The here string
    # adds a trailing newline that acts as additional delimiter.  Else,
    # a line without line break would give the same number of lines
    # (one) as a line with one line break as trailing newline, since
    # line breaks act as trailing delimiters for mapfile, not as inner
    # separators.
    new_col_1=( )
    new_col_2=( )
    new_col_3=( )
    for i in "${!col_1[@]}"; do
        mapfile -t -O "${#new_col_1[@]}" new_col_1 <<< "${col_1[i]}"
        mapfile -t -O "${#new_col_2[@]}" new_col_2 <<< "${col_2[i]}"
        mapfile -t -O "${#new_col_3[@]}" new_col_3 <<< "${col_3[i]}"
    done

    # Store the lines back in the original columns' variables.
    col_1=("${new_col_1[@]}")
    col_2=("${new_col_2[@]}")
    col_3=("${new_col_3[@]}")

    # For proper alignment of the columns, whitespace must be used as
    # separation between shorter elements.  Compute the width for both
    # the first and the second column.  If a line is wider, set the
    # width to the respective value, as long as the width doesn't exceed
    # the limit set by ${ARGPARSER_MAX_COL_WIDTH_*}.
    col_width_1=0
    col_width_2=0
    for i in "${!col_1[@]}"; do
        if (( "${#col_1[i]}" <= ARGPARSER_MAX_COL_WIDTH_1 \
            && "${#col_1[i]}" > col_width_1 ))
        then
            col_width_1="${#col_1[i]}"
        fi

        if (( "${#col_2[i]}" <= ARGPARSER_MAX_COL_WIDTH_2 \
            && "${#col_2[i]}" > col_width_2 ))
        then
            col_width_2="${#col_2[i]}"
        fi
    done

    # Compute the length of whitespace between column 1 and 2, as well
    # as between column 2 and 3.  This length equals the column's
    # maximum width minus the current line's element's length plus 1 to
    # have at least one space as separation.  If the column width
    # exceeds the limit set by ${ARGPARSER_MAX_COL_WIDTH_*}, insert a
    # line break instead to make the following column's content begin on
    # the next line.  Then, insert as much whitespace as needed to align
    # the column with the other elements.  For column 1, this equals the
    # column's maximum width plus 1 (the mandatory separation), for
    # column 2, both columns' maximum widths plus 2 (twice the mandatory
    # separation).  If the first column is too long, but the second one
    # (which is used) empty and fits the remainder of the first column's
    # content, write in the second column instead of breaking the line.
    whitespace_1=( )
    whitespace_2=( )
    for i in "${!col_1[@]}"; do
        whitespace_1+=("")
        whitespace_2+=("")
        is_overlong=false

        # Set the first column's width.
        if (( "${#col_1[i]}" <= ARGPARSER_MAX_COL_WIDTH_1 )); then
            if [[ "${ARGPARSER_USE_SHORT_OPTIONS}" == true ]]; then
                (( whitespace_len_1 = col_width_1 - "${#col_1[i]}" + 1 ))
            else
                (( whitespace_len_1 = col_width_1 - "${#col_1[i]}" ))
            fi
        elif [[ -z "${col_2[i]}" ]] \
            && (( "${#col_1[i]}" <= ARGPARSER_MAX_COL_WIDTH_1 + col_width_2 ))
        then
            is_overlong=true
            whitespace_len_1=0
        else
            if [[ "${ARGPARSER_USE_SHORT_OPTIONS}" == true ]]; then
                (( whitespace_len_1 = col_width_1 + 1 ))
            else
                (( whitespace_len_1 = col_width_1 ))
            fi
            whitespace_1[-1]+=$'\n'
        fi

        for (( j = 0; j < whitespace_len_1; j++ )); do
            whitespace_1[-1]+=" "
        done

        # Set the second column's width.
        if [[ "${is_overlong}" == true ]]; then
            if [[ "${ARGPARSER_USE_LONG_OPTIONS}" == true ]]; then
                (( whitespace_len_2 = col_width_1 + col_width_2 \
                    - "${#col_1[i]}" + 2 ))
            else
                (( whitespace_len_2 = col_width_1 + col_width_2 \
                    - "${#col_1[i]}" + 1 ))
            fi
        elif (( "${#col_2[i]}" <= ARGPARSER_MAX_COL_WIDTH_2 )); then
            if [[ "${ARGPARSER_USE_LONG_OPTIONS}" == true ]]; then
                (( whitespace_len_2 = col_width_2 - "${#col_2[i]}" + 1 ))
            else
                (( whitespace_len_2 = col_width_2 - "${#col_2[i]}" ))
            fi
        else
            if [[ "${ARGPARSER_USE_SHORT_OPTIONS}" == true \
                && "${ARGPARSER_USE_LONG_OPTIONS}" == true ]]
            then
                (( whitespace_len_2 = col_width_1 + col_width_2 + 2 ))
            else
                (( whitespace_len_2 = col_width_1 + col_width_2 + 1 ))
            fi
            whitespace_2[-1]+=$'\n'
        fi

        for (( j = 0; j < whitespace_len_2; j++ )); do
            whitespace_2[-1]+=" "
        done
    done

    # Set the help message's usage line, including the script's name.
    argparser_translate "Usage" "Usage"
    usage="${translation}: ${ARGPARSER_SCRIPT_NAME}"

    # Add a hint for the optional keyword arguments (as summary), if
    # existing.
    if [[ "${has_default_args}" == true ]]; then
        argparser_translate "Options" "OPTIONS"
        usage+=" [${translation}]"
    fi

    # Add a hint for the mandatory keyword arguments (as summary), if
    # existing.
    if [[ "${has_required_args}" == true ]]; then
        argparser_translate "Arguments" "ARGUMENTS"
        usage+=" ${translation}"
    fi

    # Add the names of the positional arguments, if existing.
    if (( "${#all_positional_args[@]}" > 0 )); then
        if [[ "${has_required_args}" == true ]]; then
            usage+=" --"
        elif [[ "${has_default_args}" == true ]]; then
            usage+=" [--]"
        fi

        for arg_key in "${all_positional_args[@]}"; do
            value_names=("${all_value_names[${arg_key}]}")
            default_values_str="${all_default_values[${arg_key}]}"

            if [[ -n "${default_values_str}" ]]; then
                usage+=" [${value_names[0]}]"
            else
                usage+=" ${value_names[0]}"
            fi
        done
    fi

    usage+=$'\n'
    help_message_groups["Usage"]="${usage}"

    # Set the description.
    if [[ -n "${ARGPARSER_HELP_DESCRIPTION}" ]]; then
        description="${ARGPARSER_HELP_DESCRIPTION}"
        argparser_fold "${description}" "${ARGPARSER_MAX_WIDTH}" 0
        description="${joined_words}"
        description+=$'\n'
    else
        description=""
    fi
    help_message_groups["Description"]="${description}"

    # Set the remark.
    remark="Mandatory arguments to long options are mandatory for short "
    remark+="options too."

    argparser_translate "Mandatory arguments" "${remark}"
    remark="${translation}"
    remark+=$'\n'
    help_message_groups["Remark"]="${remark}"

    # Set the argument groups for printing.  If there are positional
    # arguments, include the positional argument group as first one.  If
    # there are keyword arguments, add them afterwards.  Finally, add
    # the help options' group, if existing.
    if (( "${#all_positional_args[@]}" > 0 )); then
        arg_groups=("${ARGPARSER_POSITIONAL_ARG_GROUP}" "${arg_groups[@]}")
    fi

    if [[ "${ARGPARSER_ADD_HELP}" == true \
        || "${ARGPARSER_ADD_USAGE}" == true \
        || "${ARGPARSER_ADD_VERSION}" == true ]]
    then
        arg_groups+=("${ARGPARSER_HELP_ARG_GROUP}")
    fi

    # For each argument group, print its arguments.
    index=0
    for arg_group in "${arg_groups[@]}"; do
        # For any argument line, output the three columns and their
        # delimiting whitespace.  If all three columns are empty, the
        # end of the current argument group has been reached.
        help_message=""
        for (( i = index; i < "${#col_1[@]}"; i++ )); do
            if [[ -z "${col_1[i]}" && -z "${col_2[i]}" && -z "${col_3[i]}" ]]
            then
                break
            fi

            line="${col_1[i]}${whitespace_1[i]}"
            line+="${col_2[i]}${whitespace_2[i]}"
            line+="${col_3[i]}"

            line="${line%%+( )}"
            line+=$'\n'
            help_message+="${line}"
        done
        help_message_groups[${arg_group}]="${help_message}"

        # Set the start index for the next argument group to the current
        # group's end index plus 1 (with the latter being the empty line
        # used as argument group delimiter).
        (( index = i + 1 ))
    done
}

function argparser_create_usage_message() {
    # Create a usage message for the script's arguments.
    #
    # Nonlocals:
    # - all_arg_groups: the associative array holding the argument
    #   groups (read-only)
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_choice_values: the associative array holding the choice
    #   values (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - all_value_names: the associative array holding the value names
    #   (read-only)
    # - styles: the associative array containing the styles
    # - usage_message_groups: the associative array holding the usage
    #   message's groups usable as include directive
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_HELP_ARG_GROUP (read-only)
    # - ARGPARSER_HELP_OPTIONS (read-only)
    # - ARGPARSER_SCRIPT_NAME (read-only)
    # - ARGPARSER_USAGE_MESSAGE_OPTION_TYPE(read-only)
    # - ARGPARSER_USAGE_MESSAGE_ORIENTATION (read-only)
    # - ARGPARSER_USAGE_OPTIONS (read-only)
    # - ARGPARSER_USE_LONG_OPTIONS (read-only)
    # - ARGPARSER_USE_SHORT_OPTIONS (read-only)
    # - ARGPARSER_VERSION_OPTIONS (read-only)

    # Define the local variables.
    local arg_key
    local arg_number
    local caption
    local choice_values_arr
    local choice_values_str
    local default_values
    local header
    local header_width
    local -a help_option_args
    local help_options
    local i
    local line
    local -a lines
    local long_option
    local -a long_option_default_args
    local -a long_option_required_args
    local long_options
    local -a positional_default_args
    local -a positional_required_args
    local option_names
    local script_name
    local short_option
    local -a short_option_default_args
    local -a short_option_required_args
    local short_options_arr
    local short_options_str
    local -a sorted_array
    local translation
    local usage_message
    local value_name
    local value_names_arr
    local value_names_str
    local whitespace

    # Output the usage message's header, giving the script's name and
    # the existence of the help, usage, and version arguments.  For the
    # computation of the whitespace below, set the header width to the
    # width of the uncolored strings.
    argparser_translate "Usage" "Usage"
    argparser_colorize "${styles["usage_caption"]}" "${translation}" 1 caption
    argparser_colorize "${styles["script_name"]}" "${ARGPARSER_SCRIPT_NAME}" \
        1 script_name
    header="${caption}: ${script_name}"
    (( header_width = "${#translation}" + "${#ARGPARSER_SCRIPT_NAME}" + 2 ))
    usage_message="${header}"

    # Get the help options and sort them by the argument identifier,
    # such that the order is always "help", "usage", "version".
    help_option_args=( )
    for arg_key in "${!all_short_options[@]}"; do
        if [[
            "${all_arg_groups[${arg_key}]}" == "${ARGPARSER_HELP_ARG_GROUP}"
        ]]
        then
            help_option_args+=("${arg_key}")
        fi
    done

    if (( "${#help_option_args[@]}" > 0 )); then
        argparser_sort false "${help_option_args[@]}"
        help_option_args=("${sorted_array[@]}")
    fi

    # Concatenate the short or long option names of each help option.
    help_options=""
    for arg_key in "${help_option_args[@]}"; do
        # Separate the help options' names by pipes.
        if [[ -n "${help_options}" ]]; then
            help_options+=" | "
        fi

        # Set the help options' names.
        if [[ ("${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" == "short" \
                && "${ARGPARSER_USE_SHORT_OPTIONS}" == true) \
            || "${ARGPARSER_USE_LONG_OPTIONS}" == false ]]
        then
            argparser_get_option_names "${arg_key}" "short" true
            help_options+="${option_names}"
        elif [[ ("${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" == "long" \
                && "${ARGPARSER_USE_LONG_OPTIONS}" == true) \
            || "${ARGPARSER_USE_SHORT_OPTIONS}" == false ]]
        then
            argparser_get_option_names "${arg_key}" "long" true
            help_options+="${option_names}"
        fi
    done

    # Add the help options to the usage message.
    if [[ -n "${help_options}" ]]; then
        usage_message+=" [${help_options}]"
    fi

    # To keep all arguments aligned in columnar output, compute the
    # length of the script name and the (translated) leading "Usage: ".
    # For a row-like orientation, only use one space.
    if [[ "${ARGPARSER_USAGE_MESSAGE_ORIENTATION}" == "column" ]]; then
        printf -v whitespace '%*s' "${header_width}" ""
        whitespace=$'\n '"${whitespace}"
    else
        whitespace=" "
    fi

    # If ${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE} is set to "short",
    # separate keyword arguments with default values from those without
    # to output first the arguments with default values and afterwards
    # those without.  Within either block, separate arguments with short
    # options from those without to output first the arguments with
    # short option names and then those with only long option names.  If
    # ${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE} is set to "long", do the
    # same for the long options and short option-only arguments.  In
    # both cases, having both short and long option names does not
    # matter as only one sort gets printed.
    short_option_default_args=( )
    short_option_required_args=( )
    long_option_default_args=( )
    long_option_required_args=( )
    if [[ "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" == "short" ]]; then
        for arg_key in "${!all_short_options[@]}"; do
            # Skip the help options.
            if [[ "${all_arg_groups[${arg_key}]}" \
                == "${ARGPARSER_HELP_ARG_GROUP}" ]]
            then
                continue
            fi

            # Read the argument's definition.
            short_options_str="${all_short_options[${arg_key}]}"
            default_values="${all_default_values[${arg_key}]}"

            # Add the argument to the respective array.
            if [[ -z "${default_values}" ]]; then
                if [[ -z "${short_options_str}" ]]; then
                    long_option_required_args+=("${arg_key}")
                else
                    short_option_required_args+=("${arg_key}")
                fi
            else
                if [[ -z "${short_options_str}" ]]; then
                    long_option_default_args+=("${arg_key}")
                else
                    short_option_default_args+=("${arg_key}")
                fi
            fi
        done
    else
        for arg_key in "${!all_short_options[@]}"; do
            # Skip the help options.
            if [[ "${all_arg_groups[${arg_key}]}" \
                == "${ARGPARSER_HELP_ARG_GROUP}" ]]
            then
                continue
            fi

            # Read the argument's definition.
            long_options="${all_long_options[${arg_key}]}"
            default_values="${all_default_values[${arg_key}]}"

            # Add the argument to the respective array.
            if [[ -z "${default_values}" ]]; then
                if [[ -z "${long_options}" ]]; then
                    short_option_required_args+=("${arg_key}")
                else
                    long_option_required_args+=("${arg_key}")
                fi
            else
                if [[ -z "${long_options}" ]]; then
                    short_option_default_args+=("${arg_key}")
                else
                    long_option_default_args+=("${arg_key}")
                fi
            fi
        done
    fi

    # Likewise, separate positional arguments with default values from
    # those without.
    positional_default_args=( )
    positional_required_args=( )
    for arg_key in "${all_positional_args[@]}"; do
        # Read the argument's definition.
        default_values="${all_default_values[${arg_key}]}"

        # Add the argument to the respective array.
        if [[ -z "${default_values}" ]]; then
            positional_required_args+=("${arg_key}")
        else
            positional_default_args+=("${arg_key}")
        fi
    done

    # Output each keyword argument with short options and default values
    # and sort them alphabetically.
    lines=( )
    for arg_key in "${short_option_default_args[@]}"; do
        # Read the argument's definition.
        short_options_str="${all_short_options[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options_arr \
            <<< "${short_options_str}"
        value_names_str="${all_value_names[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a value_names_arr \
            <<< "${value_names_str}"
        choice_values_str="${all_choice_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values_arr \
            <<< "${choice_values_str}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # If no value name is given, set them to the capitalized short
        # option names.
        if [[ -z "${value_names_str}" ]]; then
            value_names_arr=( )
            for short_option in "${short_options_arr[@]}"; do
                value_name="${short_option//-/_}"
                value_names_arr+=("${value_name^^}")
            done
        fi

        # Concatenate and colorize the short option names, value names,
        # and choice values.
        argparser_get_option_names "${arg_key}" "short" true
        short_options_str="${option_names}"

        argparser_join true "${styles["value_names"]}" 1 \
            "${value_names_arr[@]}"
        value_names_str="${joined_array}"

        argparser_join true "${styles["choice_values"]}" 1 \
            "${choice_values_arr[@]}"
        choice_values_str="${joined_array}"

        # Define the line for the current argument.  The argument has
        # some short options, default values, and possibly choice
        # values, and a variable argument number, with each property
        # changing the look of the line.
        if [[ "${arg_number}" == 0 ]]; then
            # Flag.
            lines+=("[${short_options_str}]")
        elif [[ "${arg_number}" == "+" ]]; then
            # [1, inf) values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice and default.
                lines+=("[${short_options_str}={${choice_values_str}}...]")
            else
                # Default only.
                lines+=("[${short_options_str}=${value_names_str}...]")
            fi
        elif [[ "${arg_number}" == "*" ]]; then
            # [0, inf) values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice and default.
                lines+=("[${short_options_str}[={${choice_values_str}}...]]")
            else
                # Default only.
                lines+=("[${short_options_str}[=${value_names_str}...]]")
            fi
        elif [[ "${arg_number}" == "?" ]]; then
            # [0, 1] values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice and default.
                lines+=("[${short_options_str}[={${choice_values_str}}]]")
            else
                # Default only.
                lines+=("[${short_options_str}[=${value_names_str}]]")
            fi
        else
            # Integer-count values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice and default.
                lines+=("[${short_options_str}={${choice_values_str}}]")
            else
                # Default only.
                lines+=("[${short_options_str}=${value_names_str}]")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        argparser_sort false "${lines[@]}"
        lines=("${sorted_array[@]}")

        for line in "${lines[@]}"; do
            usage_message+="${whitespace}${line}"
        done
    fi

    # Output each keyword argument with long options and default values
    # and sort them alphabetically.
    lines=( )
    for arg_key in "${long_option_default_args[@]}"; do
        # Read the argument's definition.
        long_options_str="${all_long_options[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options_arr \
            <<< "${long_options_str}"
        value_names_str="${all_value_names[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a value_names_arr \
            <<< "${value_names_str}"
        choice_values_str="${all_choice_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values_arr \
            <<< "${choice_values_str}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # If no value name is given, set them to the capitalized long
        # option names.
        if [[ -z "${value_names_str}" ]]; then
            value_names_arr=( )
            for long_option in "${long_options_arr[@]}"; do
                value_name="${long_option//-/_}"
                value_names_arr+=("${value_name^^}")
            done
        fi

        # Concatenate and colorize the long option names, value names,
        # and choice values.
        argparser_get_option_names "${arg_key}" "long" true
        long_options_str="${option_names}"

        argparser_join true "${styles["value_names"]}" 1 \
            "${value_names_arr[@]}"
        value_names_str="${joined_array}"

        argparser_join true "${styles["choice_values"]}" 1 \
            "${choice_values_arr[@]}"
        choice_values_str="${joined_array}"

        # Define the line for the current argument.  The argument has
        # some long options, default values, and possibly choice
        # values, and a variable argument number, with each property
        # changing the look of the line.
        if [[ "${arg_number}" == 0 ]]; then
            # Flag.
            lines+=("[${long_options_str}]")
        elif [[ "${arg_number}" == "+" ]]; then
            # [1, inf) values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice and default.
                lines+=("[${long_options_str}={${choice_values_str}}...]")
            else
                # Default only.
                lines+=("[${long_options_str}=${value_names_str}...]")
            fi
        elif [[ "${arg_number}" == "*" ]]; then
            # [0, inf) values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice and default.
                lines+=("[${long_options_str}[={${choice_values_str}}...]]")
            else
                # Default only.
                lines+=("[${long_options_str}[=${value_names_str}...]]")
            fi
        elif [[ "${arg_number}" == "?" ]]; then
            # [0, 1] values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice and default.
                lines+=("[${long_options_str}[={${choice_values_str}}]]")
            else
                # Default only.
                lines+=("[${long_options_str}[=${value_names_str}]]")
            fi
        else
            # Integer-count values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice and default.
                lines+=("[${long_options_str}={${choice_values_str}}]")
            else
                # Default only.
                lines+=("[${long_options_str}=${value_names_str}]")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        argparser_sort false "${lines[@]}"
        lines=("${sorted_array[@]}")

        for line in "${lines[@]}"; do
            usage_message+="${whitespace}${line}"
        done
    fi

    # Output each keyword argument with short options and without
    # default values and sort them alphabetically.
    lines=( )
    for arg_key in "${short_option_required_args[@]}"; do
        # Read the argument's definition.
        short_options_str="${all_short_options[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options_arr \
            <<< "${short_options_str}"
        value_names_str="${all_value_names[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a value_names_arr \
            <<< "${value_names_str}"
        choice_values_str="${all_choice_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values_arr \
            <<< "${choice_values_str}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # If no value name is given, set them to the capitalized short
        # option names.
        if [[ -z "${value_names_str}" ]]; then
            value_names_arr=( )
            for short_option in "${short_options_arr[@]}"; do
                value_name="${short_option//-/_}"
                value_names_arr+=("${value_name^^}")
            done
        fi

        # Concatenate and colorize the short option names, value names,
        # and choice values.
        argparser_get_option_names "${arg_key}" "short" true
        short_options_str="${option_names}"

        argparser_join true "${styles["value_names"]}" 1 \
            "${value_names_arr[@]}"
        value_names_str="${joined_array}"

        argparser_join true "${styles["choice_values"]}" 1 \
            "${choice_values_arr[@]}"
        choice_values_str="${joined_array}"

        # Define the line for the current argument.  The argument has
        # some short options, no default values, and possibly some
        # choice values, and a variable argument number, with each
        # property changing the look of the line.
        if [[ "${arg_number}" == 0 ]]; then
            # Flag.
            lines+=("${short_options_str}")
        elif [[ "${arg_number}" == "+" ]]; then
            # [1, inf) values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice only.
                lines+=("${short_options_str}={${choice_values_str}}...")
            else
                # No choice nor default.
                lines+=("${short_options_str}=${value_names_str}...")
            fi
        elif [[ "${arg_number}" == "*" ]]; then
            # [0, inf) values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice only.
                lines+=("${short_options_str}[={${choice_values_str}}...]")
            else
                # No choice nor default.
                lines+=("${short_options_str}[=${value_names_str}...]")
            fi
        elif [[ "${arg_number}" == "?" ]]; then
            # [0, 1] values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice only.
                lines+=("${short_options_str}[={${choice_values_str}}]")
            else
                # No choice nor default.
                lines+=("${short_options_str}[=${value_names_str}]")
            fi
        else
            # Integer-count values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice only.
                lines+=("${short_options_str}={${choice_values_str}}")
            else
                # No choice nor default.
                lines+=("${short_options_str}=${value_names_str}")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        argparser_sort false "${lines[@]}"
        lines=("${sorted_array[@]}")

        for line in "${lines[@]}"; do
            usage_message+="${whitespace}${line}"
        done
    fi

    # Output each keyword argument with long options and without default
    # values and sort them alphabetically.
    lines=( )
    for arg_key in "${long_option_required_args[@]}"; do
        # Read the argument's definition.
        long_options_str="${all_long_options[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options_arr \
            <<< "${long_options_str}"
        value_names_str="${all_value_names[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a value_names_arr \
            <<< "${value_names_str}"
        choice_values_str="${all_choice_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values_arr \
            <<< "${choice_values_str}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # If no value name is given, set them to the capitalized long
        # option names.
        if [[ -z "${value_names_str}" ]]; then
            value_names_arr=( )
            for long_option in "${long_options_arr[@]}"; do
                value_name="${long_option//-/_}"
                value_names_arr+=("${value_name^^}")
            done
        fi

        # Concatenate and colorize the long option names, value names,
        # and choice values.
        argparser_get_option_names "${arg_key}" "long" true
        long_options_str="${option_names}"

        argparser_join true "${styles["value_names"]}" 1 \
            "${value_names_arr[@]}"
        value_names_str="${joined_array}"

        argparser_join true "${styles["choice_values"]}" 1 \
            "${choice_values_arr[@]}"
        choice_values_str="${joined_array}"

        # Define the line for the current argument.  The argument has
        # some long options, no default values, and possibly some choice
        # values, and a variable argument number, with each property
        # changing the look of the line.
        if [[ "${arg_number}" == 0 ]]; then
            # Flag.
            lines+=("${long_options_str}")
        elif [[ "${arg_number}" == "+" ]]; then
            # [1, inf) values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice only.
                lines+=("${long_options_str}={${choice_values_str}}...")
            else
                # No choice nor default.
                lines+=("${long_options_str}=${value_names_str}...")
            fi
        elif [[ "${arg_number}" == "*" ]]; then
            # [0, inf) values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice only.
                lines+=("${long_options_str}[={${choice_values_str}}...]")
            else
                # No choice nor default.
                lines+=("${long_options_str}[=${value_names_str}...]")
            fi
        elif [[ "${arg_number}" == "?" ]]; then
            # [0, 1] values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice only.
                lines+=("${long_options_str}[={${choice_values_str}}]")
            else
                # No choice nor default.
                lines+=("${long_options_str}[=${value_names_str}]")
            fi
        else
            # Integer-count values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice only.
                lines+=("${long_options_str}={${choice_values_str}}")
            else
                # No choice nor default.
                lines+=("${long_options_str}=${value_names_str}")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        argparser_sort false "${lines[@]}"
        lines=("${sorted_array[@]}")

        for line in "${lines[@]}"; do
            usage_message+="${whitespace}${line}"
        done
    fi

    # Output each positional argument with default values.
    lines=( )
    for arg_key in "${positional_default_args[@]}"; do
        # Read the argument's definition.
        value_names_str="${all_value_names[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a value_names_arr \
            <<< "${value_names_str}"
        choice_values_str="${all_choice_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values_arr \
            <<< "${choice_values_str}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # Concatenate and colorize the value names and choice values.
        argparser_join true "${styles["value_names"]}" 1 \
            "${value_names_arr[@]}"
        value_names_str="${joined_array}"

        argparser_join true "${styles["choice_values"]}" 1 \
            "${choice_values_arr[@]}"
        choice_values_str="${joined_array}"

        # Define the line for the current argument.  The argument has
        # some default values and may have some choice values, with the
        # existence of each changing the look of the line.
        if [[ "${arg_number}" == "+" || "${arg_number}" == "*" ]]; then
            # [1, inf) or [0, inf) values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice and default.
                lines+=("[{${choice_values_str}}...]")
            else
                # Default only.
                lines+=("[${value_names_str}...]")
            fi
        else
            # Integer-count or [0, 1] values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice and default.
                lines+=("[{${choice_values_str}}]")
            else
                # Default only.
                lines+=("[${value_names_str}]")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        for line in "${lines[@]}"; do
            usage_message+="${whitespace}${line}"
        done
    fi

    # Output each positional argument without default values.
    lines=( )
    for arg_key in "${positional_required_args[@]}"; do
        # Read the argument's definition.
        value_names_str="${all_value_names[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a value_names_arr \
            <<< "${value_names_str}"
        choice_values_str="${all_choice_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values_arr \
            <<< "${choice_values_str}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # Concatenate and colorize the value names and choice values.
        argparser_join true "${styles["value_names"]}" 1 \
            "${value_names_arr[@]}"
        value_names_str="${joined_array}"

        argparser_join true "${styles["choice_values"]}" 1 \
            "${choice_values_arr[@]}"
        choice_values_str="${joined_array}"

        # Define the line for the current argument.  The argument has no
        # default values and may have some choice values, with the
        # existence of each changing the look of the line.
        if [[ "${arg_number}" == "+" || "${arg_number}" == "*" ]]; then
            # [1, inf) or [0, inf) values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice only.
                lines+=("{${choice_values_str}}...")
            else
                # No choice nor default.
                lines+=("${value_names_str}...")
            fi
        else
            # Integer-count or [0, 1] values.
            if [[ -n "${choice_values_str}" ]]; then
                # Choice only.
                lines+=("{${choice_values_str}}")
            else
                # No choice nor default.
                lines+=("${value_names_str}")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        for line in "${lines[@]}"; do
            usage_message+="${whitespace}${line}"
        done
    fi

    # Output the final usage message.
    usage_message+=$'\n'
    usage_message_groups["Usage"]="${usage_message}"
}

function argparser_print_help_or_usage_message() {
    # Print a help or usage message.  If a file with such is given,
    # print the file, else, create a message for the script's arguments.
    # For files, possibly skip commented lines (i.e., lines starting
    # with "#") and their trailing blank lines.  Replace lines starting
    # with ${ARGPARSER_*_FILE_INCLUDE_CHAR} by the auto-generated help
    #   or usage message.
    #
    # Arguments:
    # - $1: the help type ("help" or "usage")
    # - $2: whether to exit after printing
    # - $3: the file descriptor to write to (1 or 2)
    #
    # Nonlocals:
    # - all_arg_groups: the associative array holding the argument
    #   groups (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - help_message_groups: the associative array holding the help
    #   message's groups usable as include directive (read-only)
    # - usage_message_groups: the associative array holding the usage
    #   message's groups usable as include directive (read-only)
    #
    # Environment:
    # - ARGPARSER_HELP_ARG_GROUP (read-only)
    # - ARGPARSER_HELP_EXIT_CODE (read-only)
    # - ARGPARSER_HELP_FILE (read-only)
    # - ARGPARSER_HELP_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_HELP_FILE_KEEP_COMMENTS (read-only)
    # - ARGPARSER_HELP_STYLE (read-only)
    # - ARGPARSER_POSITIONAL_ARG_GROUP (read-only)
    # - ARGPARSER_USAGE_EXIT_CODE (read-only)
    # - ARGPARSER_USAGE_FILE (read-only)
    # - ARGPARSER_USAGE_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_USAGE_FILE_KEEP_COMMENTS (read-only)
    # - ARGPARSER_USAGE_STYLE (read-only)

    # Define the local variables.
    local add_heading
    local arg_group
    local -a arg_groups
    local count
    local error_message
    local -a error_messages
    local exit
    local exit_code
    local file
    local file_descriptor
    local help_type
    local include_char
    local include_directive
    local keep_comments
    local line
    local -a lines
    local line_type
    local message
    local -a resolved_lines
    local skip_blank_line
    local -a sorted_array
    local style
    local translation

    # Read the arguments.
    help_type="$1"
    exit="$2"
    file_descriptor="$3"

    # Set the constants to the respective environment variables.
    if [[ "${help_type}" == "help" ]]; then
        file="${ARGPARSER_HELP_FILE}"
        include_char="${ARGPARSER_HELP_FILE_INCLUDE_CHAR}"
        keep_comments="${ARGPARSER_HELP_FILE_KEEP_COMMENTS}"
        style="${ARGPARSER_HELP_STYLE}"
        exit_code="${ARGPARSER_HELP_EXIT_CODE}"
    else
        file="${ARGPARSER_USAGE_FILE}"
        include_char="${ARGPARSER_USAGE_FILE_INCLUDE_CHAR}"
        keep_comments="${ARGPARSER_USAGE_FILE_KEEP_COMMENTS}"
        style="${ARGPARSER_USAGE_STYLE}"
        exit_code="${ARGPARSER_USAGE_EXIT_CODE}"
    fi

    # Read the keyword arguments' groups to sort them for the help
    # message.
    arg_groups=( )
    for arg_group in "${all_arg_groups[@]}"; do
        if [[ "${arg_group}" != "${ARGPARSER_POSITIONAL_ARG_GROUP}" \
            && "${arg_group}" != "${ARGPARSER_HELP_ARG_GROUP}" ]] \
            && ! argparser_in_array "${arg_group}" "${arg_groups[@]}"
        then
            arg_groups+=("${arg_group}")
        fi
    done

    # Sort the argument groups, prepend the positional arguments group
    # and append the help options' group.
    argparser_sort false "${arg_groups[@]}"
    arg_groups=("${sorted_array[@]}")
    if (( "${#all_positional_args[@]}" > 0 )); then
        arg_groups=("${ARGPARSER_POSITIONAL_ARG_GROUP}" "${arg_groups[@]}")
    fi

    if [[ "${ARGPARSER_ADD_HELP}" == true \
        || "${ARGPARSER_ADD_USAGE}" == true \
        || "${ARGPARSER_ADD_VERSION}" == true ]]
    then
        arg_groups+=("${ARGPARSER_HELP_ARG_GROUP}")
    fi

    # Count the keyword arguments that aren't used for the help, usage,
    # or version message.  This count is used to conditionally add the
    # remark to the help message, below.  By counting the number of
    # "true" values in ${ARGPARSER_ADD_HELP}, ${ARGPARSER_ADD_USAGE},
    # and ${ARGPARSER_ADD_VERSION}, it is possible to check which help
    # options are defined.  All other arguments that have an entry in
    # ${!all_short_options} are actual keyword arguments needed for the
    # remark.
    argparser_count "true" "${ARGPARSER_ADD_HELP}" "${ARGPARSER_ADD_USAGE}" \
        "${ARGPARSER_ADD_VERSION}"
    (( keyword_args_count = "${#all_short_options[@]}" - count ))

    # Create the help or usage message groups, which are saved in an
    # associative array using the include directives as keys.
    if [[ "${help_type}" == "help" ]]; then
        argparser_create_help_message
    else
        argparser_create_usage_message
    fi

    # Read the help or usage file, if given, or set the lines to just
    # the include directive "All", meaning to create the entire help or
    # usage message.
    if [[ -n "${file}" ]]; then
        mapfile -t lines < "${file}"
    else
        lines=("${include_char}All")
    fi

    # Resolve the summarizing include directives by replacing them with
    # the individual include directives and separating blank lines.
    resolved_lines=( )
    for line in "${lines[@]}"; do
        if [[ "${line::1}" != "${include_char}" ]]; then
            resolved_lines+=("${line}")
            continue
        fi

        # Extract the include directive, where the include character may
        # be doubled.
        if [[ "${line:1:1}" == "${include_char}" ]]; then
            add_heading=false
            include_directive="${line:2}"
        else
            add_heading=true
            include_directive="${line:1}"
        fi

        if [[ "${help_type}" == "help" ]]; then
            if [[ "${include_directive}" == "All" ]]; then
                # Add the usage, description, and remark include
                # directives, terminated by blank lines.
                resolved_lines+=(
                    "${include_char}Usage"
                    ""
                    "${include_char}Description"
                    ""
                    "${include_char}Remark"
                    ""
                )

                # Add the include directives for each arguments group.
                # Terminate all but the last by a blank line.  If the
                # last group is the help options group, double the
                # include character to indicate that the heading shall
                # be suppressed.
                for i in "${!arg_groups[@]}"; do
                    if (( i < "${#arg_groups[@]}" - 1 )); then
                        resolved_lines+=(
                            "${include_char}${arg_groups[i]}"
                            ""
                        )
                    elif [[ "${ARGPARSER_ADD_HELP}" == true \
                        || "${ARGPARSER_ADD_USAGE}" == true \
                        || "${ARGPARSER_ADD_VERSION}" == true ]]
                    then
                        resolved_lines+=(
                            "${include_char}${include_char}${arg_groups[i]}"
                        )
                    else
                        resolved_lines+=("${include_char}${arg_groups[i]}")
                    fi
                done
            elif [[ "${include_directive}" == "Header" ]]; then
                # Add the usage, description, and remark include
                # directives, separated by blank lines.
                resolved_lines+=(
                    "${include_char}Usage"
                    ""
                    "${include_char}Description"
                    ""
                    "${include_char}Remark"
                )
            else
                # Add the unmodified line.
                resolved_lines+=("${line}")
            fi
        else
            if [[ "${include_directive}" == "All" ]]; then
                # Add the usage include directive.
                resolved_lines+=("${include_char}Usage")
            else
                # Add the unmodified line.
                resolved_lines+=("${line}")
            fi
        fi
    done

    # For each resolved line, print the text and replace the include
    # directives by the respective part from the help or usage message.
    # Possibly, skip comments.
    line_type="text"
    message=""
    skip_blank_line=false
    for line in "${resolved_lines[@]}"; do
        # Set ${line_type} to "include directive" if the line contains
        # an include directive, to "comment" if the line is commented
        # and ${keep_comments} is "false", and to "text" if it is not
        # empty (but not commented).  Thus, empty lines following
        # comments still have ${line_type} set to "comment".  For
        # include directives, add the requested groups from the help or
        # usage message.  Only add the remark if keyword arguments are
        # given.
        if [[ "${line::1}" == "${include_char}" ]]; then
            line_type="include directive"

            # Set the heading to be suppressed when the include
            # character is doubled.
            if [[ "${line:1:1}" == "${include_char}" ]]; then
                add_heading=false
                include_directive="${line:2}"
            else
                add_heading=true
                include_directive="${line:1}"
            fi

            if [[ "${help_type}" == "help" ]]; then
                if [[ "${include_directive}" == "Description" ]]; then
                    # Add the description.
                    if [[ -n "${help_message_groups["Description"]}" ]]; then
                        message+="${help_message_groups["Description"]}"
                    else
                        skip_blank_line=true
                    fi
                elif [[ "${include_directive}" == "Help" ]]; then
                    # Add the help options group, possibly with heading.
                    if [[ "${add_heading}" == true ]]; then
                        message+="${ARGPARSER_HELP_ARG_GROUP}:"
                        message+=$'\n'
                    fi
                    message+="${help_message_groups["${ARGPARSER_HELP_ARG_GROUP}"]}"
                elif [[ "${include_directive}" == "Remark" ]]; then
                    # Add the remark.
                    if (( keyword_args_count > 0 )); then
                        message+="${help_message_groups["Remark"]}"
                    else
                        skip_blank_line=true
                    fi
                elif [[ "${include_directive}" == "Usage" ]]; then
                    # Add the usage.
                    message+="${help_message_groups["Usage"]}"
                elif argparser_in_array "${include_directive}" \
                    "${arg_groups[@]}"
                then
                    # Add the arguments group, possibly with heading.
                    if [[ "${add_heading}" == true ]]; then
                        message+="${include_directive}:"
                        message+=$'\n'
                    fi
                    message+="${help_message_groups["${include_directive}"]}"
                else
                    # Output an error message for the unrecognized and
                    # likely incorrect include directive.
                    error_message="Error: The include directive \"\$1\" could "
                    error_message+="not be recognized."

                    argparser_translate "Error include directive" \
                        "${error_message}" "${include_directive}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi
            else
                if [[ "${include_directive}" == "Usage" ]]; then
                    # Add the usage.
                    message+="${usage_message_groups["Usage"]}"
                else
                    # Output an error message for the unrecognized and
                    # likely incorrect include directive.
                    error_message="Error: The include directive \"\$1\" could "
                    error_message+="not be recognized."

                    argparser_translate "Error include directive" \
                        "${error_message}" "${include_directive}"
                    error_message="${translation}"
                    error_messages+=("${error_message}")
                fi
            fi
        elif [[ "${line::1}" == \# && "${keep_comments}" == false ]]; then
            line_type="comment"
        elif [[ -n "${line}" || "${keep_comments}" == true ]]; then
            line_type="text"
        fi

        # If ${skip_blank_line} is set to "true", skip the current line,
        # which is empty by definition (it follows an include directive
        # for an empty group).  Else, if ${line_type} has been set to
        # "text", print the current line.  If it is set to
        # "include_directive", reset it to "text" to (possibly) print
        # the next line, and only not the current "<ArgumentGroup>"
        # line.
        if [[ "${skip_blank_line}" == true ]]; then
            skip_blank_line=false
        elif [[ "${line_type}" == "text" ]]; then
            message+="${line}"
            message+=$'\n'
        elif [[ "${line_type}" == "include directive" ]]; then
            line_type="text"
        fi
    done

    # Sort, filter, colorize, and print all error messages.
    argparser_print_error_message true false "${error_messages[@]}"

    # Print the help or usage message, then exit, if requested.
    printf '%s' "${message}"

    if [[ "${exit}" == true ]]; then
        exit "${exit_code}"
    fi
}

function argparser_print_version_message() {
    # Create and print a version message.
    #
    # Arguments:
    # - $1: whether to exit after printing
    #
    # Nonlocals:
    # - styles: the associative array containing the styles
    #
    # Environment:
    # - ARGPARSER_SCRIPT_NAME (read-only)
    # - ARGPARSER_VERSION_EXIT_CODE (read-only)
    # - ARGPARSER_VERSION_NUMBER (read-only)
    # - ARGPARSER_VERSION_STYLE (read-only)

    # Define the local variables.
    local exit
    local script_name
    local version_message

    # Read the argument.
    exit="$1"

    # Colorize and print the version message, then exit, if requested.
    argparser_colorize "${styles["script_name"]}" "${ARGPARSER_SCRIPT_NAME}" \
        1 script_name
    argparser_colorize "${styles["version_string"]}" \
        "v${ARGPARSER_VERSION_NUMBER}" 1 version_message

    printf '%s %s\n' "${script_name}" "${version_message}"

    if [[ "${exit}" == true ]]; then
        exit "${ARGPARSER_VERSION_EXIT_CODE}"
    fi
}

function argparser_print_error_message() {
    # Sort, filter, colorize, and print all error messages.
    #
    # Arguments:
    # - $1: whether to filter the messages (by argparser_uniq)
    # - $2: whether to exit after printing
    # - $@: the error messages
    #
    # Nonlocals:
    # - styles: the associative array containing the styles
    #
    # Environment:
    # - ARGPARSER_ERROR_EXIT_CODE (read-only)
    # - ARGPARSER_ERROR_STYLE (read-only)
    # - ARGPARSER_SCRIPT_NAME (read-only)
    # - ARGPARSER_SILENCE_ERRORS (read-only)
    # - ARGPARSER_SILENCE_WARNINGS (read-only)

    # Define the local variables.
    local caption
    local exit
    local error_message
    local -a error_messages
    local filter
    local -a filtered_array
    local script_name
    local -a sorted_array

    # Read the arguments.
    filter="$1"
    exit="$2"
    shift 2
    error_messages=("$@")

    # If the error message shall not be emitted (output), return or
    # exit, effectively silencing the message.
    if [[ "${ARGPARSER_SILENCE_ERRORS}" == true ]]; then
        if [[ "${exit}" == true ]]; then
            exit "${ARGPARSER_ERROR_EXIT_CODE}"
        else
            return
        fi
    fi

    # Sort, filter, colorize, and print all error messages, then exit,
    # if requested.
    if (( "${#error_messages[@]}" > 0 )); then
        # Sort and filter the error messages.
        argparser_sort false "${error_messages[@]}"
        error_messages=("${sorted_array[@]}")

        if [[ "${filter}" == true ]]; then
            argparser_uniq "${error_messages[@]}"
            error_messages=("${filtered_array[@]}")
        fi

        # Colorize and print the error messages.
        for error_message in "${error_messages[@]}"; do
            # Prepend the script name, if given.
            if [[ -n "${ARGPARSER_SCRIPT_NAME}" ]]; then
                argparser_colorize "${styles["script_name"]}" \
                    "${ARGPARSER_SCRIPT_NAME}:" 2 script_name
            fi

            # Print the actual error message.
            argparser_colorize "${styles["error_caption"]}" "Error:" 2 caption
            argparser_colorize "${styles["error_text"]}" \
                "${error_message#Error: }" 2 error_message
            printf '%s %s %s\n' "${script_name}" "${caption}" \
                "${error_message}"
        done

        if [[ "${exit}" == true ]]; then
            exit "${ARGPARSER_ERROR_EXIT_CODE}"
        fi
    fi
}

function argparser_print_warning_message() {
    # Sort, filter, colorize, and print all warning messages.
    #
    # Arguments:
    # - $1: whether to filter the messages (by argparser_uniq)
    # - $@: the warning messages
    #
    # Nonlocals:
    # - styles: the associative array containing the styles
    #
    # Environment:
    # - ARGPARSER_SCRIPT_NAME (read-only)
    # - ARGPARSER_SILENCE_ERRORS (read-only)
    # - ARGPARSER_SILENCE_WARNINGS (read-only)
    # - ARGPARSER_WARNING_STYLE (read-only)

    # Define the local variables.
    local caption
    local filter
    local -a filtered_array
    local script_name
    local -a sorted_array
    local warning_message
    local -a warning_messages

    # Read the arguments.
    filter="$1"
    shift
    warning_messages=("$@")

    # If the warning message shall not be emitted (output), return,
    # effectively silencing the message.
    if [[ "${ARGPARSER_SILENCE_WARNINGS}" == true ]]; then
        return
    fi

    # Sort, filter, colorize, and print all warning messages.
    if (( "${#warning_messages[@]}" > 0 )); then
        # Sort and filter the warning messages.
        argparser_sort false "${warning_messages[@]}"
        warning_messages=("${sorted_array[@]}")

        if [[ "${filter}" == true ]]; then
            argparser_uniq "${warning_messages[@]}"
            warning_messages=("${filtered_array[@]}")
        fi

        # Colorize and print the warning messages.
        for warning_message in "${warning_messages[@]}"; do
            # Prepend the script name, if given.
            if [[ -n "${ARGPARSER_SCRIPT_NAME}" ]]; then
                argparser_colorize "${styles["script_name"]}" \
                    "${ARGPARSER_SCRIPT_NAME}:" script_name
            fi

            # Print the actual warning message.
            argparser_colorize "${styles["warning_caption"]}" "Warning:" 2 \
                caption
            argparser_colorize "${styles["warning_text"]}" \
                "${warning_message#Warning: }" 2 warning_message
            printf '%s %s %s\n' "${script_name}" "${caption}" \
                "${warning_message}"
        done
    fi
}

function argparser_print_logo() {
    # Print the Argparser logo in ANSI art.

    # Define the local variables.
    local font_1
    local font_2
    local font_3
    local font_4
    local font_5
    local font_6
    local font_7
    local font_8
    local font_9
    local space
    local style

    # Set each letter's color as all primary and secondary colors,
    # traversing the color wheel for one and a half rounds.
    space="black,reverse"     # _ (whitespace)
    font_1="green,reverse"    # A
    font_2="cyan,reverse"     # R
    font_3="blue,reverse"     # G
    font_4="magenta,reverse"  # P
    font_5="red,reverse"      # A
    font_6="yellow,reverse"   # R
    font_7="green,reverse"    # S
    font_8="cyan,reverse"     # E
    font_9="blue,reverse"     # R

    # Output the first line, which is empty.
    argparser_colorize "${space}" "000000000000000000000000000000" 1  # _
    argparser_colorize "${space}" "000000000000000000000000000000" 1  # _
    argparser_colorize "${space}" "00000000000000"                 1  # _
    printf '\n'

    # Output the second line, containing the first of five lines of the
    # letters.
    argparser_colorize "${space}"  "001"     1  # _, A
    argparser_colorize "${font_1}" "0000"    1  # A
    argparser_colorize "${space}"  "0101"    1  # A, _, R
    argparser_colorize "${font_2}" "0100"    1  # R
    argparser_colorize "${space}"  "1001"    1  # R, _, G
    argparser_colorize "${font_3}" "00011"   1  # G
    argparser_colorize "${space}"  "101"     1  # _, P
    argparser_colorize "${font_4}" "0100"    1  # P
    argparser_colorize "${space}"  "0001"    1  # P, _, A
    argparser_colorize "${font_5}" "0000"    1  # A
    argparser_colorize "${space}"  "0101"    1  # A, _, R
    argparser_colorize "${font_6}" "0100"    1  # R
    argparser_colorize "${space}"  "1001"    1  # R, _, S
    argparser_colorize "${font_7}" "01001"   1  # S
    argparser_colorize "${space}"  "10"      1  # _
    argparser_colorize "${font_8}" "100010"  1  # E
    argparser_colorize "${space}"  "101"     1  # _, R
    argparser_colorize "${font_9}" "0100"    1  # R
    argparser_colorize "${space}"  "100"     1  # R, _
    printf '\n'

    # Output the third line, containing the second of five lines of the
    # letters.
    argparser_colorize "${space}"  "00"      1  # _
    argparser_colorize "${font_1}" "10"      1  # A
    argparser_colorize "${space}"  "00"      1  # A
    argparser_colorize "${font_1}" "00"      1  # A
    argparser_colorize "${space}"  "10"      1  # _
    argparser_colorize "${font_2}" "10"      1  # R
    argparser_colorize "${space}"  "10"      1  # R
    argparser_colorize "${font_2}" "01"      1  # R
    argparser_colorize "${space}"  "00"      1  # _
    argparser_colorize "${font_3}" "10"      1  # G
    argparser_colorize "${space}"  "001110"  1  # G, _
    argparser_colorize "${font_4}" "10"      1  # P
    argparser_colorize "${space}"  "10"      1  # P
    argparser_colorize "${font_4}" "00"      1  # P
    argparser_colorize "${space}"  "00"      1  # _
    argparser_colorize "${font_5}" "10"      1  # A
    argparser_colorize "${space}"  "00"      1  # A
    argparser_colorize "${font_5}" "00"      1  # A
    argparser_colorize "${space}"  "10"      1  # _
    argparser_colorize "${font_6}" "10"      1  # R
    argparser_colorize "${space}"  "10"      1  # R
    argparser_colorize "${font_6}" "01"      1  # R
    argparser_colorize "${space}"  "00"      1  # _
    argparser_colorize "${font_7}" "10"      1  # S
    argparser_colorize "${space}"  "100110"  1  # S, _
    argparser_colorize "${font_8}" "10"      1  # E
    argparser_colorize "${space}"  "001010"  1  # E, _
    argparser_colorize "${font_9}" "10"      1  # R
    argparser_colorize "${space}"  "10"      1  # R
    argparser_colorize "${font_9}" "01"      1  # R
    argparser_colorize "${space}"  "00"      1  # _
    printf '\n'

    # Output the fourth line, containing the third of five lines of the
    # letters.
    argparser_colorize "${space}"  "00"      1  # _
    argparser_colorize "${font_1}" "100000"  1  # A
    argparser_colorize "${space}"  "10"      1  # _
    argparser_colorize "${font_2}" "101001"  1  # R
    argparser_colorize "${space}"  "00"      1  # _
    argparser_colorize "${font_3}" "10001"   1  # G
    argparser_colorize "${space}"  "110"     1  # G, _
    argparser_colorize "${font_4}" "10100"   1  # P
    argparser_colorize "${space}"  "000"     1  # P, _
    argparser_colorize "${font_5}" "100000"  1  # A
    argparser_colorize "${space}"  "10"      1  # _
    argparser_colorize "${font_6}" "101001"  1  # R
    argparser_colorize "${space}"  "001"     1  # _, S
    argparser_colorize "${font_7}" "0100"    1  # S
    argparser_colorize "${space}"  "110"     1  # S, _
    argparser_colorize "${font_8}" "100010"  1  # E
    argparser_colorize "${space}"  "10"      1  # _
    argparser_colorize "${font_9}" "101001"  1  # R
    argparser_colorize "${space}"  "00"      1  # _
    printf '\n'

    # Output the fifth line, containing the fourth of five lines of the
    # letters.
    argparser_colorize "${space}"  "00"      1  # _
    argparser_colorize "${font_1}" "10"      1  # A
    argparser_colorize "${space}"  "00"      1  # A
    argparser_colorize "${font_1}" "00"      1  # A
    argparser_colorize "${space}"  "10"      1  # _
    argparser_colorize "${font_2}" "10"      1  # R
    argparser_colorize "${space}"  "1"       1  # R
    argparser_colorize "${font_2}" "00"      1  # R
    argparser_colorize "${space}"  "100"     1  # R, _
    argparser_colorize "${font_3}" "10"      1  # G
    argparser_colorize "${space}"  "00"      1  # G
    argparser_colorize "${font_3}" "11"      1  # G
    argparser_colorize "${space}"  "10"      1  # _
    argparser_colorize "${font_4}" "10"      1  # P
    argparser_colorize "${space}"  "100000"  1  # P, _
    argparser_colorize "${font_5}" "10"      1  # A
    argparser_colorize "${space}"  "00"      1  # A
    argparser_colorize "${font_5}" "00"      1  # A
    argparser_colorize "${space}"  "10"      1  # _
    argparser_colorize "${font_6}" "10"      1  # R
    argparser_colorize "${space}"  "1"       1  # R
    argparser_colorize "${font_6}" "00"      1  # R
    argparser_colorize "${space}"  "1001010" 1  # R, _, S
    argparser_colorize "${font_7}" "01"      1  # S
    argparser_colorize "${space}"  "10"      1  # _
    argparser_colorize "${font_8}" "10"      1  # E
    argparser_colorize "${space}"  "001010"  1  # E, _
    argparser_colorize "${font_9}" "10"      1  # R
    argparser_colorize "${space}"  "1"       1  # R
    argparser_colorize "${font_9}" "00"      1  # R
    argparser_colorize "${space}"  "100"     1  # R, _
    printf '\n'

    # Output the sixth line, containing the fifth of five lines of the
    # letters.
    argparser_colorize "${space}"  "00"      1  # _
    argparser_colorize "${font_1}" "10"      1  # A
    argparser_colorize "${space}"  "00"      1  # A
    argparser_colorize "${font_1}" "00"      1  # A
    argparser_colorize "${space}"  "10"      1  # _
    argparser_colorize "${font_2}" "10"      1  # R
    argparser_colorize "${space}"  "10"      1  # R
    argparser_colorize "${font_2}" "01"      1  # R
    argparser_colorize "${space}"  "001"     1  # _, G
    argparser_colorize "${font_3}" "0001"    1  # G
    argparser_colorize "${space}"  "110"     1  # G, _
    argparser_colorize "${font_4}" "10"      1  # P
    argparser_colorize "${space}"  "100000"  1  # P, _
    argparser_colorize "${font_5}" "10"      1  # A
    argparser_colorize "${space}"  "00"      1  # A
    argparser_colorize "${font_5}" "00"      1  # A
    argparser_colorize "${space}"  "10"      1  # _
    argparser_colorize "${font_6}" "10"      1  # R
    argparser_colorize "${space}"  "10"      1  # R
    argparser_colorize "${font_6}" "01"      1  # R
    argparser_colorize "${space}"  "00"      1  # _
    argparser_colorize "${font_7}" "10100"   1  # S
    argparser_colorize "${space}"  "110"     1  # S, _
    argparser_colorize "${font_8}" "100010"  1  # E
    argparser_colorize "${space}"  "10"      1  # _
    argparser_colorize "${font_9}" "10"      1  # R
    argparser_colorize "${space}"  "10"      1  # R
    argparser_colorize "${font_9}" "01"      1  # R
    argparser_colorize "${space}"  "00"      1  # _
    printf '\n'

    # Output the seventh line, which is empty again.
    argparser_colorize "${space}" "000000000000000000000000000000" 1  # _
    argparser_colorize "${space}" "000000000000000000000000000000" 1  # _
    argparser_colorize "${space}" "00000000000000"                 1  # _
    printf '\n'
}

# Define the main Argparser function.
function argparser_main() {
    # Run the Argparser, depending on the values of its environment
    # variables, to read, parse, and set the script's arguments.
    #
    # Environment:
    # - ARGPARSER_ARGS
    # - ARGPARSER_CHECK_ENV_VARS (read-only)
    # - ARGPARSER_CONFIG_FILE (read-only)
    # - ARGPARSER_CREATE_ARG_DEF (read-only)
    # - ARGPARSER_HELP_ARG_GROUP
    # - ARGPARSER_HELP_DESCRIPTION
    # - ARGPARSER_POSITIONAL_ARG_GROUP
    # - ARGPARSER_READ_ARGS (read-only)
    # - ARGPARSER_SET_ARGS (read-only)
    # - ARGPARSER_STYLE_FILE (read-only)
    # - ARGPARSER_TRANSLATION_FILE (read-only)
    # - ARGPARSER_UNSET_ARGS (read-only)
    # - ARGPARSER_UNSET_ENV_VARS (read-only)
    # - ARGPARSER_UNSET_FUNCTIONS (read-only)
    # - ARGPARSER_WRITE_ARGS (read-only)
    # - ARGPARSER_WRITE_ARGS (read-only)

    # Possibly, enable the debug mode.  Since at this point, the shell
    # option "nounset" may still be activated (from the parent script),
    # the test for the variable's existence is necessary.
    if [[ "$1" == "--debug" \
        || (-v ARGPARSER_DEBUG && "${ARGPARSER_DEBUG}" == true) ]]
    then
        argparser_toggle_debugger start
    fi

    # Define the local variables.
    local -A all_arg_groups
    local -A all_arg_numbers
    local -A all_choice_values
    local -A all_default_values
    local -A all_help_texts
    local -A all_long_options
    local -A all_notes
    local -a all_positional_args
    local -A all_short_options
    local -A all_types
    local -A all_value_names
    local -A dictionary
    local is_extglob_set
    local is_self_parsing
    local is_sourced
    local -a script_args
    local -A styles
    local translation

    # Declare the remaining internal variables.  Since ${ARGPARSER_ARGS}
    # must be set in global scope within argparser_set_args, later, it's
    # useless declaring it as local, here.
    declare -a ARGPARSER_ARGS
    local argparser_version="1.2.0 \"Callospermophilus lateralis\""

    # Detect whether the Argparser is sourced or run as standalone
    # script.  In the former case, the second element of ${FUNCNAME[@]}
    # is "source".
    if (( "${#FUNCNAME[@]}" >= 2 )) && [[ "${FUNCNAME[1]}" == "source" ]]; then
        is_sourced=true
    else
        is_sourced=false
    fi

    # Locally disable errexit, nounset, and pipefail, and enable
    # extglob.  Since all functions are called from argparser_main, they
    # inherit the options.
    local -
    set +o errexit +o nounset +o pipefail
    shopt -q extglob
    is_extglob_set="$?"
    shopt -s extglob

    # If ${ARGPARSER_CONFIG_FILE} isn't set to the empty string, read
    # the configuration file.
    if [[ -n "${ARGPARSER_CONFIG_FILE}" ]]; then
        argparser_read_configuration
    fi

    # Set the environment variables that aren't already set by the
    # calling script or environment or read from the configuration file
    # to prevent overriding them.  Then, set the script's command-line
    # arguments (with the Argparser arguments being removed) as the
    # current command line.  Finally, reset the arrays holding the
    # arguments definition data.
    is_self_parsing=true
    argparser_set_env_vars "$@"
    set -- "${script_args[@]}"
    is_self_parsing=false

    unset all_arg_groups
    unset all_arg_numbers
    unset all_choice_values
    unset all_default_values
    unset all_help_texts
    unset all_long_options
    unset all_notes
    unset all_positional_args
    unset all_short_options
    unset all_types
    unset all_value_names

    local -A all_arg_groups
    local -A all_arg_numbers
    local -A all_choice_values
    local -A all_default_values
    local -A all_help_texts
    local -A all_long_options
    local -A all_notes
    local -a all_positional_args
    local -A all_short_options
    local -A all_types
    local -A all_value_names

    # If ${ARGPARSER_TRANSLATION_FILE} isn't set to the empty string,
    # read the translation file.  To be able to use the localized names
    # of ${ARGPARSER_HELP_DESCRIPTION}, ${ARGPARSER_HELP_ARG_GROUP}, and
    # ${ARGPARSER_POSITIONAL_ARG_GROUP} in the arguments definition and
    # help message, translate them.
    if [[ -n "${ARGPARSER_TRANSLATION_FILE}" ]]; then
        argparser_read_translation

        argparser_translate "Positional arguments" \
            "${ARGPARSER_POSITIONAL_ARG_GROUP}"
        ARGPARSER_POSITIONAL_ARG_GROUP="${translation}"

        argparser_translate "Help options" "${ARGPARSER_HELP_ARG_GROUP}"
        ARGPARSER_HELP_ARG_GROUP="${translation}"

        argparser_translate "Help description" "${ARGPARSER_HELP_DESCRIPTION}"
        ARGPARSER_HELP_DESCRIPTION="${translation}"
    fi

    # If ${ARGPARSER_STYLE_FILE} isn't set to the empty string, read the
    # style file.
    if [[ -n "${ARGPARSER_STYLE_FILE}" ]]; then
        argparser_read_styles
    fi

    # If ${ARGPARSER_CHECK_ENV_VARS} isn't set to "false", check if the
    # environment variables accord to their definition.  Since
    # ${ARGPARSER_CHECK_ENV_VARS} is, as any other environment variable,
    # yet unchecked, its value may be different from the expected "true"
    # or "false".  Hence, testing for "not false" is not the exact
    # opposite of testing for "true".  Even more, if
    # ${ARGPARSER_CHECK_ENV_VARS} is different from "true" and "false",
    # the test would be mandatory as it shows the environment variables
    # have been wrongly set.
    if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
        argparser_check_env_vars
    fi

    # If ${ARGPARSER_CREATE_ARG_DEF} is set to "true", create the
    # arguments definition, then exit, since the creation should not
    # happen alongside the argument parsing.
    if [[ "${ARGPARSER_CREATE_ARG_DEF}" == true ]]; then
        argparser_create_args_definition
        exit
    fi

    # If ${ARGPARSER_READ_ARGS} is set to "true", read and parse the
    # arguments.
    if [[ "${ARGPARSER_READ_ARGS}" == true ]]; then
        argparser_parse_args "$@"
    fi

    # If ${ARGPARSER_UNSET_ARGS} is set to "true", disable all arguments
    # given to the calling script, effectively unsetting the command
    # line.
    if [[ "${ARGPARSER_UNSET_ARGS}" == true ]]; then
        set --
    fi

    # If ${ARGPARSER_SET_ARGS} is set to "true", set the arguments as
    # variables to the current environment.
    if [[ "${ARGPARSER_SET_ARGS}" == true ]]; then
        argparser_set_args
    fi

    # If ${ARGPARSER_WRITE_ARGS} is set to "true", write the arguments
    # to STDOUT.
    if [[ "${ARGPARSER_WRITE_ARGS}" == true ]]; then
        argparser_write_args
    fi

    # Possibly, disable the debug mode.
    if [[ "$1" == "--debug" || "${ARGPARSER_DEBUG}" == true ]]; then
        argparser_toggle_debugger stop
    fi

    # If ${ARGPARSER_UNSET_FUNCTIONS} is set to "true", unset all
    # Argparser functions.  The names are used instead of a glob to
    # limit side effects with potentially same-named functions (i.e.,
    # those starting with "argparser_") from the calling script that
    # stand in no relation to the Argparser.
    if [[ "${ARGPARSER_UNSET_FUNCTIONS}" == true ]]; then
        unset -f argparser_add_args_definition_help_options
        unset -f argparser_check_arg_values
        unset -f argparser_check_args_definition_names
        unset -f argparser_check_args_definition_option_values
        unset -f argparser_check_args_definition_positional_values
        unset -f argparser_check_bash_version
        unset -f argparser_check_color_or_style
        unset -f argparser_check_env_vars
        unset -f argparser_check_file
        unset -f argparser_check_shell
        unset -f argparser_colorize
        unset -f argparser_count
        unset -f argparser_create_args_definition
        unset -f argparser_create_help_message
        unset -f argparser_create_usage_message
        unset -f argparser_fold
        unset -f argparser_get_arg_key
        unset -f argparser_get_option_names
        unset -f argparser_in_array
        unset -f argparser_is_alpha
        unset -f argparser_is_bool
        unset -f argparser_is_char
        unset -f argparser_is_float
        unset -f argparser_is_identifier
        unset -f argparser_is_int
        unset -f argparser_is_uint
        unset -f argparser_join
        unset -f argparser_main
        unset -f argparser_pad
        unset -f argparser_parse_arg
        unset -f argparser_parse_args
        unset -f argparser_parse_args_definition
        unset -f argparser_parse_long_option
        unset -f argparser_parse_positional_args
        unset -f argparser_parse_short_option
        unset -f argparser_print_error_message
        unset -f argparser_print_help_or_usage_message
        unset -f argparser_print_logo
        unset -f argparser_print_version_message
        unset -f argparser_print_warning_message
        unset -f argparser_quicksort
        unset -f argparser_read_args_definition
        unset -f argparser_read_configuration
        unset -f argparser_read_styles
        unset -f argparser_read_translation
        unset -f argparser_seq
        unset -f argparser_set_args
        unset -f argparser_set_env_vars
        unset -f argparser_sort
        unset -f argparser_toggle_debugger
        unset -f argparser_translate
        unset -f argparser_trim
        unset -f argparser_uniq
        unset -f argparser_write_args
    fi

    # If ${ARGPARSER_UNSET_ENV_VARS} is set to "true", unset all
    # Argparser environment variables.  Again, the names are used
    # instead of a glob to limit side effects with potentially
    # same-named variables (i.e., those starting with "ARGPARSER_") from
    # the calling script that stand in no relation to the Argparser.
    if [[ "${ARGPARSER_UNSET_ENV_VARS}" == true ]]; then
        unset ARGPARSER_ADD_HELP
        unset ARGPARSER_ADD_USAGE
        unset ARGPARSER_ADD_VERSION
        unset ARGPARSER_ALLOW_ARG_INTERMIXING
        unset ARGPARSER_ALLOW_FLAG_INVERSION
        unset ARGPARSER_ALLOW_FLAG_NEGATION
        unset ARGPARSER_ALLOW_OPTION_ABBREVIATION
        unset ARGPARSER_ALLOW_OPTION_MERGING
        unset ARGPARSER_ARG_ARRAY_NAME
        unset ARGPARSER_ARG_DEF_FILE
        unset ARGPARSER_ARG_DELIMITER_1
        unset ARGPARSER_ARG_DELIMITER_2
        unset ARGPARSER_ARGS
        unset ARGPARSER_CHECK_ARG_DEF
        unset ARGPARSER_CHECK_ENV_VARS
        unset ARGPARSER_CONFIG_FILE
        unset ARGPARSER_COUNT_FLAGS
        unset ARGPARSER_CREATE_ARG_DEF
        unset ARGPARSER_DEBUG
        unset ARGPARSER_ERROR_EXIT_CODE
        unset ARGPARSER_ERROR_STYLE
        unset ARGPARSER_HELP_ARG_GROUP
        unset ARGPARSER_HELP_DESCRIPTION
        unset ARGPARSER_HELP_EXIT_CODE
        unset ARGPARSER_HELP_FILE
        unset ARGPARSER_HELP_FILE_INCLUDE_CHAR
        unset ARGPARSER_HELP_FILE_KEEP_COMMENTS
        unset ARGPARSER_HELP_OPTIONS
        unset ARGPARSER_HELP_STYLE
        unset ARGPARSER_LANGUAGE
        unset ARGPARSER_MAX_COL_WIDTH_1
        unset ARGPARSER_MAX_COL_WIDTH_2
        unset ARGPARSER_MAX_COL_WIDTH_3
        unset ARGPARSER_MAX_WIDTH
        unset ARGPARSER_POSITIONAL_ARG_GROUP
        unset ARGPARSER_READ_ARGS
        unset ARGPARSER_SCRIPT_NAME
        unset ARGPARSER_SET_ARGS
        unset ARGPARSER_SET_ARRAYS
        unset ARGPARSER_SILENCE_ERRORS
        unset ARGPARSER_SILENCE_WARNINGS
        unset ARGPARSER_STYLE_FILE
        unset ARGPARSER_TRANSLATION_FILE
        unset ARGPARSER_UNSET_ARGS
        unset ARGPARSER_UNSET_ENV_VARS
        unset ARGPARSER_UNSET_FUNCTIONS
        unset ARGPARSER_USAGE_EXIT_CODE
        unset ARGPARSER_USAGE_FILE
        unset ARGPARSER_USAGE_FILE_INCLUDE_CHAR
        unset ARGPARSER_USAGE_FILE_KEEP_COMMENTS
        unset ARGPARSER_USAGE_MESSAGE_OPTION_TYPE
        unset ARGPARSER_USAGE_MESSAGE_ORIENTATION
        unset ARGPARSER_USAGE_OPTIONS
        unset ARGPARSER_USAGE_STYLE
        unset ARGPARSER_USE_LONG_OPTIONS
        unset ARGPARSER_USE_SHORT_OPTIONS
        unset ARGPARSER_USE_STYLES_IN_FILES
        unset ARGPARSER_VERSION_EXIT_CODE
        unset ARGPARSER_VERSION_NUMBER
        unset ARGPARSER_VERSION_OPTIONS
        unset ARGPARSER_VERSION_STYLE
        unset ARGPARSER_WARNING_STYLE
        unset ARGPARSER_WRITE_ARGS
    fi

    # Possibly disable extglob, if it was previously unset.
    if (( is_extglob_set == 1 )); then
        shopt -u extglob
    fi
}

# Run the Argparser.
argparser_main "$@"
