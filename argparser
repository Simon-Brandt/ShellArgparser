#!/bin/bash

# Author: Simon Brandt
# E-Mail: simon.brandt@uni-greifswald.de
# Last Modification: 2025-02-19

# TODO: Support argparser configuration by command-line arguments and
#       config file.
# TODO: Remove double meaning of "--" both for configuring the argparser
#       and as normal command-line option.
# TODO: Output error message for unsupported include directives.
# TODO: Rewrite tests as correct test suites.
# TODO: Write tests for keyword-only and positional-only arguments.
# TODO: Speed up argparser by e.g. trying to remove command
#       substitutions.
# BUG:  Negative values after commas are interpreted as option names.

# Usage: Source this script with "source argparser" inside the script
# whose arguments need to be parsed.  If ${ARGPARSER_READ_ARGS} is set
# to true (the default), the arguments will be parsed upon sourcing.  If
# ${ARGPARSER_SET_ARGS} is set to true (the default), the arguments will
# be set to variables upon sourcing, else, the associative array which
# ${ARGPARSER_ARG_ARRAY_NAME} points to needs to be accessed.  Refer to
# the README.md for details.

# Purpose: Parse a script's arguments, giving proper error messages for
# wrongly set arguments, assigning the values to the respective
# variables, as well as creating and printing a help message.  Refer to
# the README.md for details.

########################################################################

# Set the argparser environment variables, as long as they aren't
# already set by the calling script or environment (to prevent
# overriding them).  The no-op command ":" is used for its side effect
# to set the variables, if unset or null, as part of the parameter
# expansion.
if (( "$#" >= 2 )) && [[ "$2" == "--" ]]; then
    case "$1" in
        "--read")
            ARGPARSER_READ_ARGS=true
            ARGPARSER_SET_ARGS=false
            ;;
        "--set")
            ARGPARSER_READ_ARGS=false
            ARGPARSER_SET_ARGS=true
            ;;
        "--all")
            ARGPARSER_READ_ARGS=true
            ARGPARSER_SET_ARGS=true
            ;;
        *)
            printf 'Error: Wrong action given: %s\n' "$1"
            exit 1
            ;;
    esac
    shift 2  # Get rid of the action specification.
fi
if [[ -v ARGPARSER_DICTIONARY ]]; then
    printf 'Error: ARGPARSER_DICTIONARY must not be set.\n'
    exit 1
else
    declare -A ARGPARSER_DICTIONARY
fi
: "${ARGPARSER_ADD_HELP:=true}"
: "${ARGPARSER_ADD_USAGE:=true}"
: "${ARGPARSER_ADD_VERSION:=true}"
: "${ARGPARSER_ALLOW_OPTION_ABBREVIATION:=false}"
: "${ARGPARSER_ALLOW_OPTION_MERGING:=false}"
: "${ARGPARSER_ARG_ARRAY_NAME:="args"}"
: "${ARGPARSER_ARG_DEF_FILE:=""}"
: "${ARGPARSER_ARG_DEF_FILE_HAS_HEADER:=true}"
: "${ARGPARSER_ARG_DEF_HAS_HEADER:=true}"
: "${ARGPARSER_ARG_DELIMITER_1:=":"}"
: "${ARGPARSER_ARG_DELIMITER_2:=","}"
: "${ARGPARSER_CHECK_ARG_DEFINITION:=false}"
: "${ARGPARSER_CHECK_ENV_VARS:=false}"
: "${ARGPARSER_COUNT_FLAGS:=false}"
: "${ARGPARSER_ERROR_EXIT_CODE:=1}"
: "${ARGPARSER_ERROR_STYLE:="red,bold,reverse"}"
: "${ARGPARSER_HELP_EXIT_CODE:=0}"
: "${ARGPARSER_HELP_FILE:=""}"
: "${ARGPARSER_HELP_FILE_INCLUDE_CHAR:="@"}"
: "${ARGPARSER_HELP_FILE_KEEP_COMMENTS:=false}"
: "${ARGPARSER_HELP_STYLE:="italic"}"
: "${ARGPARSER_LANGUAGE:="en"}"
: "${ARGPARSER_MAX_COL_WIDTH_1:=5}"
: "${ARGPARSER_MAX_COL_WIDTH_2:=33}"
: "${ARGPARSER_MAX_COL_WIDTH_3:=39}"
: "${ARGPARSER_POSITIONAL_ARG_GROUP:="Positional arguments"}"
: "${ARGPARSER_READ_ARGS:=true}"
: "${ARGPARSER_SCRIPT_NAME:="${0##*/}"}"
: "${ARGPARSER_SET_ARGS:=true}"
: "${ARGPARSER_SET_ARRAYS:=true}"
: "${ARGPARSER_SILENCE_ERRORS:=false}"
: "${ARGPARSER_SILENCE_WARNINGS:=false}"
: "${ARGPARSER_TRANSLATION_FILE:=""}"
: "${ARGPARSER_UNSET_ARGS:=true}"
: "${ARGPARSER_UNSET_ENV_VARS:=true}"
: "${ARGPARSER_UNSET_FUNCTIONS:=true}"
: "${ARGPARSER_USAGE_EXIT_CODE:=0}"
: "${ARGPARSER_USAGE_FILE:=""}"
: "${ARGPARSER_USAGE_FILE_INCLUDE_CHAR:="@"}"
: "${ARGPARSER_USAGE_FILE_KEEP_COMMENTS:=false}"
: "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE:="short"}"
: "${ARGPARSER_USAGE_MESSAGE_ORIENTATION:="row"}"
: "${ARGPARSER_USAGE_STYLE:="italic"}"
: "${ARGPARSER_USE_STYLES_IN_FILES:=false}"
: "${ARGPARSER_VERSION:="1.0.0"}"
: "${ARGPARSER_VERSION_EXIT_CODE:=0}"
: "${ARGPARSER_VERSION_STYLE:="bold"}"
: "${ARGPARSER_WARNING_STYLE:="red,bold"}"

# Define the argparser functions used for general tests.
function argparser_in_array() {
    # Check if an element occurs in an array.
    #
    # Arguments:
    # - $1: the element to search for
    # - $@: the array to search through
    #
    # Output:
    # - true, if the element exists in the array
    # - false, else

    # Define the local variables.
    local element
    local query

    # Read the query element and shift the arguments such that only the
    # array to search through remains.
    query="$1"
    shift

    # Iterate through the array and compare each element to the query.
    # Output 0 on success, else 1.
    for element in "$@"; do
        if [[ "${element}" == "${query}" ]]; then
            printf true
            return
        fi
    done

    printf false
}

function argparser_is_variable_bool() {
    # Check if a variable's value is a boolean.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Output:
    # - true, if the variable's value is a boolean
    # - false, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == true || "${var}" == false ]]; then
        printf true
    else
        printf false
    fi
}

function argparser_is_variable_char() {
    # Check if a variable's value is a (printable) character.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Output:
    # - true, if the variable's value is a character
    # - false, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == [[:print:]] ]]; then
        printf true
    else
        printf false
    fi
}

function argparser_is_variable_identifier() {
    # Check if a variable's value is usable as Bash variable identifier.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Output:
    # - true, if the variable's value is usable as identifier
    # - false, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == [[:alpha:]_]+([[:word:]]) ]]; then
        printf true
    else
        printf false
    fi
}

function argparser_is_variable_int() {
    # Check if a variable's value is an integer.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Output:
    # - true, if the variable's value is an integer
    # - false, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == ?([+-])+([[:digit:]]) ]]; then
        printf true
    else
        printf false
    fi
}

function argparser_is_variable_uint() {
    # Check if a variable's value is an unsigned integer.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Output:
    # - true, if the variable's value is an unsigned integer
    # - false, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == +([[:digit:]]) ]]; then
        printf true
    else
        printf false
    fi
}

function argparser_check_color_or_style() {
    # Check if the specified colors and/or styles are implemented for
    # argparser_colorize.
    #
    # Arguments:
    # - $1: the colors and/or styles to use as comma-separated list
    #
    # Output:
    # - true, if all colors and/or styles are implemented
    # - false, else

    # Define the local variables.
    local -a colors
    local request
    local requests
    local style
    local -a styles

    # Read the argument.
    requests="$1"

    # Define the arrays of implemented colors and styles.
    # shellcheck disable=SC2190  # Indexed, not associative array.
    colors=(
        black
        red
        green
        yellow
        blue
        magenta
        cyan
        white
    )

    # shellcheck disable=SC2190  # Indexed, not associative array.
    styles=(
        normal
        bold
        faint
        italic
        underline
        double
        overline
        crossed-out
        blink
        reverse
    )

    # Split the requested color and/or style on commas and print any.
    # Then, print the string and reset the color and style.  If a
    # non-existing color or style is requested, abort the script with
    # an error message.
    IFS="," read -r -a requests <<< "${requests}"
    for request in "${requests[@]}"; do
        if [[ "$(argparser_in_array "${request}" "${colors[@]}")" == false \
            && "$(argparser_in_array "${request}" "${styles[@]}")" == false ]]
        then
            printf false
            return
        fi
    done

    printf true
}

function argparser_check_file() {
    # Check if a file exists, is a regular file, is readable, and has a
    # size greater than 0 bytes.
    #
    # Arguments:
    # - $1: the file to check
    #
    # Output:
    # - a bit mask with four bits set to 0 (true) if the file exists
    #   (first bit), is a regular file (second bit), is readable (third
    #   bit), and/or has a size greater than 0 bytes (fourth bit), else
    #   set to 1 (false)

    # Define the local variable.
    local file

    # Read the argument.
    file="$1"

    # Check the variable's value.
    if [[ -e "${file}" ]]; then
        printf 0
    else
        printf 1
    fi

    if [[ -f "${file}" ]]; then
        printf 0
    else
        printf 1
    fi

    if [[ -r "${file}" ]]; then
        printf 0
    else
        printf 1
    fi

    if [[ -s "${file}" ]]; then
        printf 0
    else
        printf 1
    fi
}

# Define the general argparser util functions.
function argparser_trim() {
    # Trim leading an trailing space characters from a string.
    #
    # Arguments:
    # - $1: the string to trim
    #
    # Output:
    # - the trimmed string

    # Define the local variables.
    local string

    # Read the argument.
    string="$1"

    # Trim and output the string.
    string="${string##+( )}"
    string="${string%%+( )}"
    printf '%s' "${string}"
}

function argparser_fold() {
    # Limit the width of a help message's column to max_col_width by
    # inserting line breaks.
    #
    # Arguments:
    # - $1: the line in the column in which to insert line breaks
    # - $2: the maximum width a column may have
    # - $3: the maximum width a column has yet
    #
    # Output:
    # - the line with introduced line breaks and the width of the widest
    #   line part as null-character-separated string

    # Define the local variables.
    local col_width
    local joined_words
    local largest_col_width
    local len_joined_words
    local len_word
    local line
    local max_col_width
    local word
    local words

    # Read the arguments.
    line="$1"
    max_col_width="$2"
    largest_col_width="$3"

    # Split the column element word by word (on whitespace), such that
    # line breaks aren't inserted into entire words.
    joined_words=""
    col_width=0
    read -r -a words <<< "${line}"

    for word in "${words[@]}"; do
        len_word="${#word}"
        len_joined_words="${#joined_words}"
        if (( len_word > max_col_width && len_joined_words == 0 )); then
            # As the word is too long, print the word and introduce a
            # line break.  Then, reset the column width.
            joined_words+="$(printf '%s\n' "${word}")"
            col_width=0
        elif (( col_width + len_word > max_col_width )); then
            # As the line with the word appended would be too long,
            # introduce a line break and print the word.  Then, set the
            # column width.
            joined_words+="$(printf '\n%s' "${word}")"
            col_width="${len_word}"
        elif (( len_joined_words == 0 )); then
            # For the first word, add the word only.  Increase the
            # column width by the word's length.
            joined_words="${word}"
            (( col_width += len_word ))
        else
            # For any other word, add the word and a leading space
            # character, else, the words would be concatenated without
            # separation (the splitting removed any whitespace).
            # Increase the column width appropriately.
            joined_words+=" ${word}"
            (( col_width += len_word + 1 ))
        fi

        # If the current line is wider than the previous ones, set the
        # largest_col_width correspondingly.  Later, this value is used
        # to determine the amount of whitespace between the columns'
        # elements.
        if (( col_width > largest_col_width )); then
            largest_col_width="${col_width}"
        fi
    done

    printf '%s\0' "${joined_words}" "${largest_col_width}"
}

function argparser_count() {
    # Count the number of occurences of an element in an array.
    #
    # Arguments:
    # - $1: the element to count
    # - $@: the array where to count the element
    #
    # Output:
    # - the count of the element

    # Define the local variables.
    local count
    local element
    local query

    # Read the query element and shift the arguments such that only the
    # array to search through remains.
    query="$1"
    shift

    # Count the number of occurences.
    count=0
    for element in "$@"; do
        if [[ "${element}" == "${query}" ]]; then
            (( count++ ))
        fi
    done
    printf '%s' "${count}"
}

function argparser_uniq() {
    # Filter adjacent duplicate entries from an array.
    #
    # Arguments:
    # - $@: the array to filter
    #
    # Output:
    # - the filtered array as string, concatenated and terminated with
    #   null characters

    # Define the local variables.
    local array
    local element
    local prev_element

    # Read the arguments.
    array=("$@")

    # Filter the array and output it.
    prev_element=""
    for element in "${array[@]}"; do
        if [[ "${element}" != "${prev_element}" ]]; then
            printf '%s\0' "${element}"
        fi
        prev_element="${element}"
    done
}

function argparser_quicksort() {
    # Sort an array using the recursive Quicksort algorithm with Tony
    # Hoare's partition scheme.
    #
    # Arguments:
    # - $1: the left boundary of the array bucket
    # - $2: the right boundary of the array bucket
    #
    # Nonlocals:
    # - array: the array to sort

    # Define the local variables.
    local i
    local j
    local left
    local pivot
    local pivot_point
    local right
    local swap

    # Read the arguments.
    left="$1"
    right="$2"

    # Sort the array by Quicksort.
    if (( left < right )); then
        # Set the start indices for the current bucket.  Take the
        # leftmost element as pivot.
        (( i = "${left}" - 1 ))
        (( j = "${right}" + 1 ))
        pivot="${array[left]}"

        while :; do
            # Traverse the array from the left, until a larger element
            # than the pivot has been found.
            (( i++ ))
            while [[ "${array[i]}" < "${pivot}" ]]; do
                (( i++ ))
            done

            # Traverse the array from the right, until a smaller element
            # than the pivot has been found.
            (( j-- ))
            while [[ "${array[j]}" > "${pivot}" ]]; do
                (( j-- ))
            done

            # If the indices have crossed each other, return.
            if (( i >= j )); then
                pivot_point="${j}"
                break
            fi

            # Swap the elements at the current indices.
            swap="${array[i]}"
            array[i]="${array[j]}"
            array[j]="${swap}"
        done

        # Recursively call the Quicksort algorithm to sort the buckets
        # individually.
        argparser_quicksort "${left}" "${pivot_point}"
        argparser_quicksort "$(( pivot_point + 1 ))" "${right}"
    fi
}

function argparser_sort() {
    # Sort an array, internally using the Quicksort algorithm.
    #
    # Arguments:
    # - $1: whether to reverse-sort the array
    # - $@: the array to sort
    #
    # Output:
    # - the sorted array as string, concatenated and terminated with
    #   null characters

    # Define the local variables.
    local array
    local i
    local reverse

    # Read the arguments.
    reverse="$1"
    shift
    array=("$@")

    # Sort the array and output it, possibly after reversing it.
    argparser_quicksort 0 "$(( "${#array[@]}" - 1 ))"
    if [[ "${reverse}" == true ]]; then
        for (( i = "${#array[@]}" - 1; i >= 0; i-- )); do
            printf '%s\0' "${array[i]}"
        done
    else
        printf '%s\0' "${array[@]}"
    fi
}

function argparser_colorize() {
    # Colorize and format the string using ANSI escape sequences.
    #
    # Arguments:
    # - $1: the colors and/or styles to use as comma-separated list
    # - $2: the string to colorize
    # - $3: the target to write to ("file" or "tty")
    #
    # Environment:
    # - ARGPARSER_USE_STYLES_IN_FILES (read-only)
    #
    # Output:
    # - the colorized string

    # Define the local variables.
    local -A colors
    local request
    local requests
    local string
    local style
    local -A styles
    local write_target

    # Read the arguments.
    requests="$1"
    string="$2"
    write_target="$3"

    # Define the associative arrays with colors or styles, respectively,
    # and their corresponding Select Graphic Rendition (SGR) ANSI escape
    # sequence codes.
    colors=(
        [black]=30
        [red]=31
        [green]=32
        [yellow]=33
        [blue]=34
        [magenta]=35
        [cyan]=36
        [white]=37
    )

    styles=(
        [normal]=22
        [bold]=1
        [faint]=2
        [italic]=3
        [underline]=4
        [double]=21
        [overline]=53
        [crossed-out]=9
        [blink]=5
        [reverse]=7
    )

    # Split the requested color and/or style on commas and print any.
    # Then, print the string and reset the color and style.  Possibly,
    # only use styles when writing to a terminal.  As argparser_colorize
    # is generally run through command substitution, [[ -t 1 ]] would
    # always be false, i.e., it is impossible to see if the final STDOUT
    # goes to a terminal.  Thus, the test is outsourced to the invoking
    # function and passed as command-line argument.
    if [[ "${ARGPARSER_USE_STYLES_IN_FILES}" == true \
        || "${write_target}" == "tty" ]]
    then
        IFS="," read -r -a requests <<< "${requests}"
        for request in "${requests[@]}"; do
            if [[ "$(argparser_in_array "${request}" \
                "${!colors[@]}")" == true ]]
            then
                printf '\e[%sm' "${colors[${request}]}"
            elif [[ "$(argparser_in_array "${request}" \
                "${!styles[@]}")" == true ]]
            then
                printf '\e[%sm' "${styles[${request}]}"
            fi
        done

        printf '%s\e[0m' "${string}"
    else
        printf '%s' "${string}"
    fi
}

# Define the argparser functions for checking the environment variables
# and reading, parsing, and checking the arguments definition.
function argparser_check_env_vars() {
    # Check if the argparser envirnoment variables accord to their
    # definition.  This should always be true for production scripts,
    # but maybe not while testing, and also not if the user is allowed
    # to set the variables himself.
    #
    # The following environment variables are unchecked:
    # - ARGPARSER_DICTIONARY (checked earlier / auto-set)
    # - ARGPARSER_LANGUAGE (arbitrary value)
    # - ARGPARSER_POSITIONAL_ARG_GROUP (arbitrary value)
    # - ARGPARSER_SCRIPT_NAME (arbitrary value)
    # - ARGPARSER_VERSION (arbitrary value)
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    # - ARGPARSER_ALLOW_OPTION_ABBREVIATION (read-only)
    # - ARGPARSER_ALLOW_OPTION_MERGING (read-only)
    # - ARGPARSER_ARG_ARRAY_NAME (read-only)
    # - ARGPARSER_ARG_DEF_FILE (read-only)
    # - ARGPARSER_ARG_DEF_FILE_HAS_HEADER (read-only)
    # - ARGPARSER_ARG_DEF_HAS_HEADER (read-only)
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_CHECK_ARG_DEFINITION (read-only)
    # - ARGPARSER_CHECK_ENV_VARS (read-only)
    # - ARGPARSER_COUNT_FLAGS (read-only)
    # - ARGPARSER_ERROR_EXIT_CODE
    # - ARGPARSER_ERROR_STYLE
    # - ARGPARSER_HELP_EXIT_CODE (read-only)
    # - ARGPARSER_HELP_FILE (read-only)
    # - ARGPARSER_HELP_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_HELP_FILE_KEEP_COMMENTS (read-only)
    # - ARGPARSER_HELP_STYLE (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_1 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_2 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_3 (read-only)
    # - ARGPARSER_READ_ARGS (read-only)
    # - ARGPARSER_SET_ARGS (read-only)
    # - ARGPARSER_SET_ARRAYS (read-only)
    # - ARGPARSER_SILENCE_ERRORS (read-only)
    # - ARGPARSER_SILENCE_WARNINGS (read-only)
    # - ARGPARSER_TRANSLATION_FILE (read-only)
    # - ARGPARSER_UNSET_ARGS (read-only)
    # - ARGPARSER_UNSET_ENV_VARS (read-only)
    # - ARGPARSER_UNSET_FUNCTIONS (read-only)
    # - ARGPARSER_USAGE_EXIT_CODE (read-only)
    # - ARGPARSER_USAGE_FILE (read-only)
    # - ARGPARSER_USAGE_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_USAGE_FILE_KEEP_COMMENTS (read-only)
    # - ARGPARSER_USAGE_MESSAGE_OPTION_TYPE (read-only)
    # - ARGPARSER_USAGE_MESSAGE_ORIENTATION (read-only)
    # - ARGPARSER_USAGE_STYLE (read-only)
    # - ARGPARSER_USE_STYLES_IN_FILES (read-only)
    # - ARGPARSER_VERSION_EXIT_CODE (read-only)
    # - ARGPARSER_VERSION_STYLE (read-only)
    # - ARGPARSER_WARNING_STYLE (read-only)

    # Define the local variables.
    local attributes
    local error_message
    local -a error_messages
    local i
    local var
    local var_1
    local var_2
    local -a vars

    # Check if all environment variables expected to be booleans are
    # true or false.  Else, output an error message.
    error_messages=( )
    vars=(
        ARGPARSER_ADD_HELP
        ARGPARSER_ADD_USAGE
        ARGPARSER_ADD_VERSION
        ARGPARSER_ALLOW_OPTION_ABBREVIATION
        ARGPARSER_ALLOW_OPTION_MERGING
        ARGPARSER_ARG_DEF_FILE_HAS_HEADER
        ARGPARSER_ARG_DEF_HAS_HEADER
        ARGPARSER_CHECK_ARG_DEFINITION
        ARGPARSER_CHECK_ENV_VARS
        ARGPARSER_COUNT_FLAGS
        ARGPARSER_HELP_FILE_KEEP_COMMENTS
        ARGPARSER_READ_ARGS
        ARGPARSER_SET_ARGS
        ARGPARSER_SET_ARRAYS
        ARGPARSER_SILENCE_ERRORS
        ARGPARSER_SILENCE_WARNINGS
        ARGPARSER_UNSET_ARGS
        ARGPARSER_UNSET_ENV_VARS
        ARGPARSER_UNSET_FUNCTIONS
        ARGPARSER_USAGE_FILE_KEEP_COMMENTS
        ARGPARSER_USE_STYLES_IN_FILES
    )
    for var in "${vars[@]}"; do
        if [[ "$(argparser_is_variable_bool "${!var}")" == false ]]; then
            error_message="Error: The environment variable \"%s\" is set to "
            error_message+="\"%s\", but must be a boolean, i.e., true or "
            error_message+="false."
            error_message="$(argparser_translate "Error env var bool" \
                "${error_message}" "${var}" "${!var}")"
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables expected to be characters are
    # one-character strings.  Else, output an error message.
    vars=(
        ARGPARSER_ARG_DELIMITER_1
        ARGPARSER_ARG_DELIMITER_2
        ARGPARSER_HELP_FILE_INCLUDE_CHAR
        ARGPARSER_USAGE_FILE_INCLUDE_CHAR
    )
    for var in "${vars[@]}"; do
        if [[ "$(argparser_is_variable_char "${!var}")" == false ]]; then
            error_message="Error: The environment variable \"%s\" is set to "
            error_message+="\"%s\", but must be a character, i.e., a string "
            error_message+="comprising one printable ASCII character."
            error_message="$(argparser_translate "Error env var char" \
                "${error_message}" "${var}" "${!var}")"
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables to be used as Bash variable
    # identifiers start with a letter or underscore and contain only
    # letters, digits, and underscores.  Else, output an error message.
    vars=(
        ARGPARSER_ARG_ARRAY_NAME
    )
    for var in "${vars[@]}"; do
        if [[ "$(argparser_is_variable_identifier "${!var}")" == false ]]; then
            error_message="Error: The environment variable \"%s\" is set to "
            error_message+="\"%s\", but designed to be used as Bash variable "
            error_message+="identifier, i.e., its value must start with a "
            error_message+="letter or underscore and contain only letters, "
            error_message+="digits, and underscores."
            error_message="$(argparser_translate "Error env var identifier" \
                "${error_message}" "${var}" "${!var}")"
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables expected to be integers are
    # only digits, possibly with a leading sign.  Else, output an error
    # message.
    vars=(
        ARGPARSER_ERROR_EXIT_CODE
        ARGPARSER_HELP_EXIT_CODE
        ARGPARSER_USAGE_EXIT_CODE
        ARGPARSER_VERSION_EXIT_CODE
    )
    for var in "${vars[@]}"; do
        if [[ "$(argparser_is_variable_int "${!var}")" == false ]]; then
            error_message="Error: The environment variable \"%s\" is set to "
            error_message+="\"%s\", but must be an integer, i.e., comprise "
            error_message+="only digits and possibly a leading sign."
            error_message="$(argparser_translate "Error env var int" \
                "${error_message}" "${var}" "${!var}")"
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables expected to be unsigned
    # integers are only digits.  Else, output an error message.
    vars=(
        ARGPARSER_MAX_COL_WIDTH_1
        ARGPARSER_MAX_COL_WIDTH_2
        ARGPARSER_MAX_COL_WIDTH_3
    )
    for var in "${vars[@]}"; do
        if [[ "$(argparser_is_variable_uint "${!var}")" == false ]]; then
            error_message="Error: The environment variable \"%s\" is set to "
            error_message+="\"%s\", but must be an unsigned integer, i.e., "
            error_message+="comprise only digits and no sign."
            error_message="$(argparser_translate "Error env var uint" \
                "${error_message}" "${var}" "${!var}")"
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables expected to point to files have
    # the referenced file existing, readable, and with a size greater
    # than 0 bytes.  Else, output an error message.
    vars=(
        ARGPARSER_ARG_DEF_FILE
        ARGPARSER_HELP_FILE
        ARGPARSER_USAGE_FILE
    )
    for var in "${vars[@]}"; do
        attributes="$(argparser_check_file "${!var}")"
        if [[ -n "${!var}" && "${attributes}" != 0000 ]]; then
            error_message="Error: The environment variable \"%s\" is set to "
            error_message+="\"%s\", but the referenced file "
            case "${attributes}" in
                0001) error_message+="is empty." ;;
                0010) error_message+="is not readable." ;;
                0011) error_message+="is not readable and empty." ;;
                0100) error_message+="is not a regular file." ;;
                0101) error_message+="is not a regular file and empty." ;;
                0110)
                    error_message+="is not a regular file and not readable."
                    ;;
                0111)
                    error_message+="is not a regular file, not readable, and "
                    error_message+="empty."
                    ;;
                1111) error_message+="does not exist." ;;
            esac
            error_message="$(argparser_translate \
                "Error env var file ${attributes}" "${error_message}" \
                "${var}" "${!var}")"
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables with a limited set of allowed
    # values have their values lying in them.  Else, output an error
    # message.
    # First, check if all environment variables for styles only have
    # values supported by argparser_colorize.
    vars=(
        ARGPARSER_ERROR_STYLE
        ARGPARSER_HELP_STYLE
        ARGPARSER_USAGE_STYLE
        ARGPARSER_VERSION_STYLE
        ARGPARSER_WARNING_STYLE
    )
    for var in "${vars[@]}"; do
        if [[ "$(argparser_check_color_or_style "${!var}")" == false ]]; then
            error_message="Error: The environment variable \"%s\" is set to "
            error_message+="\"%s\", but the comma-separated values must lie "
            error_message+="in {black, red, green, yellow, blue, magenta, "
            error_message+="cyan, white} for colors and in {normal, bold, "
            error_message+="faint, italic, underline, double, overline, "
            error_message+="crossed-out, blink, reverse} for styles."
            error_message="$(argparser_translate "Error env var styles" \
                "${error_message}" "${var}" "${!var}")"
            error_messages+=("${error_message}")
        fi
    done

    # Then, check the option type for usage messages.
    if [[ "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" != "long" \
        && "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" != "short" ]]
    then
        error_message="Error: The environment variable "
        error_message+="\"ARGPARSER_USAGE_MESSAGE_OPTION_TYPE\" must be "
        error_message+="either set to \"long\" or \"short\", but is \"%s\"."
        error_message="$(argparser_translate "Error env var option type" \
            "${error_message}" "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}")"
        error_messages+=("${error_message}")
    fi

    # Then, check the orientation for usage messages.
    if [[ "${ARGPARSER_USAGE_MESSAGE_ORIENTATION}" != "row" \
        && "${ARGPARSER_USAGE_MESSAGE_ORIENTATION}" != "column" ]]
    then
        error_message="Error: The environment variable "
        error_message+="\"ARGPARSER_USAGE_MESSAGE_ORIENTATION\" must be "
        error_message+="either set to \"row\" or \"column\", but is \"%s\"."
        error_message="$(argparser_translate "Error env var orientation" \
            "${error_message}" "${ARGPARSER_USAGE_MESSAGE_ORIENTATION}")"
        error_messages+=("${error_message}")
    fi

    # Check the environment variables with mutually exclusive values.
    # First, check that the argument definition delimiters are
    # different.
    if [[ "${ARGPARSER_ARG_DELIMITER_1}" == "${ARGPARSER_ARG_DELIMITER_2}" ]]
    then
        error_message="Error: The environment variables "
        error_message+="\"ARGPARSER_ARG_DELIMITER_1\" and "
        error_message+="\"ARGPARSER_ARG_DELIMITER_2\" must have different "
        error_message+="values."
        error_message="$(argparser_translate "Error env var delimiters" \
            "${error_message}")"
        error_messages+=("${error_message}")
    fi

    # Then, check that the arguments definition file, the help file, the
    # translation file, and the usage file are different from each
    # other, if given.
    vars=(
        ARGPARSER_ARG_DEF_FILE
        ARGPARSER_HELP_FILE
        ARGPARSER_TRANSLATION_FILE
        ARGPARSER_USAGE_FILE
    )
    for i in "${!vars[@]}"; do
        var_1="${vars[i]}"
        for var_2 in "${vars[@]:$((i + 1))}"; do
            if [[ -n "${!var_1}" && "${!var_1}" == "${!var_2}" ]]; then
                error_message="Error: The environment variables \"%s\" and "
                error_message+="\"%s\" point to the same file."
                error_message="$(argparser_translate "Error env var files" \
                    "${error_message}" "${var_1}" "${var_2}")"
                error_messages+=("${error_message}")
            fi
        done
    done

    # If there are error messages, colorize, sort, and print them, then
    # exit, as parsing the arguments with a faulty environment variable
    # configuration might be impossible.  If ${ARGPARSER_ERROR_STYLE} is
    # among the faulty variables, the error messages cannot be properly
    # colorized.  Thus, set the style to its default value.  The same
    # holds true for ${ARGPARSER_ERROR_EXIT_CODE}.
    for error_message in "${error_messages[@]}"; do
        if [[ "${error_message}" == *"ARGPARSER_ERROR_EXIT_CODE"* ]]; then
            ARGPARSER_ERROR_EXIT_CODE=1
        elif [[ "${error_message}" == *"ARGPARSER_ERROR_STYLE"* ]]; then
            ARGPARSER_ERROR_STYLE="red,bold,reverse"
        fi
    done

    argparser_print_error_or_warning_message "error" false true \
        "${error_messages[@]}"
}

function argparser_read_args_definition() {
    # Read the arguments definition from the script and arguments
    # definition file, if provided.
    #
    # Arguments:
    # - $@: the arguments known to the script
    #
    # Environment:
    # - ARGPARSER_ARG_DEF_FILE (read-only)
    # - ARGPARSER_ARG_DEF_FILE_HAS_HEADER (read-only)
    # - ARGPARSER_ARG_DEF_HAS_HEADER (read-only)
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    #
    # Output:
    # - the parsed arguments definition as message or an error message,
    #   starting with "File: ", "Script: ", or "Error: " (translated),
    #   concatenated and terminated with null characters

    # Define the local variables.
    local arg
    local arg_key
    local -a args
    local def_pattern
    local error_message
    local header
    local i
    local key_pattern
    local line
    local lines

    # Read the arguments.
    # shellcheck disable=SC2190  # Indexed, not associative array.
    args=("$@")

    # Define the pattern how the arguments definition's keys look like,
    # as well as the pattern of the entire definition.  For the default
    # value of ${ARGPARSER_ARG_DELIMITER_1}, a colon, the definition
    # pattern describes alternating sequences of eleven non-colons,
    # i.e., "+([^:])", and ten colons, i.e., ":", in Bash's extglob
    # syntax. In PCRE syntax, the non-colon pattern would be written as
    # "[^:]+".  The key pattern only consists of one non-colon pattern.
    # This reflects the structure of the arguments definition
    # irrespective of the order of the columns.
    key_pattern="+([^${ARGPARSER_ARG_DELIMITER_1}])"
    def_pattern="${key_pattern}"
    for (( i = 0; i < 10; i++ )); do
        def_pattern+="${ARGPARSER_ARG_DELIMITER_1}${key_pattern}"
    done

    # Read and output the header for a possible arguments definition in
    # the script. If none is given or the first line does not match the
    # columnar argparser syntax matched by the definition pattern, then
    # assume a default header and re-read the arguments, leaving the
    # zeroth element, interpreted as header in the loop below, empty.

    # shellcheck disable=SC2053  # Intentional pattern matching.
    # shellcheck disable=SC2190  # Indexed, not associative array.
    if [[ "${ARGPARSER_ARG_DEF_HAS_HEADER}" == false \
        || "${args[0]}" != ${def_pattern} ]]
    then
        args=( )
        args[0]="id:short_opts:long_opts:val_names:defaults:choices:type:"
        args[0]+="arg_no:arg_group:notes:help"
        for arg in "$@"; do
            args+=("${arg}")
        done
    fi
    header="${args[0]}"
    printf 'Script: %s\0' "${header}"

    # If ${ARGPARSER_ARG_DEF_FILE} isn't set to the empty string, read
    # the arguments definition file and output the header.  Again, if
    # none is given, assume a default header.
    if [[ -n "${ARGPARSER_ARG_DEF_FILE}" ]]; then
        if [[ "${ARGPARSER_ARG_DEF_FILE_HAS_HEADER}" == true ]]; then
            mapfile -t lines < "${ARGPARSER_ARG_DEF_FILE}"
        else
            mapfile -t -O 1 lines < "${ARGPARSER_ARG_DEF_FILE}"
            lines[0]="id:short_opts:long_opts:val_names:defaults:choices:type:"
            lines[0]+="arg_no:arg_group:notes:help"
        fi
        header="${lines[0]}"
        printf 'File: %s\0' "${header}"
    fi

    # Get the definition for each argument (excluding the header as
    # zeroth element in ${args}).  These arguments may either be defined
    # in the script, where they're given in the columnar argparser
    # syntax, or in a separate arguments definition file, so they're
    # only given as their key.  If the structure differs, output an
    # error message.
    for arg in "${args[@]:1}"; do
        # shellcheck disable=SC2053  # Intentional pattern matching.
        if [[ "${arg}" == ${def_pattern} ]]; then
            # The argument matches the entire definition pattern.
            # Output its definition.
            printf 'Script: %s\0' "${arg}"
        elif [[ "${arg}" == ${key_pattern} && -n "${ARGPARSER_ARG_DEF_FILE}" ]]
        then
            # The argument matches the key pattern and an arguments
            # definition file is given. Iterate over all arguments
            # definition lines from the file. When the argument key in
            # one line matches the given key and the line matches the
            # definition pattern, output the key and definition, then
            # continue the outer loop (with index 2).  If the inner loop
            # doesn't get aborted by the continuation, it means that no
            # fitting argument definition has been found.  Thus, output
            # an error message.
            for line in "${lines[@]:1}"; do
                arg_key="${line%%"${ARGPARSER_ARG_DELIMITER_1}"*}"
                arg_key="$(argparser_trim "${arg_key}")"
                if [[ "${arg_key}" == "${arg}" ]]; then
                    if [[ "${line}" == ${def_pattern} ]]; then
                        printf 'File: %s\0' "${line}"
                        continue 2
                    else
                        error_message="Error: Invalid argument definition for "
                        error_message+="\"%s\"."
                        error_message="$(argparser_translate \
                            "Error wrong arg def" "${error_message}" "${arg}")"
                        printf '%s\0' "${error_message}"
                        continue 2
                    fi
                fi
            done
            error_message="Error: No argument definition for \"%s\"."
            error_message="$(argparser_translate "Error no arg def" \
                "${error_message}" "${arg}")"
            printf '%s\0' "${error_message}"
        else
            # The argument doesn't match any pattern and is thus deemed
            # invalid, so output an error message.
            error_message="Error: Invalid argument definition for \"%s\"."
            error_message="$(argparser_translate "Error wrong arg def" \
                "${error_message}" "${arg}")"
            printf '%s\0' "${error_message}"
        fi
    done
}

function argparser_parse_args_definition() {
    # Parse the arguments definition into an associative array per CSV
    # column.
    #
    # Arguments:
    # - $1: the origin of the arguments definition ("script" or "file")
    # - $@: the indexed array holding the arguments definition, the
    #       first line of which being the header
    #
    # Nonlocals:
    # - all_arg_groups: the associative array holding the argument
    #   groups
    # - all_arg_numbers: the associative array holding the argument
    #   numbers
    # - all_choice_values: the associative array holding the choice
    #   values
    # - all_default_values: the associative array holding the default
    #   values
    # - all_help_texts: the associative array holding the help texts
    # - all_long_options: the associative array holding the long option
    #   names
    # - all_notes: the associative array holding the notes
    # - all_positional_args: the indexed array holding the positional
    #   argument names
    # - all_short_options: the associative array holding the short
    #   option names
    # - all_types: the associative array holding the argument types
    # - all_value_names: the associative array holding the value names
    #
    # Environment:
    # - ARGPARSER_ARG_DEF_FILE (read-only)
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_SCRIPT_NAME (read-only)

    # Define the local variables.
    local arg_group
    local arg_key
    local arg_number
    local -a args_definition
    local choice_values
    local column_index
    local default_values
    local definition_type
    local error_message
    local -a error_messages
    local field
    local -A fields
    local -a header
    local help_text
    local i
    local -a line
    local long_options
    local notes
    local short_options
    local type
    local value_names

    # Read the arguments.
    definition_type="$1"
    shift
    args_definition=("$@")

    # Read the first line (the header) of ${args_definition} to get the
    # column indices for the fields.  Strip leading and trailing spaces.
    IFS="${ARGPARSER_ARG_DELIMITER_1}" read -r -a header \
        <<< "${args_definition[0]}"
    for column_index in "${!header[@]}"; do
        header[column_index]="$(argparser_trim "${header[column_index]}")"
    done

    # Get the column indices of all fields known to the current
    # argparser version.
    fields=(
        [id]=""
        [short_opts]=""
        [long_opts]=""
        [val_names]=""
        [defaults]=""
        [choices]=""
        [type]=""
        [arg_no]=""
        [arg_group]=""
        [notes]=""
        [help]=""
    )

    for field in "${!fields[@]}"; do
        for column_index in "${!header[@]}"; do
            if [[ "${header[column_index]}" == "${field}" ]]; then
                fields[${field}]="${column_index}"
            fi
        done
    done

    # If any column isn't given, output an error message.
    error_messages=( )
    for field in "${!fields[@]}"; do
        column_index="${fields[${field}]}"
        if [[ -z "${column_index}" ]]; then
            if [[ "${definition_type}" == "script" ]]; then
                error_message="Error: In the arguments definition in \"%s\", "
                error_message+="the column \"%s\" is missing."
                error_message="$(argparser_translate "Error arg def field" \
                    "${error_message}" "${ARGPARSER_SCRIPT_NAME}" "${field}")"
            elif [[ "${definition_type}" == "file" ]]; then
                error_message="Error: In the arguments definition file "
                error_message+="\"%s\", the column \"%s\" is missing."
                error_message="$(argparser_translate \
                    "Error arg def file field" "${error_message}" \
                    "${ARGPARSER_ARG_DEF_FILE}" "${field}")"
            fi
            error_messages+=("${error_message}")
        fi
    done

    # If there are error messages, colorize, sort, and print them, then
    # exit.
    argparser_print_error_or_warning_message "error" false true \
        "${error_messages[@]}"

    # Read all lines of the arguments definition and save the fields in
    # an associative array per column, using the argument identifier as
    # key and the definition in the field as value.  If neither a short
    # nor a long option name is given, interpret the argument as
    # positional and add it to the respective indexed array.
    for line in "${args_definition[@]:1}"; do
        IFS="${ARGPARSER_ARG_DELIMITER_1}" read -r -a line <<< "${line}"
        arg_key="$(argparser_trim "${line[${fields["id"]}]}")"

        short_options="$(argparser_trim "${line[${fields["short_opts"]}]}")"
        long_options="$(argparser_trim "${line[${fields["long_opts"]}]}")"

        if [[ "${short_options}" == "-" && "${long_options}" == "-" ]]; then
            all_positional_args+=("${arg_key}")
        else
            all_short_options[${arg_key}]="${short_options}"
            all_long_options[${arg_key}]="${long_options}"
        fi

        value_names="$(argparser_trim "${line[${fields["val_names"]}]}")"
        all_value_names[${arg_key}]="${value_names}"

        default_values="$(argparser_trim "${line[${fields["defaults"]}]}")"
        all_default_values[${arg_key}]="${default_values}"

        choice_values="$(argparser_trim "${line[${fields["choices"]}]}")"
        all_choice_values[${arg_key}]="${choice_values}"

        type="$(argparser_trim "${line[${fields["type"]}]}")"
        all_types[${arg_key}]="${type}"

        arg_number="$(argparser_trim "${line[${fields["arg_no"]}]}")"
        all_arg_numbers[${arg_key}]="${arg_number}"

        arg_group="$(argparser_trim "${line[${fields["arg_group"]}]}")"
        all_arg_groups[${arg_key}]="${arg_group}"

        notes="$(argparser_trim "${line[${fields["notes"]}]}")"
        all_notes[${arg_key}]="${notes}"

        help_text="$(argparser_trim "${line[${fields["help"]}]}")"
        all_help_texts[${arg_key}]="${help_text}"
    done
}

function argparser_check_args_definition_names() {
    # Check if the script's arguments' definition is consistent
    # regarding the short and long option names.  This should always be
    # true for production scripts, but maybe not while testing.
    #
    # Nonlocals:
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    #
    # Output:
    # - the error messages, starting with "Error: ", concatenated and
    #   terminated with null characters

    # Define the local variables.
    local arg_key
    local -a arg_keys
    local count
    local -A checked_long_options
    local -A checked_short_options
    local error_message
    local long_option
    local -a long_options
    local short_option
    local -a short_options

    # Get and sort all argument keys (identifiers), such that the
    # following loop is performed in alphabetical order of the
    # arguments, such that the error messages for duplicate option names
    # refer to the lexicographically earlier argument.
    mapfile -d "" -t arg_keys \
        < <(argparser_sort false "${!all_short_options[@]}")

    # Check that no short or long option is given twice for the same
    # argument or among multiples.
    for arg_key in "${arg_keys[@]}"; do
        # Read the argument's definition.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
            <<< "${all_short_options[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
            <<< "${all_long_options[${arg_key}]}"

        # If more than one short option name is given, check if any is a
        # hyphen, which must only once be used as placeholder for
        # missing short options.  Then, check if any short option name
        # is longer than one character, and if it is given multiple
        # times in the current argument's definition or across all yet
        # investigated arguments' definitions.  If only one short option
        # name is given, the hyphen is a legit value, so don't check
        # this.
        if (( "${#short_options[@]}" > 1 )) \
            && [[ "$(argparser_in_array "-" "${short_options[@]}")" == true ]]
        then
            # Check if a hyphen is included in the short option names.
            error_message="Error: The argument with the identifier \"%s\" has "
            error_message+="a placeholder \"-\" given as one of the %s short "
            error_message+="option names, instead of a legit name."
            error_message="$(argparser_translate \
                "Error arg def short name hyphen" "${error_message}" \
                "${arg_key}" "${#short_options[@]}")"
            printf '%s\0' "${error_message}"
        fi

        for short_option in "${short_options[@]}"; do
            if [[ "${ARGPARSER_ADD_HELP}" == true \
                && "${short_option}" == "h" ]]
            then
                # Check if a short option name uses the reserved flag
                # for the help message.
                error_message="Error: The argument with the identifier "
                error_message+="\"%s\" has the short option -h defined, which "
                error_message+="is reserved for invoking the help message."
                error_message="$(argparser_translate \
                    "Error arg def short name help" "${error_message}" \
                    "${arg_key}")"
                printf '%s\0' "${error_message}"
            elif [[ "${ARGPARSER_ADD_USAGE}" == true \
                && "${short_option}" == "u" ]]
            then
                # Check if a short option name uses the reserved flag
                # for the usage message.
                error_message="Error: The argument with the identifier "
                error_message+="\"%s\" has the short option -u defined, which "
                error_message+="is reserved for invoking the usage message."
                error_message="$(argparser_translate \
                    "Error arg def short name usage" "${error_message}" \
                    "${arg_key}")"
                printf '%s\0' "${error_message}"
            elif [[ "${ARGPARSER_ADD_VERSION}" == true \
                && "${short_option}" == "V" ]]
            then
                # Check if a short option name uses the reserved flag
                # for the version message.
                error_message="Error: The argument with the identifier "
                error_message+="\"%s\" has the short option -V defined, which "
                error_message+="is reserved for invoking the version message."
                error_message="$(argparser_translate \
                    "Error arg def short name version" "${error_message}" \
                    "${arg_key}")"
                printf '%s\0' "${error_message}"
            elif [[ "${short_option}" != "-" ]]; then
                # Check if a short option name is more than one
                # character long.
                if (( "${#short_option}" > 1 )); then
                    error_message="Error: The argument with the identifier "
                    error_message+="\"%s\" has the short option \"-%s\" "
                    error_message+="defined with more than 1 character length."
                    error_message="$(argparser_translate \
                        "Error arg def short name length" "${error_message}" \
                        "${arg_key}" "${short_option}")"
                    printf '%s\0' "${error_message}"
                fi

                # Check if the short option name is given multiple times
                # in the current argument's definition.
                count="$(argparser_count "${short_option}" \
                    "${short_options[@]}")"
                if (( count > 1 )); then
                    error_message="Error: The argument with the identifier "
                    error_message+="\"%s\" has the short option \"-%s\" given "
                    error_message+="%s times."
                    error_message="$(argparser_translate \
                        "Error arg def short name inner duplication" \
                        "${error_message}" "${arg_key}" "${short_option}" \
                        "${count}")"
                    printf '%s\0' "${error_message}"
                fi

                # Check if the short option name is already given in
                # another argument's definition.
                if [[ "$(argparser_in_array "${short_option}" \
                    "${!checked_short_options[@]}")" == true \
                    && "${checked_short_options[${short_option}]}" != \
                    "${arg_key}" ]]
                then
                    error_message="Error: The argument with the identifier "
                    error_message+="\"%s\" has the short option \"-%s\" "
                    error_message+="given, but that is already in use by "
                    error_message+="\"%s\"."
                    error_message="$(argparser_translate \
                        "Error arg def short name outer duplication" \
                        "${error_message}" "${arg_key}" "${short_option}" \
                        "${checked_short_options[${short_option}]}")"
                    printf '%s\0' "${error_message}"
                fi

                # Add the short option name to the associative array of
                # all short option names.
                checked_short_options[${short_option}]="${arg_key}"
            fi
        done

        # Perform the same tests for the long option names for having a
        # hyphen among the long option names or if any long option name
        # is shorter than two characters, and if it is given multiple
        # times in the current argument's definition or across all yet
        # investigated arguments' definitions.
        if (( "${#long_options[@]}" > 1 )) \
            && [[ "$(argparser_in_array "-" "${long_options[@]}")" == true ]]
        then
            # Check if a hyphen is included in the long option names.
            error_message="Error: The argument with the identifier \"%s\" has "
            error_message+="a placeholder \"-\" given as one of the %s long "
            error_message+="option names, instead of a legit name."
            error_message="$(argparser_translate \
                "Error arg def long name hyphen" "${error_message}" \
                "${arg_key}" "${#long_options[@]}")"
            printf '%s\0' "${error_message}"
        fi

        for long_option in "${long_options[@]}"; do
            if [[ "${ARGPARSER_ADD_HELP}" == true \
                && "${long_option}" == "help" ]]
            then
                # Check if a long option name uses the reserved flag for
                # the help message.
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has the long option --help defined, which is "
                error_message+="reserved for invoking the help message."
                error_message="$(argparser_translate \
                    "Error arg def long name help" "${error_message}" \
                    "${arg_key}")"
                printf '%s\0' "${error_message}"
            elif [[ "${ARGPARSER_ADD_USAGE}" == true \
                && "${long_option}" == "usage" ]]
            then
                # Check if a long option name uses the reserved flag for
                # the usage message.
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has the long option --usage defined, which is "
                error_message+="reserved for invoking the usage message."
                error_message="$(argparser_translate \
                    "Error arg def long name usage" "${error_message}" \
                    "${arg_key}")"
                printf '%s\0' "${error_message}"
            elif [[ "${ARGPARSER_ADD_VERSION}" == true \
                && "${long_option}" == "version" ]]
            then
                # Check if a long option name uses the reserved flag for
                # the version message.
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has the long option --version defined, which "
                error_message+="is reserved for invoking the version message."
                error_message="$(argparser_translate \
                    "Error arg def long name version" "${error_message}" \
                    "${arg_key}")"
                printf '%s\0' "${error_message}"
            elif [[ "${long_option}" != "-" ]]; then
                # Check if a long option name is less than two
                # characters long.
                if (( "${#long_option}" < 2 )); then
                    error_message="Error: The argument with the identifier "
                    error_message+="\"%s\" has the long option \"--%s\" "
                    error_message+="defined with less than 2 characters "
                    error_message+="length."
                    error_message="$(argparser_translate \
                        "Error arg def long name length" "${error_message}" \
                        "${arg_key}" "${long_option}")"
                    printf '%s\0' "${error_message}"
                fi

                # Check if the long option name is given multiple times
                # in the current argument's definition.
                count="$(argparser_count "${long_option}" \
                    "${long_options[@]}")"
                if (( count > 1 )); then
                    error_message="Error: The argument with the identifier "
                    error_message+="\"%s\" has the long option \"--%s\" given "
                    error_message+="%s times."
                    error_message="$(argparser_translate \
                        "Error arg def long name inner duplication" \
                        "${error_message}" "${arg_key}" "${long_option}" \
                        "${count}")"
                    printf '%s\0' "${error_message}"
                fi

                # Check if the long option name is already given in
                # another argument's definition.
                if [[ "$(argparser_in_array "${long_option}" \
                    "${!checked_long_options[@]}")" == true \
                    && "${checked_long_options[${long_option}]}" != \
                    "${arg_key}" ]]
                then
                    error_message="Error: The argument with the identifier "
                    error_message+="\"%s\" has the long option \"--%s\" "
                    error_message+="given, but that is already in use by "
                    error_message+="\"%s\"."
                    error_message="$(argparser_translate \
                        "Error arg def long name outer duplication" \
                        "${error_message}" "${arg_key}" "${long_option}" \
                        "${checked_long_options[${long_option}]}")"
                    printf '%s\0' "${error_message}"
                fi

                # Add the long option name to the associative array of
                # all long option names.
                checked_long_options[${long_option}]="${arg_key}"
            fi
        done
    done
}

function argparser_check_args_definition_positional_values() {
    # Check if the script's arguments' definition is consistent
    # regarding the default and choice values, as well as the number of
    # arguments for positional arguments.  This should always be true
    # for production scripts, but maybe not while testing.
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_choice_values: the associative array holding the choice
    #   values (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_notes: the associative array holding the notes (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    # - all_types: the associative array holding the argument types
    #   (read-only)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    #
    # Output:
    # - the error messages, starting with "Error: " (translated),
    #   concatenated and terminated with null characters

    # Define the local variables.
    local arg_key
    local arg_number
    local choice_value
    local -a choice_values
    local default_value
    local -a default_values
    local error_message
    local infinite_arg_number_arg
    local note
    local -a notes
    local optional_arg
    local type

    # Check the consistency of all positional arguments.
    infinite_arg_number_arg=""
    optional_arg=""
    for arg_key in "${all_positional_args[@]}"; do
        # Read the argument's definition.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a default_values \
            <<< "${all_default_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values \
            <<< "${all_choice_values[${arg_key}]}"
        type="${all_types[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a notes \
            <<< "${all_notes[${arg_key}]}"

        # Check if the number of default values equals the number of
        # required values.  Else, output an error message.
        if [[ "${arg_number}" != "+" \
            && "${default_values[0]}" != "-" \
            && "${#default_values[@]}" != "${arg_number}" ]]
        then
            if [[ "${arg_number}" == 1 ]]; then
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" requires 1 value, but has "
                error_message+="%s given as default."
                error_message="$(argparser_translate \
                    "Error arg def pos default 1" "${error_message}" \
                    "${arg_key}" "${#default_values[@]}")"
                printf '%s\0' "${error_message}"
            else
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" requires %s values, but has "
                error_message+="%s given as default."
                error_message="$(argparser_translate \
                    "Error arg def pos default 2" "${error_message}" \
                    "${arg_key}" "${arg_number}" "${#default_values[@]}")"
                printf '%s\0' "${error_message}"
            fi
        fi

        # Check if the default values accord to the choice values, i.e.,
        # if each default value lies within the array of choice values.
        # Else, output an error message.
        if [[ "${choice_values[0]}" != "-" ]]; then
            for default_value in "${default_values[@]}"; do
                if [[ "${default_value}" != "-" \
                    && "$(argparser_in_array "${default_value}" \
                        "${choice_values[@]}")" == false ]]
                then
                    choice_value="$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; \
                        printf '%s' "${choice_values[*]}")"
                    default_value="$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; \
                        printf '%s' "${default_values[*]}")"

                    error_message="Error: The positional argument with the "
                    error_message+="identifier \"%s\" accepts only the choice "
                    error_message+="values {%s}, but has {%s} given as "
                    error_message+="default."
                    error_message="$(argparser_translate \
                        "Error arg def pos choice" "${error_message}" \
                        "${arg_key}" "${choice_value}" "${default_value}")"
                    printf '%s\0' "${error_message}"
                    break
                fi
            done
        fi

        # Check the number of arguments with default values.
        if [[ "${default_values[0]}" != "-" ]]; then
            # Check that no two positional arguments are optional, which
            # would be impossible to parse.
            if [[ -n "${optional_arg}" ]]; then
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" is optional, as is \"%s\", "
                error_message+="which renders parsing impossible."
                error_message="$(argparser_translate \
                    "Error arg def pos optionals" "${error_message}" \
                    "${arg_key}" "${optional_arg}")"
                printf '%s\0' "${error_message}"
            else
                optional_arg="${arg_key}"
            fi

            # Likewise, check that there is no positional argument
            # accepting an infinite number of values along the optional
            # one, which would also be impossible to parse.
            if [[ -n "${infinite_arg_number_arg}" ]]; then
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" is optional, while \"%s\" "
                error_message+="accepts an infinite number of values, which "
                error_message+="renders parsing impossible."
                error_message="$(argparser_translate \
                    "Error arg def pos optional infinite" "${error_message}" \
                    "${arg_key}" "${infinite_arg_number_arg}")"
                printf '%s\0' "${error_message}"
            fi
        fi

        # Check the number of arguments.
        if [[ "${arg_number}" == 0 ]]; then
            # Since positional arguments can't be flags, output an error
            # message.
            error_message="Error: The positional argument with the identifier "
            error_message+="\"%s\" accepts 0 arguments and thus can never be "
            error_message+="given on the command line."
            error_message="$(argparser_translate "Error arg def pos flag" \
                "${error_message}" "${arg_key}")"
            printf '%s\0' "${error_message}"
        elif [[ "${arg_number}" == "+" ]]; then
            # Check that no two positional arguments accept an infinite
            # number of values, which would be impossible to parse.
            if [[ -n "${infinite_arg_number_arg}" ]]; then
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" accepts an infinite number "
                error_message+="of values, as does \"%s\", which renders "
                error_message+="parsing impossible."
                error_message="$(argparser_translate \
                    "Error arg def pos infinites" "${error_message}" \
                    "${arg_key}" "${infinite_arg_number_arg}")"
                printf '%s\0' "${error_message}"
            else
                infinite_arg_number_arg="${arg_key}"
            fi

            # Likewise, check that there is no optional positional
            # argument along the one accepting an infinite number of
            # values, which would also be impossible to parse.
            if [[ -n "${optional_arg}" ]]; then
                if [[ "${optional_arg}" == "${arg_key}" ]]; then
                    # The argument being both optional and accepting an
                    # infinite number of values is the same (the current
                    # one), which is not supported.
                    error_message="Error: The positional argument with the "
                    error_message+="identifier \"%s\" accepts an infinite "
                    error_message+="number of values, while being optional, "
                    error_message+="which is not supported."
                    error_message="$(argparser_translate \
                        "Error arg def pos infinite optional 1" \
                        "${error_message}" "${arg_key}")"
                else
                    # Both arguments are different, which is impossible
                    # to parse.
                    error_message="Error: The positional argument with the "
                    error_message+="identifier \"%s\" accepts an infinite "
                    error_message+="number of values, while \"%s\" is "
                    error_message+="optional, which renders parsing "
                    error_message+="impossible."
                    error_message="$(argparser_translate \
                        "Error arg def pos infinite optional 2" \
                        "${error_message}" "${arg_key}" "${optional_arg}")"
                fi
                printf '%s\0' "${error_message}"
            fi
        fi

        # Check the data type.
        if [[ "$(argparser_in_array "${type}" "-" "bool" "char" "int" "str" \
            "uint")" == false ]]
        then
            error_message="Error: The positional argument with the identifier "
            error_message+="\"%s\" has \"%s\" given as data type, but only "
            error_message+="\"bool\", \"char\", \"int\", \"str\", and "
            error_message+="\"uint\" are supported."
            error_message="$(argparser_translate "Error arg def pos type" \
                "${error_message}" "${arg_key}" "${type}")"
            printf '%s\0' "${error_message}"
        fi

        # Check if the choice values accord to the type.
        for choice_value in "${choice_values[@]}"; do
            if [[ "${choice_value}" == "-" || "${type}" == "-" ]]; then
                # No choice value or type is given, so abort the loop.
                break
            elif [[ "${type}" == "bool" \
                && "$(argparser_is_variable_bool \
                    "${choice_value}")" == false ]]
            then
                # Check if the choice value is a boolean.
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" has \"%s\" given as choice "
                error_message+="value, which must be a boolean, i.e., true or "
                error_message+="false."
                error_message="$(argparser_translate "Error arg def pos bool" \
                    "${error_message}" "${arg_key}" "${choice_value}")"
                printf '%s\0' "${error_message}"
            elif [[ "${type}" == "char" \
                && "$(argparser_is_variable_char \
                    "${choice_value}")" == false ]]
            then
                # Check if the choice value is a character.
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" has \"%s\" given as choice "
                error_message+="value, which must be a character, i.e., a "
                error_message+="string comprising one printable ASCII "
                error_message+="character."
                error_message="$(argparser_translate "Error arg def pos char" \
                    "${error_message}" "${arg_key}" "${choice_value}")"
                printf '%s\0' "${error_message}"
            elif [[ "${type}" == "int" \
                && "$(argparser_is_variable_int "${choice_value}")" == false ]]
            then
                # Check if the choice value is an integer.
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" has \"%s\" given as choice "
                error_message+="value, which must be an integer, i.e., "
                error_message+="comprise only digits and possibly a leading "
                error_message+="sign."
                error_message="$(argparser_translate "Error arg def pos int" \
                    "${error_message}" "${arg_key}" "${choice_value}")"
                printf '%s\0' "${error_message}"
            elif [[ "${type}" == "uint" \
                && "$(argparser_is_variable_uint \
                    "${choice_value}")" == false ]]
            then
                # Check if the choice value is an unsigned integer.
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" has \"%s\" given as choice "
                error_message+="value, which must be an unsigned integer, "
                error_message+="i.e., comprise only digits and no sign."
                error_message="$(argparser_translate "Error arg def pos uint" \
                    "${error_message}" "${arg_key}" "${choice_value}")"
                printf '%s\0' "${error_message}"
            fi
        done

        # Check the notes.
        for note in "${notes[@]}"; do
            if [[ "$(argparser_in_array "${note}" "-" \
                "deprecated")" == false ]]
            then
                error_message="Error: The positional argument with the "
                error_message+="identifier \"%s\" has \"%s\" given as note, "
                error_message+="but only \"deprecated\" is supported."
                error_message="$(argparser_translate "Error arg def pos note" \
                    "${error_message}" "${arg_key}" "${note}")"
                printf '%s\0' "${error_message}"
            fi
        done
    done
}

function argparser_check_args_definition_option_values() {
    # Check if the script's arguments' definition is consistent
    # regarding the default and choice values, as well as the number of
    # arguments for options (keyword arguments).  This should always be
    # true for production scripts, but maybe not while testing.
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_choice_values: the associative array holding the choice
    #   values (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_notes: the associative array holding the notes (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - all_types: the associative array holding the argument types
    #   (read-only)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    #
    # Output:
    # - the error messages, starting with "Error: " (translated),
    #   concatenated and terminated with null characters

    # Define the local variables.
    local arg_key
    local arg_number
    local choice_value
    local -a choice_values
    local default_value
    local -a default_values
    local error_message
    local note
    local -a notes
    local type

    # Check the consistency of all keyword arguments.
    for arg_key in "${!all_short_options[@]}"; do
        # Read the argument's definition.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a default_values \
            <<< "${all_default_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values \
            <<< "${all_choice_values[${arg_key}]}"
        type="${all_types[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a notes \
            <<< "${all_notes[${arg_key}]}"

        # Check if the default value for flags is either true or false.
        if [[ "${arg_number}" == 0 \
            && "${default_values[0]}" != true \
            && "${default_values[0]}" != false ]]
        then
            default_value="$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; \
                printf '%s' "${default_values[*]}")"
            error_message="Error: The argument with the identifier \"%s\" "
            error_message+="must be true or false, but has {%s} given as "
            error_message+="default."
            error_message="$(argparser_translate "Error arg def option flag" \
                "${error_message}" "${arg_key}" "${default_value}")"
            printf '%s\0' "${error_message}"
        fi

        # Check if the number of default values equals the number of
        # required values.  Else, output an error message.  Ignore flags
        # as long as they have the only default value of true or false,
        # but a number of required values of 0.
        if [[ "${arg_number}" != "+" \
            && "${arg_number}" != 0 \
            && "${default_values[0]}" != "-" \
            && "${#default_values[@]}" != "${arg_number}" ]]
        then
            if [[ "${arg_number}" == 1 ]]; then
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="requires 1 value, but has %s given as default."
                error_message="$(argparser_translate \
                    "Error arg def option default 1" "${error_message}" \
                    "${arg_key}" "${#default_values[@]}")"
                printf '%s\0' "${error_message}"
            else
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="requires %s values, but has %s given as "
                error_message+="default."
                error_message="$(argparser_translate \
                    "Error arg def option default 2" "${error_message}" \
                    "${arg_key}" "${arg_number}" "${#default_values[@]}")"
                printf '%s\0' "${error_message}"
            fi
        fi

        # Check if the default values accord to the choice values, i.e.,
        # if each default value lies within the array of choice values.
        # Else, output an error message.
        if [[ "${choice_values[0]}" != "-" ]]; then
            # Check that flags have no choice values.
            if [[ "${arg_number}" == 0 ]]; then
                choice_value="$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; \
                    printf '%s' "${choice_values[*]}")"
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="accepts no choice values, but has {%s} given."
                error_message="$(argparser_translate \
                    "Error arg def option choice flag" "${error_message}" \
                    "${arg_key}" "${choice_value}")"
                printf '%s\0' "${error_message}"
            fi

            # Check the default values.
            for default_value in "${default_values[@]}"; do
                if [[ "${default_value}" != "-" \
                    && "$(argparser_in_array "${default_value}" \
                    "${choice_values[@]}")" == false ]]
                then
                    choice_value="$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; \
                        printf '%s' "${choice_values[*]}")"
                    default_value="$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; \
                        printf '%s' "${default_values[*]}")"
                    error_message="Error: The argument with the identifier "
                    error_message+="\"%s\" accepts only the choice values "
                    error_message+="{%s}, but has {%s} given as default."
                    error_message="$(argparser_translate \
                        "Error arg def option choice" "${error_message}" \
                        "${arg_key}" "${choice_value}" "${default_value}")"
                    printf '%s\0' "${error_message}"
                    break
                fi
            done
        fi

        # Check the data type.
        if [[ "$(argparser_in_array "${type}" "-" "bool" "char" "int" "str" \
            "uint")" == false ]]
        then
            error_message="Error: The argument with the identifier \"%s\" has "
            error_message+="\"%s\" given as data type, but only \"bool\", "
            error_message+="\"char\", \"int\", \"str\", and \"uint\" are "
            error_message+="supported."
            error_message="$(argparser_translate "Error arg def option type" \
                "${error_message}" "${arg_key}" "${type}")"
            printf '%s\0' "${error_message}"
        fi

        # Check if the choice values accord to the type.
        for choice_value in "${choice_values[@]}"; do
            if [[ "${choice_value}" == "-" || "${type}" == "-" ]]; then
                # No choice value or type is given, so abort the loop.
                break
            elif [[ "${type}" == "bool" \
                && "$(argparser_is_variable_bool \
                    "${choice_value}")" == false ]]
            then
                # Check if the choice value is a boolean.
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has \"%s\" given as choice value, which must "
                error_message+="be a boolean, i.e., true or false."
                error_message="$(argparser_translate \
                    "Error arg def option bool" "${error_message}" \
                    "${arg_key}" "${choice_value}")"
                printf '%s\0' "${error_message}"
            elif [[ "${type}" == "char" \
                && "$(argparser_is_variable_char \
                    "${choice_value}")" == false ]]
            then
                # Check if the choice value is a character.
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has \"%s\" given as choice value, which must "
                error_message+="be a character, i.e., a string comprising one "
                error_message+="printable ASCII character."
                error_message="$(argparser_translate \
                    "Error arg def option char" "${error_message}" \
                    "${arg_key}" "${choice_value}")"
                printf '%s\0' "${error_message}"
            elif [[ "${type}" == "int" \
                && "$(argparser_is_variable_int "${choice_value}")" == false ]]
            then
                # Check if the choice value is an integer.
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has \"%s\" given as choice value, which must "
                error_message+="be an integer, i.e., comprise only digits and "
                error_message+="possibly a leading sign."
                error_message="$(argparser_translate \
                    "Error arg def option int" "${error_message}" \
                    "${arg_key}" "${choice_value}")"
                printf '%s\0' "${error_message}"
            elif [[ "${type}" == "uint" \
                && "$(argparser_is_variable_uint \
                    "${choice_value}")" == false ]]
            then
                # Check if the choice value is an unsigned integer.
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has \"%s\" given as choice value, which must "
                error_message+="be an unsigned integer, i.e., comprise only "
                error_message+="digits and no sign."
                error_message="$(argparser_translate \
                    "Error arg def option uint" "${error_message}" \
                    "${arg_key}" "${choice_value}")"
                printf '%s\0' "${error_message}"
            fi
        done

        # Check the notes.
        for note in "${notes[@]}"; do
            if [[ "$(argparser_in_array "${note}" "-" \
                "deprecated")" == false ]]
            then
                error_message="Error: The argument with the identifier \"%s\" "
                error_message+="has \"%s\" given as note, but only "
                error_message+="\"deprecated\" is supported."
                error_message="$(argparser_translate \
                    "Error arg def option note" "${error_message}" \
                    "${arg_key}" "${note}")"
                printf '%s\0' "${error_message}"
            fi
        done
    done
}

# Define the argparser functions for the argument parsing.
function argparser_get_arg_key() {
    # Get the argument identifier (key) for a given short or long option
    # name.
    #
    # Arguments:
    # - $1: whether the option is expected to be a short or long option
    #   ("short" or "long")
    # - $2: the option name
    #
    # Nonlocals:
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    #
    # Output:
    # - the argument identifier, if the key exists
    # - the empty string, else (when the option name is erroneous)

    # Define the local variables.
    local arg_key
    local long_option
    local -a long_options
    local mode
    local option_name
    local short_option
    local -a short_options

    # Read the arguments.
    mode="$1"
    option_name="$2"

    # Get the argument identifier.
    if [[ "${mode}" == "short" ]]; then
        for arg_key in "${!all_short_options[@]}"; do
            # Read the argument's definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
                <<< "${all_short_options[${arg_key}]}"

            # Ignore arguments without a short option name.
            if [[ "${short_options[0]}" == "-" ]]; then
                continue
            fi

            # Check the short options.
            for short_option in "${short_options[@]}"; do
                if [[ "${option_name}" == "${short_option}" ]]; then
                    printf '%s' "${arg_key}"
                    return
                fi
            done
        done
    else
        for arg_key in "${!all_long_options[@]}"; do
            # Read the argument's definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
                <<< "${all_long_options[${arg_key}]}"

            # Ignore arguments without a long option name.
            if [[ "${long_options[0]}" == "-" ]]; then
                continue
            fi

            # Check the long options.
            for long_option in "${long_options[@]}"; do
                if [[ "${option_name}" == "${long_option}" ]]; then
                    printf '%s' "${arg_key}"
                    return
                fi
            done
        done
    fi

    printf ""
}

function argparser_get_option_names() {
    # Concatenate the name of all short and long options for the error
    # and warning messages.
    #
    # Arguments:
    # - $1: the argument's name (key)
    # - $2: the order of the options ("short-long" or "long-short")
    #
    # Nonlocals:
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - all_value_names: the associative array holding the value names
    #   (read-only)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    #
    # Output:
    # - the name of all short and long options as comma-separated string

    # Define the local variables.
    local arg_key
    local -a long_options
    local option_names
    local order
    local -a short_options
    local value_names

    # Read the arguments.
    arg_key="$1"
    order="$2"

    # Read the argument's definition.  As positional arguments aren't
    # included in ${all_short_options} and ${all_long_options}, assign
    # them the default value of a hyphen, indicating absence.  For the
    # option name below, use the value name, of which positional
    # arguments can only have one (thus using a string, not an array).
    if [[ "$(argparser_in_array "${arg_key}" \
        "${!all_short_options[@]}")" == true ]]
    then
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
            <<< "${all_short_options[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
            <<< "${all_long_options[${arg_key}]}"
    else
        short_options=("-")
        long_options=("-")
        value_names="${all_value_names[${arg_key}]}"
    fi

    # Concatenate the name of all short and long options.
    if [[ "${short_options[0]}" != "-" && "${long_options[0]}" != "-" ]]; then
        if [[ "${order}" == "short-long" ]]; then
            option_names="$(printf -- '-%s,' "${short_options[@]}")"
            option_names+="$(printf -- '--%s,' "${long_options[@]}")"
        elif [[ "${order}" == "long-short" ]]; then
            option_names="$(printf -- '--%s,' "${long_options[@]}")"
            option_names+="$(printf -- '-%s,' "${short_options[@]}")"
        fi
        option_names="${option_names%,}"
    elif [[ "${short_options[0]}" != "-" ]]; then
        option_names="$(printf -- '-%s,' "${short_options[@]}")"
        option_names="${option_names%,}"
    elif [[ "${long_options[0]}" != "-" ]]; then
        option_names="$(printf -- '--%s,' "${long_options[@]}")"
        option_names="${option_names%,}"
    else
        option_names="${value_names}"
    fi
    printf '%s' "${option_names}"
}

function argparser_split_args() {
    # Split all arguments given to the script on
    # ${ARGPARSER_ARG_DELIMITER_2} characters.
    #
    # Arguments:
    # - $@: the arguments to parse
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    #
    # Output:
    # - the split arguments as string, concatenated and terminated with
    #   null characters

    # Define the local variables.
    local given_arg
    local -a given_args
    local value
    local -a values

    # Read the arguments.
    given_args=("$@")

    for given_arg in "${given_args[@]}"; do
        # Split all arguments on ${ARGPARSER_ARG_DELIMITER_2} characters
        # and output them.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a values <<< "${given_arg}"

        for value in "${values[@]}"; do
            printf '%s\0' "${value}"
        done
    done
}

function argparser_parse_arg() {
    # Parse an argument given to the script.
    #
    # Arguments:
    # - $1: the argument to parse
    #
    # Nonlocals:
    # - is_positional_only: whether the positional arguments delimiter
    #   "--" has already been set and has not been unset by "++"
    #   (read-only)
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    #
    # Output:
    # - the parsed argument as message or an error message, starting
    #   with "Help", "Usage", "Version", "Positional_Start",
    #   "Positional_End", "Error: " (translated), "Argument: ",
    #   "Prefix: ", or "Value: ", concatenated and terminated with null
    #   characters

    # Define the local variables.
    local error_message
    local given_arg

    # Read the argument.
    given_arg="$1"

    # Output the argument, split into option names and values, or an
    # error message.  In the latter case, output also the given
    # argument, such that values following the unknown argument are
    # assigned to this argument, not the last known one that got parsed.
    if [[ "${given_arg}" != "++"* \
        && ("${given_arg}" != [-+]* || "${is_positional_only}" == true) ]]
    then
        # The argument doesn't start with a hyphen ("-") or plus sign
        # ("+"), so deem it a value to a previous keyword argument or a
        # positional argument.  Likewise, if the positional arguments
        # delimiter "--" has already been set and has neither been unset
        # by "++" nor the current argument is this "++", then deem any
        # value a positional argument.
        printf 'Value: %s\0' "${given_arg}"
    elif [[ "${given_arg}" == "--" ]]; then
        # The argument is the positional arguments delimiter "--".
        printf 'Positional_Start\0'
    elif [[ "${given_arg}" == "--="* ]]; then
        # The argument is the positional arguments delimiter "--", but
        # followed by an illegal equals sign ("=").
        error_message="Error: The special option \"--\" takes no value."
        error_message="$(argparser_translate "Error arg double hyphen" \
            "${error_message}")"
        printf '%s\0' "${error_message}"
        printf 'Argument: %s\0' "${given_arg}"
    elif [[ "${given_arg}" == "++" ]]; then
        # The argument is the positional arguments delimiter "++".
        printf 'Positional_End\0'
    elif [[ "${given_arg}" == "++="* ]]; then
        # The argument is the positional arguments delimiter "++", but
        # followed by an illegal equals sign ("=").
        error_message="Error: The special option \"++\" takes no value."
        error_message="$(argparser_translate "Error arg double plus" \
            "${error_message}")"
        printf '%s\0' "${error_message}"
        printf 'Argument: %s\0' "${given_arg}"
    elif [[ "${ARGPARSER_ADD_HELP}" == true && \
        ("${given_arg}" == "-h" || "${given_arg}" == "--help") ]]
    then
        # The argument is for the help message.
        printf 'Help\0'
    elif [[ "${ARGPARSER_ADD_HELP}" == true && \
        ( "${given_arg}" == "-h="* || "${given_arg}" == "--help="*) ]]
    then
        # The argument is for the help message, but followed by an
        # illegal equals sign ("=").
        error_message="Error: The option \"-h,--help\" takes no value."
        error_message="$(argparser_translate "Error arg help" \
            "${error_message}")"
        printf '%s\0' "${error_message}"
        printf 'Argument: %s\0' "${given_arg}"
    elif [[ "${ARGPARSER_ADD_USAGE}" == true && \
        ( "${given_arg}" == "-u" || "${given_arg}" == "--usage") ]]
    then
        # The argument is for the usage message.
        printf 'Usage\0'
    elif [[ "${ARGPARSER_ADD_USAGE}" == true && \
        ( "${given_arg}" == "-u="* || "${given_arg}" == "--usage="*) ]]
    then
        # The argument is for the usage message, but followed by an
        # illegal equals sign ("=").
        error_message="Error: The option \"-u,--usage\" takes no value."
        error_message="$(argparser_translate "Error arg usage" \
            "${error_message}")"
        printf '%s\0' "${error_message}"
        printf 'Argument: %s\0' "${given_arg}"
    elif [[ "${ARGPARSER_ADD_VERSION}" == true && \
        ( "${given_arg}" == "-V" || "${given_arg}" == "--version") ]]
    then
        # The argument is for the version message.
        printf 'Version\0'
    elif [[ "${ARGPARSER_ADD_VERSION}" == true && \
        ( "${given_arg}" == "-V="* || "${given_arg}" == "--version="*) ]]
    then
        # The argument is for the version message, but followed by an
        # illegal equals sign ("=").
        error_message="Error: The option \"-V,--version\" takes no value."
        error_message="$(argparser_translate "Error arg version" \
            "${error_message}")"
        printf '%s\0' "${error_message}"
        printf 'Argument: %s\0' "${given_arg}"
    elif [[ "${given_arg::2}" == "--" || "${given_arg::2}" == "++" ]]; then
        # The argument is a long option, so check whether the given
        # argument is defined.
        argparser_parse_long_option "${given_arg}"
    elif [[ "${given_arg::2}" == [-+][!-+] ]]; then
        # The argument is a short option, so check whether the given
        # argument is defined.
        argparser_parse_short_option "${given_arg}"
    else
        # The argument hasn't been matched by any condition, so deem it
        # unknown.  This is true if the prefix is neither "--", "++", a
        # single "-" nor a single "+", but e.g. "+-" or "-+".
        error_message="Error: The argument \"%s\" is unknown."
        error_message="$(argparser_translate "Error arg unknown" \
            "${error_message}" "${given_arg%%=*}")"
        printf '%s\0' "${error_message}"
        printf 'Argument: %s\0' "${given_arg}"
    fi
}

function argparser_parse_long_option() {
    # Parse a long-option argument given to the script.
    #
    # Arguments:
    # - $1: the argument to parse
    #
    # Nonlocals:
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    #
    # Environment:
    # - ARGPARSER_ALLOW_OPTION_ABBREVIATION (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    #
    # Output:
    # - the parsed argument as message or an error message, starting
    #   with "Error: " (translated), "Argument: ", "Prefix: ", or
    #   "Value: ", concatenated and terminated with null characters

    # Define the local variables.
    local abbr_long_option
    local -A abbr_long_options
    local arg_key
    local error_message
    local given_arg
    local long_option
    local -a long_options
    local prefix

    # Read the argument.
    given_arg="$1"

    # Get the prefix, option name, and possibly value for the given
    # argument.
    prefix="${given_arg::1}"
    option_name="${given_arg:2}"
    if [[ "${given_arg}" =~ "=" ]]; then
        option_name="${option_name%%=*}"
        value="${given_arg#*=}"
    else
        value=""
    fi
    arg_key="$(argparser_get_arg_key "long" "${option_name}")"

    # Output the argument, split into the option name and value, or an
    # error message.  In the latter case, output also the given
    # argument, such that values following the unknown argument are
    # assigned to this argument, not the last known one that got parsed.
    if [[ "${ARGPARSER_ALLOW_OPTION_ABBREVIATION}" == true \
        && -z "${arg_key}" ]]
    then
        # Check if the argument is an abbreviated long option, since no
        # argument identifier for the entire option name has been found.
        for arg_key in "${!all_long_options[@]}"; do
            # Read the argument's definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
                <<< "${all_long_options[${arg_key}]}"

            # Abbreviate the long option names by shortening them to the
            # length of the given option name and add them to the
            # associative array.  Ignore arguments without long option
            # name.
            for long_option in "${long_options[@]}"; do
                if [[ "${long_option}" == "-" ]]; then
                    break
                fi
                abbr_long_options[${arg_key}]="${long_option::${#option_name}}"
            done
        done

        # Count the number of matches of the argument among the
        # abbreviated long option names. If it matches once, output the
        # argument identifier and possibly the value following the
        # equals sign ("=").  If multiple or no option names are
        # matched, output an error message, instead.
        count="$(argparser_count "${option_name}" "${abbr_long_options[@]}")"

        if (( count == 1 )); then
            # Get the argument identifier for the abbreviated argument.
            for arg_key in "${!abbr_long_options[@]}"; do
                abbr_long_option="${abbr_long_options[${arg_key}]}"
                if [[ "${option_name}" == "${abbr_long_option}"* ]]; then
                    break
                fi
            done

            if [[ -n "${value}" ]]; then
                # Output the argument identifier, the prefix, and the
                # value.
                printf 'Argument: %s\0' "${arg_key}"
                printf 'Prefix: %s\0' "${prefix}"
                printf 'Value: %s\0' "${value}"
            else
                # Output the argument identifier and the prefix.
                printf 'Argument: %s\0' "${arg_key}"
                printf 'Prefix: %s\0' "${prefix}"
            fi
        elif (( count > 1 )); then
            # Since multiple option names have been found in the
            # definition, output an error message and the argument.
            error_message="Error: The long option \"%s\" matches multiple "
            error_message+="long options."
            error_message="$(argparser_translate "Error long option match" \
                "${error_message}" "${given_arg%%=*}")"
            printf '%s\0' "${error_message}"
            printf 'Argument: %s\0' "${given_arg}"
        else
            # Since the argument hasn't been found in the definition,
            # output an error message and the argument.
            error_message="Error: The long option \"%s\" is unknown."
            error_message="$(argparser_translate "Error long option unknown" \
                "${error_message}" "${given_arg%%=*}")"
            printf '%s\0' "${error_message}"
            printf 'Argument: %s\0' "${given_arg}"
        fi
    else
        if [[ -n "${arg_key}" ]]; then
            if [[ -n "${value}" ]]; then
                # Output the argument identifier, the prefix, and the
                # value.
                printf 'Argument: %s\0' "${arg_key}"
                printf 'Prefix: %s\0' "${prefix}"
                printf 'Value: %s\0' "${value}"
            else
                # Output the argument identifier and the prefix.
                printf 'Argument: %s\0' "${arg_key}"
                printf 'Prefix: %s\0' "${prefix}"
            fi
        else
            # Since the argument hasn't been found in the definition,
            # output an error message and the argument.
            error_message="Error: The long option \"%s\" is unknown."
            error_message="$(argparser_translate "Error long option unknown" \
                "${error_message}" "${given_arg%%=*}")"
            printf '%s\0' "${error_message}"
            printf 'Argument: %s\0' "${given_arg}"
        fi
    fi
}

function argparser_parse_short_option() {
    # Parse a short-option argument given to the script.
    #
    # Arguments:
    # - $1: the argument to parse
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    #
    # Environment:
    # - ARGPARSER_ALLOW_OPTION_MERGING (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    #
    # Output:
    # - the parsed argument as message or an error message, starting
    #   with "Error: " (translated), "Argument: ", "Prefix: ", or
    #   "Value: ", concatenated and terminated with null characters

    # Define the local variables.
    local arg_key
    local arg_number
    local char
    local given_arg
    local i
    local prefix
    local option_name
    local value

    # Read the argument.
    given_arg="$1"

    # Get the prefix, option name, and possibly value for the given
    # argument.
    prefix="${given_arg::1}"
    option_name="${given_arg:1}"
    if [[ "${given_arg}" =~ "=" ]]; then
        option_name="${option_name%%=*}"
        value="${given_arg#*=}"
    else
        value=""
    fi
    arg_key="$(argparser_get_arg_key "short" "${option_name}")"

    # Get the argument identifier for the given (and perhaps merged)
    # argument and output it, possibly along with the value following
    # the equals sign ("=").
    if [[ "${ARGPARSER_ALLOW_OPTION_MERGING}" == true ]]; then
        # Split the combined short option name, which may end in a
        # merged value, after any character.
        for (( i = 0; i < "${#option_name}"; i++ )); do
            char="${option_name:i:1}"
            arg_key="$(argparser_get_arg_key "short" "${char}")"
            if [[ -z "${arg_key}" ]]; then
                # Since the argument hasn't been found in the
                # definition, output an error message and the argument.
                error_message="Error: The short option \"%s%s\" is unknown."
                error_message="$(argparser_translate \
                    "Error short option merge" "${error_message}" \
                    "${prefix}" "${char}")"
                printf '%s\0' "${error_message}"
                printf 'Argument: %s\0' "${given_arg}"
                return
            fi

            # Output the argument identifier and the prefix for the
            # short option name character.
            printf 'Argument: %s\0' "${arg_key}"
            printf 'Prefix: %s\0' "${prefix}"

            # Get the number of required arguments to judge whether the
            # following character is an argument to the current option
            # or another option (i.e., the current option is a flag).
            # If there is no following character, the value must have
            # been given as next whitespace-delimited argument, thus
            # don't output anything.
            arg_number="${all_arg_numbers[${arg_key}]}"
            if [[ "${arg_number}" != 0 ]] && (( i < "${#option_name}" - 1 ))
            then
                # Output the value, which is the argument's rest.
                printf 'Value: %s\0' "${option_name:i+1}"
                return
            fi
        done

        if [[ -n "${value}" ]]; then
            # Output the value, which is given after an equals sign
            # ("=").
            printf 'Value: %s\0' "${value}"
        fi
    else
        if [[ -n "${arg_key}" ]]; then
            if [[ -n "${value}" ]]; then
                # Output the argument identifier, the prefix, and the
                # value.
                printf 'Argument: %s\0' "${arg_key}"
                printf 'Prefix: %s\0' "${prefix}"
                printf 'Value: %s\0' "${value}"
            else
                # Output the argument identifier and the prefix.
                printf 'Argument: %s\0' "${arg_key}"
                printf 'Prefix: %s\0' "${prefix}"
            fi
        else
            # Since the argument hasn't been found in the definition,
            # output an error message and the argument.
            error_message="Error: The short option \"%s\" is unknown."
            error_message="$(argparser_translate "Error short option unknown" \
                "${error_message}" "${given_arg%%=*}")"
            printf '%s\0' "${error_message}"
            printf 'Argument: %s\0' "${given_arg}"
        fi
    fi
}

function argparser_parse_positional_args() {
    # Parse all positional arguments given to the script.
    #
    # Arguments:
    # - $@: the arguments to parse
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    #
    # Output:
    # - the parsed argument as message or an error message, starting
    #   with "Error: " (translated), "Argument: ", or "Value: ",
    #   concatenated and terminated with null characters

    # Define the local variables.
    local arg_key
    local arg_number
    local args_count
    local default_args_count
    local default_value
    local -a default_values
    local error_message
    local given_arg
    local -a given_args
    local i
    local index
    local required_args_count

    # Read the arguments.
    given_args=("$@")

    # Count the defined positional arguments with default values and
    # those without.
    default_args_count=0
    required_args_count=0
    for arg_key in "${all_positional_args[@]}"; do
        # Read the argument's definition.
        default_values="${all_default_values[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # For the counting, consider an infinite number of values as 1,
        # i.e., the minimum number that can be given.
        if [[ "${arg_number}" == "+" ]]; then
            arg_number=1
        fi

        # Increment the respective count.
        if [[ "${default_values}" == "-" ]]; then
            (( required_args_count += arg_number ))
        else
            (( default_args_count += arg_number ))
        fi
    done

    # Based on the number of given, default, and required positional
    # arguments, judge whether values for arguments with default values
    # are given.  Since there cannot be arguments with an infinite
    # number of values defined when there are arguments with default
    # values defined, a higher number of given values than required
    # means that either some values for arguments with default values
    # are given (then, their count exceeds zero), or that an argument
    # accepting an infinite number of values is given as last once
    # (then, the count of default arguments is zero).  This allows to
    # distinguish these two cases.
    args_count="${#given_args[@]}"
    if (( args_count > required_args_count && default_args_count > 0 )); then
        # There are arguments having default values given.  Get the
        # argument identifiers for all given arguments and output them,
        # along with the values.
        index=0
        for arg_key in "${all_positional_args[@]}"; do
            # Read the argument's definition.
            arg_number="${all_arg_numbers[${arg_key}]}"

            # Output as many given arguments as requested.
            printf 'Argument: %s\0' "${arg_key}"
            for (( i = index; i < arg_number + index && i < args_count; i++ ))
            do
                printf 'Value: %s\0' "${given_args[i]}"
            done
            (( index += arg_number ))
        done
    else
        # There are no arguments having default values given.  Get the
        # argument identifiers for all given arguments and output them,
        # along with the values.
        index=0
        for arg_key in "${all_positional_args[@]}"; do
            # Read the argument's definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a default_values \
                <<< "${all_default_values[${arg_key}]}"
            arg_number="${all_arg_numbers[${arg_key}]}"

            # Skip the defined arguments having default values, but
            # aren't given.
            if [[ "${default_values[0]}" != "-" ]]; then
                continue
            fi

            # If the positional argument accepts an infinite number of
            # values, output all remaining given arguments, else, only
            # as many as requested.
            printf 'Argument: %s\0' "${arg_key}"
            if [[ "${arg_number}" == "+" ]]; then
                for (( i = index; i < args_count; i++ )); do
                    printf 'Value: %s\0' "${given_args[i]}"
                done
                index="${args_count}"

                break
            else
                for (( i = index; i < arg_number + index && i < args_count; \
                    i++ ))
                do
                    printf 'Value: %s\0' "${given_args[i]}"
                done
                (( index += arg_number ))
            fi
        done
    fi

    # If there are positional arguments remaining that haven't been
    # consumed by a defined argument, output an error message.
    if (( index < args_count )); then
        if (( index == 1 )); then
            error_message="Error: 1 positional argument is required, but %s "
            error_message+="are given."
            error_message="$(argparser_translate "Error pos arg count 1" \
                "${error_message}" "${args_count}")"
        else
            error_message="Error: %s positional arguments are required, but "
            error_message+="%s are given."
            error_message="$(argparser_translate "Error pos arg count 2" \
                "${error_message}" "${index}" "${args_count}")"
        fi
        printf '%s\0' "${error_message}"
    fi
}

function argparser_check_arg_values() {
    # Check if a script's argument accords to its definition.
    #
    # Arguments:
    # - $1: the argument's name (key)
    # - $2: the argument's prefixes ("-", "+", or "")
    # - $3: the argument's values
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_choice_values: the associative array holding the choice
    #   values (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_notes: the associative array holding the notes (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    # - all_types: the associative array holding the argument types
    #   (read-only)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_COUNT_FLAGS (read-only)
    #
    # Output:
    # - the parsed argument as message or an error or warning message,
    #   starting with "Error: " (translated), "Warning: " (translated),
    #   or "Value: ", concatenated and terminated with null characters

    # Define the local variables.
    local arg_key
    local arg_number
    local -a choice_values
    local count
    local -a default_values
    local error_message
    local option_names
    local prefix
    local -a prefixes
    local type
    local value
    local -a values
    local warning_message

    # Read the arguments.  Since positional arguments have no prefix,
    # use an empty array as default value, such that testing on its
    # value is possible, below.
    arg_key="$1"
    if [[ "$(argparser_in_array "${arg_key}" \
        "${all_positional_args[@]}")" == true ]]
    then
        prefixes=( )
    else
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a prefixes <<< "$2"
    fi
    IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a values <<< "$3"

    # Read the argument's definition.
    IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a default_values \
        <<< "${all_default_values[${arg_key}]}"
    IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a choice_values \
        <<< "${all_choice_values[${arg_key}]}"
    type="${all_types[${arg_key}]}"
    arg_number="${all_arg_numbers[${arg_key}]}"
    IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a notes \
        <<< "${all_notes[${arg_key}]}"

    # Concatenate the name of all short and long options for the error
    # and warning messages.
    option_names="$(argparser_get_option_names "${arg_key}" "short-long")"

    # If a "+" prefix is given and the argument is no flag, output an
    # error message.
    for prefix in "${prefixes[@]}"; do
        if [[ "${prefix}" == "+" && "${arg_number}" != 0 ]]; then
            error_message="Error: The option \"%s\" is no flag and thus "
            error_message+="cannot be given with a \"+\" prefix."
            error_message="$(argparser_translate "Error arg no flag" \
                "${error_message}" "${option_names}")"
            printf '%s\0' "${error_message}"
            return
        fi
    done

    # Check if the correct number of values is given.  If an argument
    # hadn't been given, both its value and prefix are empty, but if it
    # was given without value the prefix is non-empty, allowing to
    # distinguish both cases.
    if (( "${#values[@]}" == 0 && "${#prefixes[@]}" == 0 )); then
        if [[ "${default_values[0]}" == "-" ]]; then
            # The argument is not given, but must have been since it
            # doesn't have a default value.  Hence, output an error
            # message.
            error_message="Error: The argument \"%s\" is mandatory, but not "
            error_message+="given."
            error_message="$(argparser_translate "Error mandatory arg" \
                "${error_message}" "${option_names}")"
            printf '%s\0' "${error_message}"
            return
        elif [[ "${ARGPARSER_COUNT_FLAGS}" == true && "${arg_number}" == 0 ]]
        then
            # The argument is not given, but a flag with a default value
            # of "true" or "false".  Since the flags shall be counted,
            # set the value to 1 for "true" and to -1 for "false", which
            # are the same values as would be when the flags would be
            # given with a hyphen ("-", true) or plus sign ("+", false).
            if [[ "${default_values[0]}" == true ]]; then
                values=(1)
            else
                values=(-1)
            fi
        else
            # The argument is not given, but it has default values.
            # Hence, read them.  This is required for optional
            # arguments, which don't need to be set.
            values=("${default_values[@]}")
        fi
    else
        if [[ "${arg_number}" != "+" && "${#values[@]}" != "${arg_number}" ]] \
            || [[ "${arg_number}" == "+" && "${#values[@]}" == 0 ]]
        then
            # If the number of values doesn't equal the number of
            # required values, check if some default values are given.
            if [[ "${default_values[0]}" == "-" ]]; then
                # If no default value is given, output an error message
                # indicating the number of required and given arguments.
                if [[ "${arg_number}" == 1 ]]; then
                    error_message="Error: The argument \"%s\" requires 1 "
                    error_message+="value, but has %s given."
                    error_message="$(argparser_translate \
                        "Error wrong arg number 1" "${error_message}" \
                        "${option_names}" "${#values[@]}")"
                elif [[ "${arg_number}" == "+" ]]; then
                    error_message="Error: The argument \"%s\" requires at "
                    error_message+="least 1 value, but has %s given."
                    error_message="$(argparser_translate \
                        "Error wrong arg number 2" "${error_message}" \
                        "${option_names}" "${#values[@]}")"
                else
                    error_message="Error: The argument \"%s\" requires %s "
                    error_message+="values, but has %s given."
                    error_message="$(argparser_translate \
                        "Error wrong arg number 3" "${error_message}" \
                        "${option_names}" "${arg_number}" "${#values[@]}")"
                fi
                printf '%s\0' "${error_message}"
                return
            else
                # As some default values are given, print a similar
                # warning message as for the absence case, but set the
                # values to the default values and continue.
                default_values=("$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; \
                    printf '%s' "${default_values[*]}")")
                if [[ "${arg_number}" == 1 ]]; then
                    warning_message="Warning: The argument \"%s\" requires 1 "
                    warning_message+="value, but has %s given.  For "
                    warning_message+="convenience, the default (%s) is used."
                    warning_message="$(argparser_translate \
                        "Warning wrong arg number 1" "${warning_message}" \
                        "${option_names}" "${#values[@]}" \
                        "${default_values[0]}")"
                elif [[ "${arg_number}" == "+" ]]; then
                    warning_message="Warning: The argument \"%s\" requires at "
                    warning_message+="least 1 value, but has %s given.  For "
                    warning_message+="convenience, the default (%s) is used."
                    warning_message="$(argparser_translate \
                        "Warning wrong arg number 2" "${warning_message}" \
                        "${option_names}" "${#values[@]}" \
                        "${default_values[0]}")"
                else
                    warning_message="Warning: The argument \"%s\" requires "
                    warning_message+="%s values, but has %s given.  For "
                    warning_message+="convenience, the default (%s) is used."
                    warning_message="$(argparser_translate \
                        "Warning wrong arg number 3" "${warning_message}" \
                        "${option_names}" "${arg_number}" "${#values[@]}" \
                        "${default_values[0]}")"
                fi
                printf '%s\0' "${warning_message}"

                IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a default_values \
                    <<< "${all_default_values[${arg_key}]}"
                values=("${default_values[@]}")
            fi
        elif [[ "${arg_number}" == 0 && (! -v values || -z "${values[0]}") ]]
        then
            # If no value is required nor given, the argument is a flag.
            # As it is set (present), set the value to true for a "-"
            # prefix and to false for a "+" prefix.  Thereby, the last
            # given prefix determines the value, implicitly overriding
            # any prefix given before.
            if [[ "${ARGPARSER_COUNT_FLAGS}" == true ]]; then
                (( count = "$(argparser_count "-" "${prefixes[@]}")" ))
                (( count -= "$(argparser_count "+" "${prefixes[@]}")" ))
                values=("${count}")
            else
                if [[ "${prefixes[-1]}" == "-" ]]; then
                    values=(true)
                else
                    values=(false)
                fi
            fi
        fi
    fi

    # Check if the given values accord to the choice values, i.e., if
    # each given value lies within the array of choice values.  Else,
    # output an error message.
    if [[ "${choice_values[0]}" != "-" ]]; then
        for value in "${values[@]}"; do
            if [[ "$(argparser_in_array "${value}" \
                "${choice_values[@]}")" == false ]]
            then
                choice_values=("$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; \
                    printf '%s' "${choice_values[*]}")")
                error_message="Error: The argument \"%s\" must be in {%s}."
                error_message="$(argparser_translate "Error arg choice" \
                    "${error_message}" "${option_names}" \
                    "${choice_values[0]}")"
                printf '%s\0' "${error_message}"
                return
            fi
        done
    fi

    # Check if the given values accord to the type.
    for value in "${values[@]}"; do
        if [[ "${type}" == "-" ]]; then
            # No type is given, so abort the loop.
            break
        elif [[ "${type}" == "bool" \
            && "${arg_number}" != 0 \
            && "$(argparser_is_variable_bool "${value}")" == false ]]
        then
            # Check if the value is a boolean.  If the argument is a
            # flag, then the values are set by the argparser to
            # booleans, or, if ${ARGPARSER_COUNT_FLAGS} is set to true,
            # to unsigned integers.  Since both automatically have the
            # correct type, don't check them.
            error_message="Error: The argument \"%s\" is set to \"%s\", but "
            error_message+="must be a boolean, i.e., true or false."
            error_message="$(argparser_translate "Error arg bool" \
                "${error_message}" "${option_names}" "${value}")"
            printf '%s\0' "${error_message}"
            return
        elif [[ "${type}" == "char" \
            && "$(argparser_is_variable_char "${value}")" == false ]]
        then
            # Check if the value is a character.
            error_message="Error: The argument \"%s\" is set to \"%s\", but "
            error_message+="must be a character, i.e., a string comprising "
            error_message+="one printable ASCII character."
            error_message="$(argparser_translate "Error arg char" \
                "${error_message}" "${option_names}" "${value}")"
            printf '%s\0' "${error_message}"
            return
        elif [[ "${type}" == "int" \
            && "$(argparser_is_variable_int "${value}")" == false ]]
        then
            # Check if the value is an integer.
            error_message="Error: The argument \"%s\" is set to \"%s\", but "
            error_message+="must be an integer, i.e., comprise only digits "
            error_message+="and possibly a leading sign."
            error_message="$(argparser_translate "Error arg int" \
                "${error_message}" "${option_names}" "${value}")"
            printf '%s\0' "${error_message}"
            return
        elif [[ "${type}" == "uint" \
            && "$(argparser_is_variable_uint "${value}")" == false ]]
        then
            # Check if the value is an unsigned integer.
            error_message="Error: The argument \"%s\" is set to \"%s\", but "
            error_message+="must be an unsigned integer, i.e., comprise only "
            error_message+="digits and no sign."
            error_message="$(argparser_translate "Error arg uint" \
                "${error_message}" "${option_names}" "${value}")"
            printf '%s\0' "${error_message}"
            return
        fi
    done

    # Check the notes.
    for note in "${notes[@]}"; do
        if [[ "${note}" == "deprecated" && "${#prefixes[@]}" != 0 ]]; then
            # Only output a deprecation warning if the argument had been
            # given (and thus the prefix is non-empty), not when its
            # default value has been used.
            warning_message="Warning: The argument \"%s\" is deprecated and "
            warning_message+="will be removed in the future."
            warning_message="$(argparser_translate "Warning deprecation" \
                "${warning_message}" "${option_names}")"
            printf '%s\0' "${warning_message}"
        fi
    done

    # Output the checked values.
    value="$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; printf '%s' "${values[*]}")"
    printf 'Value: %s\0' "${value}"
}

function argparser_set_args() {
    # Set the keyword and positional arguments to global variables.
    #
    # Globals:
    # - ${${ARGPARSER_ARG_ARRAY_NAME}[@]}: the parsed and checked
    #   arguments with key and value as associative array, which
    #   ${ARGPARSER_ARG_ARRAY_NAME} refers to (read-only)
    # - ${!${ARGPARSER_ARG_ARRAY_NAME}[@]}: all argument identifiers
    #   found in ${${ARGPARSER_ARG_ARRAY_NAME}[@]}
    #
    # Environment:
    # - ARGPARSER_ARG_ARRAY_NAME (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_SET_ARRAYS (read-only)

    # Define the local variable.
    local arg_key

    # Get the associative array ${ARGPARSER_ARG_ARRAY_NAME} refers to.
    # If it is already "args" (the default name), nothing needs to be
    # done, but other variable names need to be mapped to "args" to be
    # able to refer to the variable by name.  Thus, declare prints the
    # array contents stored in the variable ${ARGPARSER_ARG_ARRAY_NAME}
    # refers to, which then gets stripped from the leading assignment
    # (before the equals sign ("=")) and set to the new associative
    # array ${args}.
    if [[ "${ARGPARSER_ARG_ARRAY_NAME}" != "args" ]]; then
        local args
        args="$(declare -p "${ARGPARSER_ARG_ARRAY_NAME}")"
        local -A args="${args#*=}"
    fi

    # Set the arguments.
    for arg_key in "${!args[@]}"; do
        if [[ "${args[${arg_key}]}" == *"${ARGPARSER_ARG_DELIMITER_2}"*
            && "${ARGPARSER_SET_ARRAYS}" == true ]]
        then
            # Set the argument, which includes the
            # ${ARGPARSER_ARG_DELIMITER_2} and hence is a sequence of
            # elements, as indexed array variable, while keeping it in
            # ${args} for usage by the calling script.
            declare -g -a "${arg_key}"

            # shellcheck disable=SC2229  # Indirect variable reference.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a "${arg_key}" \
                <<< "${args[${arg_key}]}"
        else
            # Set the keyword argument as variable, while keeping it in
            # ${args} for potential usage by the calling script.
            declare -g "${arg_key}"="${args[${arg_key}]}"
        fi
    done
}

# Define the argparser functions for creating and printing the help and
# usage messages, including their translation, as well as for printing
# error messages.
function argparser_read_translation() {
    # Read the translation of the auto-generated text for help and usage
    # messages from the YAML file into an associative array.
    #
    # Environment:
    # - ARGPARSER_DICTIONARY
    # - ARGPARSER_LANGUAGE (read-only)
    # - ARGPARSER_TRANSLATION_FILE (read-only)

    # Define the local variables.
    local attributes
    local error_message
    local -a error_messages
    local group
    local is_continued
    local language
    local line
    local -a lines
    local translation

    # Read the translation file.  If it doesn't exist or isn't readable,
    # output an error message and exit.  Since at this point of
    # invokation, the environment variables aren't checked, yet, set the
    # needed ones to default values, if ${ARGPARSER_CHECK_ENV_VARS}
    # isn't set to false (and by this, the checking hasn't been
    # explicitly disabled).
    attributes="$(argparser_check_file "${ARGPARSER_TRANSLATION_FILE}")"
    if [[ "${attributes}" != 0000 ]]; then
        error_message="Error: The environment variable \"%s\" is set to "
        error_message+="\"%s\", but the referenced file "
        case "${attributes}" in
            0001) error_message+="is empty." ;;
            0010) error_message+="is not readable." ;;
            0011) error_message+="is not readable and empty." ;;
            0100) error_message+="is not a regular file." ;;
            0101) error_message+="is not a regular file and empty." ;;
            0110)
                error_message+="is not a regular file and not readable."
                ;;
            0111)
                error_message+="is not a regular file, not readable, and "
                error_message+="empty."
                ;;
            1111) error_message+="does not exist." ;;
        esac

        if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
            ARGPARSER_ERROR_EXIT_CODE=1
            ARGPARSER_ERROR_STYLE="red,bold,reverse"
        fi
        argparser_print_error_or_warning_message "error" false true \
            "${error_message}"
    fi

    mapfile -t lines < "${ARGPARSER_TRANSLATION_FILE}"
    group=""
    language=""
    translation=""
    is_continued=false
    error_messages=( )

    for line in "${lines[@]}"; do
        if [[ -z "${line}" || "${line}" == \#* ]]; then
            # The line is empty or commented.
            continue
        elif [[ "${line}" == "---" || "${line}" == "..." ]]; then
            # The line starts or end a YAML block, which can be ignored.
            continue
        elif [[ "${line}" == "  ${ARGPARSER_LANGUAGE}: >" ]]; then
            # The line starts the translation to the desired language.
            language="${ARGPARSER_LANGUAGE}"
            translation=""
            is_continued=true
        elif [[ "${line}" == "  ${ARGPARSER_LANGUAGE}: "* ]]; then
            # The line contains the translation to the desired language.
            language="${ARGPARSER_LANGUAGE}"
            translation="${line#*: }"
        elif [[ "${line}" == "  "*": >" ]]; then
            # The line start the translation to another language, which
            # can be ignored, along all following lines until the start
            # of a new YAML key.
            language="${line#* }"
            language="${language%:*}"
            translation=""
            is_continued=true
        elif [[ "${line}" == "  "*([^ ])": "* ]]; then
            # The line contains the translation to another language,
            # which can be ignored.
            language="${line#* }"
            language="${language%:*}"
            translation=""
        elif [[ "${line}" == "    "* \
            && "${language}" == "${ARGPARSER_LANGUAGE}" \
            && "${is_continued}" == true ]]
        then
            # The line continues the translation from the previous line.
            if [[ -z "${translation}" ]]; then
                translation="${line#    }"
            else
                translation+=" ${line#    }"
            fi
        elif [[ "${line}" == "    "* && "${is_continued}" == true ]]; then
            # The line continues the translation to another language,
            # from the previous line, which can be ignored.
            translation=""
        elif [[ "${line}" == *:  && "${line::1}" != " " ]]; then
            # The line starts a new group of translations.  Save the
            # previous translation under the previous group name, then
            # extract the new one.
            if [[ -n "${group}" ]]; then
                ARGPARSER_DICTIONARY[${group}]="${translation}"
            fi
            group="${line%:}"
            translation=""
            is_continued=false
        else
            error_message="Error: Unrecognized YAML line \"%s\"."
            error_message="$(argparser_translate "Error YAML" \
                "${error_message}" "${line}")"
            error_messages+=("${error_message}")
        fi
    done

    # Add the last group to the dictionary.
    if [[ -n "${group}" ]]; then
        ARGPARSER_DICTIONARY[${group}]="${translation}"
    fi

    # Colorize, sort, filter, and print all error messages.
    argparser_print_error_or_warning_message "error" true false \
        "${error_messages[@]}"
}

function argparser_translate() {
    # Translate the given string.
    #
    # Arguments:
    # - $1: the key (identifier) of the string in the dictionary
    # - $2: the string to use as fallback if no translation file is
    #       given or the key does not exist
    # - $@: the variable names to use for interpolation of "%s" format
    #       specifiers in the string
    #
    # Environment:
    # - ARGPARSER_DICTIONARY (read-only)
    # - ARGPARSER_TRANSLATION_FILE (read-only)
    #
    # Output:
    # - the translated string

    # Define the local variables.
    local key
    local string
    local var
    local -a vars

    # Read the arguments.
    key="$1"
    string="$2"
    shift 2
    vars=("$@")

    # If an ${ARGPARSER_TRANSLATION_FILE} was given (and thus the
    # translation was requested), translate the string by fetching its
    # translation from the associative array ${ARGPARSER_DICTIONARY}.
    # Else, output the untranslated string.  If the key or string does
    # not exist in ${ARGPARSER_DICTIONARY}, output a warning message and
    # the untranslated string.  Translate the warning message only if
    # the key is not the one required for translation, else, an infinite
    # loop would arise by trying to fetch the inexistent translation
    # over and over.
    if [[ -n "${ARGPARSER_TRANSLATION_FILE}" ]]; then
        if [[ "$(argparser_in_array "${key}" \
            "${!ARGPARSER_DICTIONARY[@]}")" == false ]]
        then
            warning_message="Warning: In the translation file \"%s\", the "
            warning_message+="identifier \"%s\" is missing.  For convenience, "
            warning_message+="the untranslated string is used, instead."

            if [[ "${key}" == "Warning no identifier" ]]; then
                for var in "${ARGPARSER_TRANSLATION_FILE}" "${key}"; do
                    warning_message="${warning_message/"%s"/${var}}"
                done
            else
                warning_message="$(argparser_translate \
                    "Warning no identifier" "${warning_message}" \
                    "${ARGPARSER_TRANSLATION_FILE}" "${key}")"
            fi

            argparser_print_error_or_warning_message "warning" false false \
                "${warning_message}"
        elif [[ -z "${ARGPARSER_DICTIONARY[${key}]}" ]]; then
            warning_message="Warning: In the translation file \"%s\", the "
            warning_message+="translation to \"%s\" for the identifier \"%s\" "
            warning_message+="is missing.  For convenience, the untranslated "
            warning_message+="string is used, instead."

            if [[ "${key}" == "Warning no translation" ]]; then
                for var in "${ARGPARSER_TRANSLATION_FILE}" \
                    "${ARGPARSER_LANGUAGE}" "${key}"
                do
                    warning_message="${warning_message/"%s"/${var}}"
                done
            else
                warning_message="$(argparser_translate \
                    "Warning no translation" "${warning_message}" \
                    "${ARGPARSER_TRANSLATION_FILE}" "${ARGPARSER_LANGUAGE}" \
                    "${key}")"
            fi

            argparser_print_error_or_warning_message "warning" false false \
                "${warning_message}"
        else
            string="${ARGPARSER_DICTIONARY[${key}]}"
        fi
    fi

    # Replace the format specifiers in the string and output it.
    for var in "${vars[@]}"; do
        string="${string/"%s"/${var}}"
    done
    printf '%s' "${string}"
}

function argparser_create_help_message() {
    # Create a help message for the script's arguments.
    #
    # Nonlocals:
    # - all_arg_groups: the associative array holding the argument
    #   groups (read-only)
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_choice_values: the associative array holding the choice
    #   values (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_help_texts: the associative array holding the help texts
    #   (read-only)
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - all_notes: the associative array holding the notes (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - all_value_names: the associative array holding the value names
    #   (read-only)
    # - help_message_groups: the associative array holding the help
    #   message's groups usable as include directive
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_1 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_2 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_3 (read-only)
    # - ARGPARSER_POSITIONAL_ARG_GROUP (read-only)
    # - ARGPARSER_SCRIPT_NAME (read-only)

    # Define the local variables.
    local arg_group
    local -a arg_groups
    local arg_key
    local arg_number
    local choice_values
    local -a col_1
    local -a col_2
    local -a col_3
    local col_width_1
    local col_width_2
    local col_width_3
    local count
    local default_values
    local has_default_args
    local has_required_args
    local help_message
    local help_text
    local i
    local index
    local is_deprecated
    local j
    local -a line
    local line_count_1
    local line_count_2
    local line_count_3
    local lines_col_1
    local lines_col_2
    local lines_col_3
    local long_option
    local long_options
    local max_line_count
    local -a new_col_1
    local new_col_1_value
    local -a new_col_2
    local new_col_2_value
    local -a new_col_3
    local new_col_3_value
    local newline_count_1
    local newline_count_2
    local newline_count_3
    local newlines_1
    local newlines_2
    local newlines_3
    local note
    local -a notes
    local -a option_names
    local remark
    local short_options
    local -A sorted_col_1
    local -A sorted_col_2
    local -A sorted_col_3
    local usage
    local -a value_names
    local -a whitespace_1
    local -a whitespace_2
    local whitespace_len_1
    local whitespace_len_2

    # Read the arguments' groups to sort the keyword arguments by group
    # in the help message.  To this end, compare each argument's group
    # later upon iterating over them.
    arg_groups=( )
    for arg_group in "${all_arg_groups[@]}"; do
        if [[ "${arg_group}" != "${ARGPARSER_POSITIONAL_ARG_GROUP}" \
            && "$(argparser_in_array "${arg_group}" \
                "${arg_groups[@]}")" == false ]]
        then
            arg_groups+=("${arg_group}")
        fi
    done

    # The help message is structured in three columns: short options,
    # long options and the help text.  Populate these columns with the
    # entries for each argument.
    col_1=( )
    col_2=( )
    col_3=( )

    has_default_args=false
    has_required_args=false

    # Compute the columns for the positional arguments.
    for arg_key in "${all_positional_args[@]}"; do
        # Read the argument's definition.
        value_names="${all_value_names[${arg_key}]}"
        default_values="${all_default_values[${arg_key}]}"
        choice_values="${all_choice_values[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a notes \
            <<< "${all_notes[${arg_key}]}"
        help_text="${all_help_texts[${arg_key}]}"

        # Set a flag whether the argument is deprecated.
        is_deprecated=false
        for note in "${notes[@]}"; do
            if [[ "${note}" == "deprecated" ]]; then
                is_deprecated=true
            fi
        done

        # Define the columns' next line, for the current argument.  The
        # argument may have some default and some choice values with the
        # existence of each changing  the look of the first column.
        # Set the first column's value.
        if [[ "${choice_values}" != "-" && "${default_values}" != "-" ]]
        then  # Choice and default.
            col_1+=("$(printf "[%s={%s}]" "${value_names}" \
                "${choice_values}")")
        elif [[ "${choice_values}" != "-" ]]; then  # Choice only.
            col_1+=("$(printf "%s={%s}" "${value_names}" "${choice_values}")")
        elif [[ "${default_values}" != "-" ]]; then  # Default only.
            col_1+=("$(printf "[%s]" "${value_names}")")
        else  # No choice nor default.
            col_1+=("$(printf "%s" "${value_names}")")
        fi

        # Set the second column's value.
        col_2+=("")

        # Set the third column's value.
        if [[ "${default_values}" != "-" && "${is_deprecated}" == true ]]
        then  # Default and deprecated.
            new_col_3_value="($(argparser_translate "Deprecated" \
                "DEPRECATED")) "
            new_col_3_value+="${help_text} ("
            new_col_3_value+="$(argparser_translate "Default" "default"): "
            new_col_3_value+="${default_values})"
            col_3+=("${new_col_3_value}")
        elif [[ "${default_values}" != "-" ]]; then  # Default only
            new_col_3_value="${help_text} ("
            new_col_3_value+="$(argparser_translate "Default" "default"): "
            new_col_3_value+="${default_values})"
            col_3+=("${new_col_3_value}")
        elif [[ "${is_deprecated}" == true ]]; then  # Deprecated only.
            new_col_3_value="($(argparser_translate "Deprecated" \
                "DEPRECATED")) "
            new_col_3_value+="${help_text}"
            col_3+=("${new_col_3_value}")
        else  # No default nor deprecated.
            col_3+=("${help_text}")
        fi
    done

    # To mark the end of an argument group later upon printing, add an
    # empty line in all three columns.  This cannot appear by chance,
    # whereas empty lines for single columns emerge from the line break
    # insertion when they are differently long.  Thus, a completely
    # empty line can be used as safe argument group delimiter.
    col_1+=("")
    col_2+=("")
    col_3+=("")

    # Compute the columns for the keyword arguments.
    for arg_group in "${arg_groups[@]}"; do
        new_col_1=( )
        new_col_2=( )
        new_col_3=( )
        option_names=( )

        for arg_key in "${!all_short_options[@]}"; do
            # Read the argument's group to check whether it belongs to
            # the current group.
            if [[ "${all_arg_groups[${arg_key}]}" != "${arg_group}" ]]; then
                continue
            fi

            # Read the argument's remaining definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
                <<< "${all_short_options[${arg_key}]}"
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
                <<< "${all_long_options[${arg_key}]}"
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a value_names \
                <<< "${all_value_names[${arg_key}]}"
            default_values="${all_default_values[${arg_key}]}"
            choice_values="${all_choice_values[${arg_key}]}"
            arg_number="${all_arg_numbers[${arg_key}]}"
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a notes \
                <<< "${all_notes[${arg_key}]}"
            help_text="${all_help_texts[${arg_key}]}"

            # Concatenate the name of all short and long options for the
            # sorting of all arguments, later.
            option_names+=("$(argparser_get_option_names "${arg_key}" \
                "long-short")")

            # Set a flag whether the option has default values for
            # adjustment of the help message header, later.
            if [[ "${default_values}" != "-" ]]; then
                has_default_args=true
            else
                has_required_args=true
            fi

            # Set a flag whether the option is deprecated.
            is_deprecated=false
            for note in "${notes[@]}"; do
                if [[ "${note}" == "deprecated" ]]; then
                    is_deprecated=true
                fi
            done

            # Define the columns' next line, for the current argument.
            # The argument may have some short and long options, along
            # with value names, some default and some choice values or
            # an argument number of 0 (i.e., it is a flag), with the
            # existence of each changing  the look of the respective
            # column.  If either no short or no long option is given,
            # use the empty string instead.
            # Set the first column's value.
            if [[ "${short_options[0]}" == "-" ]]; then  # No short option.
                new_col_1+=("")
            elif [[ "${long_options[0]}" == "-" ]]; then  # No long option.
                if [[ "${arg_number}" == 0 ]]; then  # Flag.
                    new_col_1_value="["
                    new_col_1_value+="$(printf -- "-%s, " \
                        "${short_options[@]}")"
                    new_col_1_value="${new_col_1_value%, }"
                    new_col_1_value+="]"
                    new_col_1+=("${new_col_1_value}")
                elif [[ "${choice_values}" != "-" \
                    && "${default_values}" != "-" ]]
                then  # Choice and default.
                    new_col_1_value=""
                    for short_option in "${short_options[@]}"; do
                        new_col_1_value+="$(printf -- "[-%s={%s}], " \
                            "${short_option}" "${choice_values}")"
                    done
                    new_col_1_value="${new_col_1_value%, }"
                    new_col_1+=("${new_col_1_value}")
                elif [[ "${choice_values}" != "-" ]]; then  # Choice only.
                    new_col_1_value=""
                    for short_option in "${short_options[@]}"; do
                        new_col_1_value+="$(printf -- "-%s={%s}, " \
                            "${short_option}" "${choice_values}")"
                    done
                    new_col_1_value="${new_col_1_value%, }"
                    new_col_1+=("${new_col_1_value}")
                elif [[ "${default_values}" != "-" ]]; then  # Default only.
                    new_col_1_value=""
                    for i in "${!short_options[@]}"; do
                        new_col_1_value+="$(printf -- "[-%s=%s], " \
                            "${short_options[i]}" \
                            "${value_names[i]:-${short_options[i]^^}}")"
                    done
                    new_col_1_value="${new_col_1_value%, }"
                    new_col_1+=("${new_col_1_value}")
                else  # No choice nor default.
                    new_col_1_value=""
                    for i in "${!short_options[@]}"; do
                        new_col_1_value+="$(printf -- "-%s=%s, " \
                            "${short_options[i]}" \
                            "${value_names[i]:-${short_options[i]^^}}")"
                    done
                    new_col_1_value="${new_col_1_value%, }"
                    new_col_1+=("${new_col_1_value}")
                fi
            elif [[ "${arg_number}" == 0 ]]; then  # Long option, flag.
                new_col_1_value="["
                new_col_1_value+="$(printf -- "-%s, " "${short_options[@]}")"
                new_col_1_value="${new_col_1_value%, }"
                new_col_1_value+="],"
                new_col_1+=("${new_col_1_value}")
            else  # Long option, non-flag.
                new_col_1+=("$(printf -- "-%s, " "${short_options[@]}")")
            fi

            # Set the second column's value.
            if [[ "${long_options[0]}" == "-" ]]; then  # No long option.
                new_col_2+=("")
            elif [[ "${arg_number}" == 0 ]]; then  # Flag.
                new_col_2_value="["
                new_col_2_value+="$(printf -- "--%s, " "${long_options[@]}")"
                new_col_2_value="${new_col_2_value%, }"
                new_col_2_value+="]"
                new_col_2+=("${new_col_2_value}")
            elif [[ "${choice_values}" != "-" && "${default_values}" != "-" ]]
            then  # Choice and default.
                new_col_2_value=""
                for long_option in "${long_options[@]}"; do
                    new_col_2_value+="$(printf -- "[--%s={%s}], " \
                        "${long_option}" "${choice_values}")"
                done
                new_col_2_value="${new_col_2_value%, }"
                new_col_2+=("${new_col_2_value}")
            elif [[ "${choice_values}" != "-" ]]; then  # Choice only.
                new_col_2_value=""
                for long_option in "${long_options[@]}"; do
                    new_col_2_value+="$(printf -- "--%s={%s}, " \
                        "${long_option}" "${choice_values}")"
                done
                new_col_2_value="${new_col_2_value%, }"
                new_col_2+=("${new_col_2_value}")
            elif [[ "${default_values}" != "-" ]]; then  # Default only.
                new_col_2_value=""
                for i in "${!long_options[@]}"; do
                    new_col_2_value+="$(printf -- "[--%s=%s], " \
                        "${long_options[i]}" \
                        "${value_names[i]:-${long_options[i]^^}}")"
                done
                new_col_2_value="${new_col_2_value%, }"
                new_col_2+=("${new_col_2_value}")
            else  # No choice nor default.
                new_col_2_value=""
                for i in "${!long_options[@]}"; do
                    new_col_2_value+="$(printf -- "--%s=%s, " \
                        "${long_options[i]}" \
                        "${value_names[i]:-${long_options[i]^^}}")"
                done
                new_col_2_value="${new_col_2_value%, }"
                new_col_2+=("${new_col_2_value}")
            fi

            # Set the third column's value.
            if [[ "${arg_number}" == 0  && "${is_deprecated}" == true ]]
            then  # Flag and deprecated.
                new_col_3_value="($(argparser_translate "Deprecated" \
                    "DEPRECATED")) "
                new_col_3_value+="${help_text} ("
                new_col_3_value+="$(argparser_translate "Default" "default"): "
                new_col_3_value+="$(argparser_translate "${default_values}" \
                    "${default_values}"))"
                new_col_3+=("${new_col_3_value}")
            elif [[ "${arg_number}" == 0 ]]; then  # Flag only.
                new_col_3_value="${help_text} ("
                new_col_3_value+="$(argparser_translate "Default" "default"): "
                new_col_3_value+="$(argparser_translate "${default_values}"\
                    "${default_values}"))"
                new_col_3+=("${new_col_3_value}")
            elif [[ "${default_values}" != "-" && "${is_deprecated}" == true ]]
            then  # Default and deprecated.
                new_col_3_value="($(argparser_translate "Deprecated" \
                    "DEPRECATED")) "
                new_col_3_value+="${help_text} ("
                new_col_3_value+="$(argparser_translate "Default" "default"): "
                new_col_3_value+="${default_values})"
                new_col_3+=("${new_col_3_value}")
            elif [[ "${default_values}" != "-" ]]; then  # Default only
                new_col_3_value="${help_text} ("
                new_col_3_value+="$(argparser_translate "Default" "default"): "
                new_col_3_value+="${default_values})"
                new_col_3+=("${new_col_3_value}")
            elif [[ "${is_deprecated}" == true ]]; then  # Deprecated only.
                new_col_3_value="($(argparser_translate "Deprecated" \
                    "DEPRECATED")) "
                new_col_3_value+="${help_text}"
                new_col_3+=("${new_col_3_value}")
            else  # No default nor deprecated.
                new_col_3+=("${help_text}")
            fi
        done

        # Sort the arguments by the option names.  To this end, three
        # associative arrays are defined that use the option names as
        # keys and the first, second, or third column's values as
        # values.  Then, the option names' indexed array gets sorted and
        # the indexed arrays for the first, second, and third columns
        # are re-populated using the values from the associative array,
        # such that the sorted option names define the order of the yet
        # unsorted columns.  As a consequence, all columns are sorted as
        # if they would have been sorted together (which appears not be
        # feasible).
        for i in "${!option_names[@]}"; do
            sorted_col_1[${option_names[i]}]="${new_col_1[i]}"
            sorted_col_2[${option_names[i]}]="${new_col_2[i]}"
            sorted_col_3[${option_names[i]}]="${new_col_3[i]}"
        done

        mapfile -d "" -t option_names \
            < <(argparser_sort false "${option_names[@]}")

        for i in "${!option_names[@]}"; do
            col_1+=("${sorted_col_1[${option_names[i]}]}")
            col_2+=("${sorted_col_2[${option_names[i]}]}")
            col_3+=("${sorted_col_3[${option_names[i]}]}")
        done

        # To mark the end of an argument group later upon printing, add
        # an empty line in all three columns.  This cannot appear by
        # chance, whereas empty lines for single columns emerge from the
        # line break insertion when they are differently long.  Thus, a
        # completely empty line can be used as safe argument group
        # delimiter.
        col_1+=("")
        col_2+=("")
        col_3+=("")
    done

    # Add the help, usage, and version flags that always exist (if
    # defined).
    if [[ "${ARGPARSER_ADD_HELP}" == true ]]; then
        col_1+=("-h,")
        col_2+=("--help")
        col_3+=("$(argparser_translate "--help" "display this help and exit")")
    fi

    if [[ "${ARGPARSER_ADD_USAGE}" == true ]]; then
        col_1+=("-u,")
        col_2+=("--usage")
        col_3+=("$(argparser_translate "--usage" \
            "display the usage and exit")")
    fi

    if [[ "${ARGPARSER_ADD_VERSION}" == true ]]; then
        col_1+=("-V,")
        col_2+=("--version")
        col_3+=("$(argparser_translate "--version" \
            "display the version and exit")")
    fi

    # Limit the width of each column of the help message to
    # ${ARGPARSER_MAX_COL_WIDTH_*} by inserting line breaks.
    # Split the element of column 1.
    col_width_1=0
    for i in "${!col_1[@]}"; do
        mapfile -d "" -t line \
            < <(argparser_fold "${col_1[i]}" "${ARGPARSER_MAX_COL_WIDTH_1}" \
                "${col_width_1}")
        col_1[i]="${line[0]}"
        col_width_1="${line[1]}"
    done

    # Split the element of column 2.
    col_width_2=0
    for i in "${!col_2[@]}"; do
        mapfile -d "" -t line \
            < <(argparser_fold "${col_2[i]}" "${ARGPARSER_MAX_COL_WIDTH_2}" \
                "${col_width_2}")
        col_2[i]="${line[0]}"
        col_width_2="${line[1]}"
    done

    # Split the element of column 3.
    col_width_3=0
    for i in "${!col_3[@]}"; do
        mapfile -d "" -t line \
            < <(argparser_fold "${col_3[i]}" "${ARGPARSER_MAX_COL_WIDTH_3}" \
                "${col_width_3}")
        col_3[i]="${line[0]}"
        col_width_3="${line[1]}"
    done

    # Adjust the number of line breaks between each column's rows, such
    # that each element shares the same number of rows.
    for i in "${!col_1[@]}"; do
        # Count the number of rows for each element.
        mapfile -t lines_col_1 <<< "${col_1[i]}"
        line_count_1="${#lines_col_1[@]}"

        mapfile -t lines_col_2 <<< "${col_2[i]}"
        line_count_2="${#lines_col_2[@]}"

        mapfile -t lines_col_3 <<< "${col_3[i]}"
        line_count_3="${#lines_col_3[@]}"

        # Get the largest line count.
        if (( line_count_1 > line_count_2 )); then
            if (( line_count_1 > line_count_3 )); then
                max_line_count="${line_count_1}"
            else
                max_line_count="${line_count_3}"
            fi
        else
            if (( line_count_2 > line_count_3 )); then
                max_line_count="${line_count_2}"
            else
                max_line_count="${line_count_3}"
            fi
        fi

        # Set the number of required line breaks to align each line.  If
        # the line count is 0, 1 is subtracted from the maximum line
        # count, such that the last line does not end in a line break.
        # The same holds true for a line count of greater than 0, where
        # normally 1 would have to be added.  This trailing newline
        # character gets added by the here string upon re-reading the
        # arrays, below.
        if (( line_count_1 == 0 )); then
            (( newline_count_1 = max_line_count - 1 ))
        else
            (( newline_count_1 = max_line_count - line_count_1 ))
        fi

        if (( line_count_2 == 0 )); then
            (( newline_count_2 = max_line_count - 1 ))
        else
            (( newline_count_2 = max_line_count - line_count_2 ))
        fi

        if (( line_count_3 == 0 )); then
            (( newline_count_3 = max_line_count - 1 ))
        else
            (( newline_count_3 = max_line_count - line_count_3 ))
        fi

        # To each element, add as many line breaks as computed.
        newlines_1=""
        for (( j = 0; j < newline_count_1; j++ )); do
            newlines_1+=$'\n'
        done
        col_1[i]+="${newlines_1}"

        newlines_2=""
        for (( j = 0; j < newline_count_2; j++ )); do
            newlines_2+=$'\n'
        done
        col_2[i]+="${newlines_2}"

        newlines_3=""
        for (( j = 0; j < newline_count_3; j++ )); do
            newlines_3+=$'\n'
        done
        col_3[i]+="${newlines_3}"
    done

    # Re-read in the columns' lines, such that each line makes up one
    # element of the array.  To this end, split the lines on newline
    # characters (that get stripped off the lines).  The here string
    # adds a trailing newline that acts as additional delimiter.  Else,
    # a line without line break would give the same number of lines
    # (one) as a line with one line break as trailing newline, since
    # line breaks act as trailing delimiters for mapfile, not as inner
    # separators.
    new_col_1=( )
    new_col_2=( )
    new_col_3=( )
    for i in "${!col_1[@]}"; do
        mapfile -t -O "${#new_col_1[@]}" new_col_1 <<< "${col_1[i]}"
        mapfile -t -O "${#new_col_2[@]}" new_col_2 <<< "${col_2[i]}"
        mapfile -t -O "${#new_col_3[@]}" new_col_3 <<< "${col_3[i]}"
    done

    # Store the lines back in the original columns' variables.
    col_1=("${new_col_1[@]}")
    col_2=("${new_col_2[@]}")
    col_3=("${new_col_3[@]}")

    # For proper alignment of the columns, whitespace must be used as
    # separation between shorter elements.  Compute the width for both
    # the first and the second column.  If a line is wider, set the
    # width to the respective value, as long as the width doesn't exceed
    # the limit set by ${ARGPARSER_MAX_COL_WIDTH_*}.
    col_width_1=0
    col_width_2=0
    for i in "${!col_1[@]}"; do
        if (( "${#col_1[i]}" <= ARGPARSER_MAX_COL_WIDTH_1 \
            && "${#col_1[i]}" > col_width_1 ))
        then
            col_width_1="${#col_1[i]}"
        fi

        if (( "${#col_2[i]}" <= ARGPARSER_MAX_COL_WIDTH_2 \
            && "${#col_2[i]}" > col_width_2 ))
        then
            col_width_2="${#col_2[i]}"
        fi
    done

    # Compute the length of whitespace between column 1 and 2, as well
    # as between column 2 and 3.  This length equals the column's
    # maximum width minus the current line's element's length plus 1 to
    # have at least one space as separation.  If the column width
    # exceeds the limit set by ${ARGPARSER_MAX_COL_WIDTH_*}, insert a
    # line break instead to make the following column's content begin on
    # the next line.  Then, insert as much whitespace as needed to align
    # the column with the other elements.  For column 1, this equals the
    # column's maximum width plus 1 (the mandatory separation), for
    # column 2, both columns' maximum widths plus 2 (twice the mandatory
    # separation).
    whitespace_1=( )
    whitespace_2=( )
    for i in "${!col_1[@]}"; do
        if (( "${#col_1[i]}" <= ARGPARSER_MAX_COL_WIDTH_1 )); then
            (( whitespace_len_1 = col_width_1 - "${#col_1[i]}" + 1 ))
            whitespace_1+=("$(printf '%*s' "${whitespace_len_1}" "")")
        else
            (( whitespace_len_1 = col_width_1 + 1 ))
            whitespace_1+=("$(printf '\n%*s' "${whitespace_len_1}" "")")
        fi

        if (( "${#col_2[i]}" <= ARGPARSER_MAX_COL_WIDTH_2 )); then
            (( whitespace_len_2 = col_width_2 - "${#col_2[i]}" + 1 ))
            whitespace_2+=("$(printf '%*s' "${whitespace_len_2}" "")")
        else
            (( whitespace_len_2 = col_width_1 + col_width_2 + 2 ))
            whitespace_2+=("$(printf '\n%*s' "${whitespace_len_2}" "")")
        fi
    done

    # Set the help message's usage line, including the script's name.
    usage="$(argparser_translate "Usage" "Usage"): ${ARGPARSER_SCRIPT_NAME}"

    # Add a hint for the optional keyword arguments (as summary), if
    # existing.
    if [[ "${has_default_args}" == true ]]; then
        usage+=" [$(argparser_translate "Options" "OPTIONS")]"
    fi

    # Add a hint for the mandatory keyword arguments (as summary), if
    # existing.
    if [[ "${has_required_args}" == true ]]; then
        usage+=" $(argparser_translate "Arguments" "ARGUMENTS")"
    fi

    # Add the names of the positional arguments, if existing.
    if (( "${#all_positional_args[@]}" > 0 )); then
        usage+=" [--]"
        for arg_key in "${all_positional_args[@]}"; do
            value_names=("${all_value_names[${arg_key}]}")
            default_values="${all_default_values[${arg_key}]}"

            if [[ "${default_values}" != "-" ]]; then
                usage+=" [${value_names[0]}]"
            else
                usage+=" ${value_names[0]}"
            fi
        done
    fi

    usage+=$'\n'
    help_message_groups["Usage"]="${usage}"

    # Set the remark.
    remark="Mandatory arguments to long options are mandatory for short "
    remark+="options too"
    remark="$(argparser_translate "Mandatory arguments" "${remark}")."
    remark+=$'\n'
    help_message_groups["Remark"]="${remark}"

    # For each argument group, including the positional argument group
    # as first one, and the rest being sorted alphabetically, print its
    # arguments.
    index=0
    arg_groups=("${ARGPARSER_POSITIONAL_ARG_GROUP}" "${arg_groups[@]}")
    for arg_group in "${arg_groups[@]}"; do
        # Set the argument group's name for output.
        help_message="${arg_group}:"
        help_message+=$'\n'

        # For any argument line, output the three columns and their
        # delimiting whitespace.  If all three columns are empty, the
        # end of the current argument group has been reached.
        for (( i = index; i < "${#col_1[@]}"; i++ )); do
            if [[ -z "${col_1[i]}" && -z "${col_2[i]}" && -z "${col_3[i]}" ]]
            then
                break
            fi

            help_message+="${col_1[i]}${whitespace_1[i]}${col_2[i]}"
            help_message+="${whitespace_2[i]}${col_3[i]}"
            help_message+=$'\n'
        done
        help_message_groups[${arg_group}]="${help_message}"

        # Set the start index for the next argument group to the current
        # group's end index plus 1 (with the latter being the empty line
        # used as argument group delimiter).
        (( index = i + 1 ))
    done

    # Output the help, usage, and version lines, which are the last
    # three lines.  Thereby, count the number of "true" as value of the
    # respective environment variable, viz. ${ARGPARSER_ADD_HELP},
    # ${ARGPARSER_ADD_USAGE}, and ${ARGPARSER_ADD_VERSION}.
    count="$(argparser_count true "${ARGPARSER_ADD_HELP}" \
        "${ARGPARSER_ADD_USAGE}" "${ARGPARSER_ADD_VERSION}")"
    help_message=""
    if (( count == 3 )); then
        help_message+="${col_1[-3]}${whitespace_1[-3]}${col_2[-3]}"
        help_message+="${whitespace_2[-3]}${col_3[-3]}"
        help_message+=$'\n'
    fi
    if (( count >= 2 )); then
        help_message+="${col_1[-2]}${whitespace_1[-2]}${col_2[-2]}"
        help_message+="${whitespace_2[-2]}${col_3[-2]}"
        help_message+=$'\n'
    fi
    if (( count >= 1 )); then
        help_message+="${col_1[-1]}${whitespace_1[-1]}${col_2[-1]}"
        help_message+="${whitespace_2[-1]}${col_3[-1]}"
        help_message+=$'\n'
    fi
    help_message_groups["Help"]="${help_message}"
}

function argparser_create_usage_message() {
    # Create a usage message for the script's arguments.
    #
    # Nonlocals:
    # - all_arg_numbers: the associative array holding the argument
    #   numbers (read-only)
    # - all_choice_values: the associative array holding the choice
    #   values (read-only)
    # - all_default_values: the associative array holding the default
    #   values (read-only)
    # - all_long_options: the associative array holding the long option
    #   names (read-only)
    # - all_positional_args: the indexed array holding the positional
    #   argument names (read-only)
    # - all_short_options: the associative array holding the short
    #   option names (read-only)
    # - all_value_names: the associative array holding the value names
    #   (read-only)
    # - usage_message_groups: the associative array holding the usage
    #   message's groups usable as include directive
    #
    # Environment:
    # - ARGPARSER_ADD_HELP (read-only)
    # - ARGPARSER_ADD_USAGE (read-only)
    # - ARGPARSER_ADD_VERSION (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_SCRIPT_NAME (read-only)
    # - ARGPARSER_USAGE_MESSAGE_OPTION_TYPE(read-only)
    # - ARGPARSER_USAGE_MESSAGE_ORIENTATION (read-only)

    # Define the local variables.
    local arg_key
    local arg_number
    local choice_values
    local default_values
    local header
    local -a lines
    local -a long_option_default_args
    local -a long_option_required_args
    local -a long_options
    local -a positional_default_args
    local -a positional_required_args
    local -a short_option_default_args
    local -a short_option_required_args
    local -a short_options
    local usage_message
    local value_names
    local whitespace
    local whitespace_len

    # Output the usage message's header, giving the script's name and
    # the existence of the -h | --help, -u | --usage, and -V | --version
    # arguments.
    header="$(argparser_translate "Usage" "Usage"): ${ARGPARSER_SCRIPT_NAME}"
    if [[ "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" == "short" ]]; then
        if [[ "${ARGPARSER_ADD_HELP}" == true \
            && "${ARGPARSER_ADD_USAGE}" == true \
            && "${ARGPARSER_ADD_VERSION}" == true ]]
        then
            usage_message="${header} [-h | -u | -V]"
        elif [[ "${ARGPARSER_ADD_HELP}" == true \
            && "${ARGPARSER_ADD_USAGE}" == true ]]
        then
            usage_message="${header} [-h | -u]"
        elif [[ "${ARGPARSER_ADD_HELP}" == true \
            && "${ARGPARSER_ADD_VERSION}" == true ]]
        then
            usage_message="${header} [-h | -V]"
        elif [[ "${ARGPARSER_ADD_USAGE}" == true \
            && "${ARGPARSER_ADD_VERSION}" == true ]]
        then
            usage_message="${header} [-u | -V]"
        elif [[ "${ARGPARSER_ADD_HELP}" == true ]]; then
            usage_message="${header} [-h]"
        elif [[ "${ARGPARSER_ADD_USAGE}" == true ]]; then
            usage_message="${header} [-u]"
        elif [[ "${ARGPARSER_ADD_VERSION}" == true ]]; then
            usage_message="${header} [-V]"
        fi
    else
        if [[ "${ARGPARSER_ADD_HELP}" == true \
            && "${ARGPARSER_ADD_USAGE}" == true \
            && "${ARGPARSER_ADD_VERSION}" == true ]]
        then
            usage_message="${header} [--help | --usage | --version]"
        elif [[ "${ARGPARSER_ADD_HELP}" == true \
            && "${ARGPARSER_ADD_USAGE}" == true ]]
        then
            usage_message="${header} [--help | --usage]"
        elif [[ "${ARGPARSER_ADD_HELP}" == true \
            && "${ARGPARSER_ADD_VERSION}" == true ]]
        then
            usage_message="${header} [--help | --version]"
        elif [[ "${ARGPARSER_ADD_USAGE}" == true \
            && "${ARGPARSER_ADD_VERSION}" == true ]]
        then
            usage_message="${header} [--usage | --version]"
        elif [[ "${ARGPARSER_ADD_HELP}" == true ]]; then
            usage_message="${header} [--help]"
        elif [[ "${ARGPARSER_ADD_USAGE}" == true ]]; then
            usage_message="${header} [--usage]"
        elif [[ "${ARGPARSER_ADD_VERSION}" == true ]]; then
            usage_message="${header} [--version]"
        fi
    fi

    # To keep all arguments aligned in columnar output, compute the
    # length of the script name and the (translated) leading "Usage: ".
    # For a row-like orientation, only use one space.
    if [[ "${ARGPARSER_USAGE_MESSAGE_ORIENTATION}" == "column" ]]; then
        whitespace_len="${#header}"
        (( whitespace_len++ ))
        whitespace="$(printf '\n%*s' "${whitespace_len}" "")"
    else
        whitespace=" "
    fi

    # If ${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE} is set to "short",
    # separate keyword arguments with default values from those without
    # to output first the arguments with default values and afterwards
    # those without.  Within either block, separate arguments with short
    # options from those without to output first the arguments with
    # short option names and then those with only long option names.  If
    # ${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE} is set to "long", do the
    # same for the long options and short option-only arguments.  In
    # both cases, having both short and long option names does not
    # matter as only one sort gets printed.
    short_option_default_args=( )
    short_option_required_args=( )
    long_option_default_args=( )
    long_option_required_args=( )
    if [[ "${ARGPARSER_USAGE_MESSAGE_OPTION_TYPE}" == "short" ]]; then
        for arg_key in "${!all_short_options[@]}"; do
            # Read the argument's definition.
            short_options="${all_short_options[${arg_key}]}"
            default_values="${all_default_values[${arg_key}]}"

            # Add the argument to the respective array.
            if [[ "${default_values}" == "-" ]]; then
                if [[ "${short_options}" == "-" ]]; then
                    long_option_required_args+=("${arg_key}")
                else
                    short_option_required_args+=("${arg_key}")
                fi
            else
                if [[ "${short_options}" == "-" ]]; then
                    long_option_default_args+=("${arg_key}")
                else
                    short_option_default_args+=("${arg_key}")
                fi
            fi
        done
    else
        for arg_key in "${!all_short_options[@]}"; do
            # Read the argument's definition.
            long_options="${all_long_options[${arg_key}]}"
            default_values="${all_default_values[${arg_key}]}"

            # Add the argument to the respective array.
            if [[ "${default_values}" == "-" ]]; then
                if [[ "${long_options}" == "-" ]]; then
                    short_option_required_args+=("${arg_key}")
                else
                    long_option_required_args+=("${arg_key}")
                fi
            else
                if [[ "${long_options}" == "-" ]]; then
                    short_option_default_args+=("${arg_key}")
                else
                    long_option_default_args+=("${arg_key}")
                fi
            fi
        done
    fi

    # Likewise, separate positional arguments with default values from
    # those without.
    positional_default_args=( )
    positional_required_args=( )
    for arg_key in "${all_positional_args[@]}"; do
        # Read the argument's definition.
        default_values="${all_default_values[${arg_key}]}"

        # Add the argument to the respective array.
        if [[ "${default_values}" == "-" ]]; then
            positional_required_args+=("${arg_key}")
        else
            positional_default_args+=("${arg_key}")
        fi
    done

    # Output each keyword argument with short options and default values
    # and sort them alphabetically.
    lines=( )
    for arg_key in "${short_option_default_args[@]}"; do
        # Read the argument's definition.
        short_options=("${all_short_options[${arg_key}]}")
        value_names="${all_value_names[${arg_key}]}"
        choice_values="${all_choice_values[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # If no value name is given, set them to the capitalized short
        # option names.
        if [[ "${value_names}" == "-" ]]; then
            value_names="${short_options[0]^^}"
        fi

        # Prefix the short options with one hyphen for their printing
        # style.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
            <<< "${short_options[0]}"
        short_options=("$(printf -- "-%s${ARGPARSER_ARG_DELIMITER_2}" \
            "${short_options[@]}")")
        short_options=("${short_options[0]%?}")

        # Define the line for the current argument.  The argument has
        # some short options and some default values and may have some
        # choice values or an argument number of 0 (i.e., it is a flag),
        # with the existence of each changing the look of the line.
        if [[ "${arg_number}" == 0 ]]; then  # Flag.
            lines+=("$(printf '[%s]' "${short_options[0]}")")
        elif [[ "${choice_values}" != "-" ]]; then  # Choice and default.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("$(printf '[%s={%s}...]' "${short_options[0]}" \
                    "${choice_values}")")
            else
                lines+=("$(printf '[%s={%s}]' "${short_options[0]}" \
                    "${choice_values}")")
            fi
        else  # Default only.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("$(printf '[%s=%s...]' "${short_options[0]}" \
                    "${value_names}")")
            else
                lines+=("$(printf '[%s=%s]' "${short_options[0]}" \
                    "${value_names}")")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        mapfile -d "" -t lines < <(argparser_sort false "${lines[@]}")
        usage_message+="$(printf "${whitespace}%s" "${lines[@]}")"
    fi

    # Output each keyword argument with long options and default values
    # and sort them alphabetically.
    lines=( )
    for arg_key in "${long_option_default_args[@]}"; do
        # Read the argument's definition.
        long_options=("${all_long_options[${arg_key}]}")
        value_names="${all_value_names[${arg_key}]}"
        choice_values="${all_choice_values[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # If no value name is given, set them to the capitalized long
        # option names.
        if [[ "${value_names}" == "-" ]]; then
            value_names="${long_options[0]^^}"
        fi

        # Prefix the long options with two hyphens for their printing
        # style.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
            <<< "${long_options[0]}"
        long_options=("$(printf -- "--%s${ARGPARSER_ARG_DELIMITER_2}" \
            "${long_options[@]}")")
        long_options=("${long_options[0]%?}")

        # Define the line for the current argument.  The argument has
        # some long options and some default values and may have some
        # choice values or an argument number of 0 (i.e., it is a flag),
        # with the existence of each changing the look of the line.
        if [[ "${arg_number}" == 0 ]]; then  # Flag.
            lines+=("$(printf '[%s]' "${long_options[0]}")")
        elif [[ "${choice_values}" != "-" ]]; then  # Choice and default.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("$(printf '[%s={%s}...]' "${long_options[0]}" \
                    "${choice_values}")")
            else
                lines+=("$(printf '[%s={%s}]' "${long_options[0]}" \
                    "${choice_values}")")
            fi
        else  # Default only.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("$(printf '[%s=%s...]' "${long_options[0]}" \
                    "${value_names}")")
            else
                lines+=("$(printf '[%s=%s]' "${long_options[0]}" \
                    "${value_names}")")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        mapfile -d "" -t lines < <(argparser_sort false "${lines[@]}")
        usage_message+="$(printf "${whitespace}%s" "${lines[@]}")"
    fi

    # Output each keyword argument with short options and without
    # default values and sort them alphabetically.
    lines=( )
    for arg_key in "${short_option_required_args[@]}"; do
        # Read the argument's definition.
        short_options=("${all_short_options[${arg_key}]}")
        value_names="${all_value_names[${arg_key}]}"
        choice_values="${all_choice_values[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # If no value name is given, set them to the capitalized short
        # option names.
        if [[ "${value_names}" == "-" ]]; then
            value_names="${short_options[0]^^}"
        fi

        # Prefix the short options with one hyphen for their printing
        # style.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a short_options \
            <<< "${short_options[0]}"
        short_options=("$(printf -- "-%s${ARGPARSER_ARG_DELIMITER_2}" \
            "${short_options[@]}")")
        short_options=("${short_options[0]%?}")

        # Define the line for the current argument.  The argument has
        # some short options and no default values and may have some
        # choice values, with the existence of each changing the look of
        # the line.
        if [[ "${choice_values}" != "-" ]]; then  # Choice only.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("$(printf '%s={%s}...' "${short_options[0]}" \
                    "${choice_values}")")
            else
                lines+=("$(printf '%s={%s}' "${short_options[0]}" \
                    "${choice_values}")")
            fi
        else  # No choice nor default.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("$(printf '%s=%s...' "${short_options[0]}" \
                    "${value_names}")")
            else
                lines+=("$(printf '%s=%s' "${short_options[0]}" \
                    "${value_names}")")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        mapfile -d "" -t lines < <(argparser_sort false "${lines[@]}")
        usage_message+="$(printf "${whitespace}%s" "${lines[@]}")"
    fi

    # Output each keyword argument with long options and without default
    # values and sort them alphabetically.
    lines=( )
    for arg_key in "${long_option_required_args[@]}"; do
        # Read the argument's definition.
        long_options=("${all_long_options[${arg_key}]}")
        value_names="${all_value_names[${arg_key}]}"
        choice_values="${all_choice_values[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # If no value name is given, set them to the capitalized long
        # option names.
        if [[ "${value_names}" == "-" ]]; then
            value_names="${long_options[0]^^}"
        fi

        # Prefix the long options with two hyphens for their printing
        # style.
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -r -a long_options \
            <<< "${long_options[0]}"
        long_options=("$(printf -- "--%s${ARGPARSER_ARG_DELIMITER_2}" \
            "${long_options[@]}")")
        long_options=("${long_options[0]%?}")

        # Define the line for the current argument.  The argument has
        # some long options and no default values and may have some
        # choice values, with the existence of each changing the look of
        # the line.
        if [[ "${choice_values}" != "-" ]]; then  # Choice only.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("$(printf '%s={%s}...' "${long_options[0]}" \
                    "${choice_values}")")
            else
                lines+=("$(printf '%s={%s}' "${long_options[0]}" \
                    "${choice_values}")")
            fi
        else  # No choice nor default.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("$(printf '%s=%s...' "${long_options[0]}" \
                    "${value_names}")")
            else
                lines+=("$(printf '%s=%s' "${long_options[0]}" \
                    "${value_names}")")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        mapfile -d "" -t lines < <(argparser_sort false "${lines[@]}")
        usage_message+="$(printf "${whitespace}%s" "${lines[@]}")"
    fi

    # Output each positional argument with default values and sort them
    # alphabetically.
    lines=( )
    for arg_key in "${positional_default_args[@]}"; do
        # Read the argument's definition.
        value_names="${all_value_names[${arg_key}]}"
        choice_values="${all_choice_values[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # Define the line for the current argument.  The argument has
        # some default values and may have some choice values, with the
        # existence of each changing the look of the line.
        if [[ "${choice_values}" != "-" ]]; then  # Choice and default.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("$(printf '[{%s}...]' "${choice_values}")")
            else
                lines+=("$(printf '[{%s}]' "${choice_values}")")
            fi
        else  # Default only.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("$(printf '[%s...]' "${value_names}")")
            else
                lines+=("$(printf '[%s]' "${value_names}")")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        mapfile -d "" -t lines < <(argparser_sort false "${lines[@]}")
        usage_message+="$(printf "${whitespace}%s" "${lines[@]}")"
    fi

    # Output each positional argument without default values and sort
    # them alphabetically.
    lines=( )
    for arg_key in "${positional_required_args[@]}"; do
        # Read the argument's definition.
        value_names="${all_value_names[${arg_key}]}"
        choice_values="${all_choice_values[${arg_key}]}"
        arg_number="${all_arg_numbers[${arg_key}]}"

        # Define the line for the current argument.  The argument has no
        # default values and may have some choice values, with the
        # existence of each changing the look of the line.
        if [[ "${choice_values}" != "-" ]]; then  # Choice only.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("$(printf '{%s}...' "${choice_values}")")
            else
                lines+=("$(printf '{%s}' "${choice_values}")")
            fi
        else  # No choice nor default.
            if [[ "${arg_number}" == "+" ]]; then  # Multiple values.
                lines+=("$(printf '%s...' "${value_names}")")
            else
                lines+=("$(printf '%s' "${value_names}")")
            fi
        fi
    done

    if (( "${#lines[@]}" > 0 )); then
        mapfile -d "" -t lines < <(argparser_sort false "${lines[@]}")
        usage_message+="$(printf "${whitespace}%s" "${lines[@]}")"
    fi

    # Output the final usage message.
    usage_message+=$'\n'
    usage_message_groups["Usage"]="${usage_message}"
}

function argparser_print_help_or_usage_message() {
    # Print a help or usage message.  If a file with such is given,
    # print the file, else, create a message for the script's arguments.
    # For files, possibly skip commented lines (i.e., lines starting
    # with "#") and their trailing blank lines.  Replace lines starting
    # with ${ARGPARSER_*_FILE_INCLUDE_CHAR} by the auto-generated help
    #   or usage message.
    #
    # Arguments:
    # - $1: the help type ("help" or "usage")
    # - $2: whether to exit after printing
    # - $3: the target to write to ("file" or "tty")
    #
    # Nonlocals:
    # - all_arg_groups: the associative array holding the argument
    #   groups (read-only)
    # - help_message_groups: the associative array holding the help
    #   message's groups usable as include directive (read-only)
    # - usage_message_groups: the associative array holding the usage
    #   message's groups usable as include directive (read-only)
    #
    # Environment:
    # - ARGPARSER_HELP_EXIT_CODE (read-only)
    # - ARGPARSER_HELP_FILE (read-only)
    # - ARGPARSER_HELP_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_HELP_FILE_KEEP_COMMENTS (read-only)
    # - ARGPARSER_HELP_STYLE (read-only)
    # - ARGPARSER_POSITIONAL_ARG_GROUP (read-only)
    # - ARGPARSER_USAGE_EXIT_CODE (read-only)
    # - ARGPARSER_USAGE_FILE (read-only)
    # - ARGPARSER_USAGE_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_USAGE_FILE_KEEP_COMMENTS (read-only)
    # - ARGPARSER_USAGE_STYLE (read-only)

    # Define the local variables.
    local arg_group
    local -a arg_groups
    local exit
    local exit_code
    local file
    local help_type
    local include_char
    local include_directive
    local keep_comments
    local line
    local -a lines
    local line_type
    local message
    local style
    local write_target

    # Read the arguments.
    help_type="$1"
    exit="$2"
    write_target="$3"

    # Set the constants to the respective environment variables.
    if [[ "${help_type}" == "help" ]]; then
        file="${ARGPARSER_HELP_FILE}"
        include_char="${ARGPARSER_HELP_FILE_INCLUDE_CHAR}"
        keep_comments="${ARGPARSER_HELP_FILE_KEEP_COMMENTS}"
        style="${ARGPARSER_HELP_STYLE}"
        exit_code="${ARGPARSER_HELP_EXIT_CODE}"
    else
        file="${ARGPARSER_USAGE_FILE}"
        include_char="${ARGPARSER_USAGE_FILE_INCLUDE_CHAR}"
        keep_comments="${ARGPARSER_USAGE_FILE_KEEP_COMMENTS}"
        style="${ARGPARSER_USAGE_STYLE}"
        exit_code="${ARGPARSER_USAGE_EXIT_CODE}"
    fi

    # Read the keyword arguments' groups to sort them for the help
    # message.
    arg_groups=( )
    for arg_group in "${all_arg_groups[@]}"; do
        if [[ "${arg_group}" != "${ARGPARSER_POSITIONAL_ARG_GROUP}" \
            && "$(argparser_in_array "${arg_group}" \
                "${arg_groups[@]}")" == false ]]
        then
            arg_groups+=("${arg_group}")
        fi
    done

    # Sort the argument groups and prepend the positional arguments
    # group.
    mapfile -d "" -t arg_groups < <(argparser_sort false "${arg_groups[@]}")
    arg_groups=("${ARGPARSER_POSITIONAL_ARG_GROUP}" "${arg_groups[@]}")

    # Create the help or usage message groups, which are saved in an
    # associative array using the include directives as keys.
    if [[ "${help_type}" == "help" ]]; then
        argparser_create_help_message
    else
        argparser_create_usage_message
    fi

    # Read the help or usage file, if given, or set the lines to just
    # the include directive "All", meaning to create the entire help or
    # usage message.
    if [[ -n "${file}" ]]; then
        mapfile -t lines < "${file}"
    else
        lines=("${include_char}All")
    fi

    # For each line, print the text and replace the include directives
    # by the respective part from the help or usage message.  Possibly,
    # skip comments.
    line_type="text"
    message=""
    for line in "${lines[@]}"; do
        # Set ${line_type} to "include directive" if the line contains
        # an include directive, to "comment" if the line is commented
        # and ${keep_comments} is false, and to "text" if it is not
        # empty (but not commented).  Thus, empty lines following
        # comments still have ${line_type} set to "comment".  For
        # include directives, add the requested groups from the help or
        # usage message.
        if [[ "${line}" == "${include_char}"* ]]; then
            line_type="include directive"
            include_directive="${line:1}"
            if [[ "${help_type}" == "help" ]]; then
                if [[ "${include_directive}" == "All" ]]; then
                    message+="${help_message_groups["Usage"]}"
                    message+=$'\n'

                    message+="${help_message_groups["Remark"]}"
                    message+=$'\n'

                    for arg_group in "${arg_groups[@]}"; do
                        message+="${help_message_groups[${arg_group}]}"
                        message+=$'\n'
                    done

                    message+="${help_message_groups["Help"]}"
                elif [[ "${include_directive}" == "Header" ]]; then
                    message+="${help_message_groups["Usage"]}"
                    message+=$'\n'
                    message+="${help_message_groups["Remark"]}"
                else
                    message+="${help_message_groups[${include_directive}]}"
                fi
            else
                message+="${usage_message_groups["Usage"]}"
            fi
        elif [[ "${line}" == \#* && "${keep_comments}" == false ]]; then
            line_type="comment"
        elif [[ -n "${line}" || "${keep_comments}" == true ]]; then
            line_type="text"
        fi

        # If ${line_type} has been set to "text", print the current
        # line.  If it is set to "include_directive", reset it to "text"
        # to (possibly) print the next line, and only not the current
        # "<ArgumentGroup>" line.
        if [[ "${line_type}" == "text" ]]; then
            message+="${line}"
            message+=$'\n'
        elif [[ "${line_type}" == "include directive" ]]; then
            line_type="text"
        fi
    done 

    # Colorize and print the help or usage message, then exit, if
    # requested.
    argparser_colorize "${style}" "${message}" "${write_target}"

    if [[ "${exit}" == true ]]; then
        exit "${exit_code}"
    fi
}

function argparser_print_version_message() {
    # Create and print a version message.
    #
    # Arguments:
    # - $1: whether to exit after printing
    # - $2: the target to write to ("file" or "tty")
    #
    # Environment:
    # - ARGPARSER_SCRIPT_NAME (read-only)
    # - ARGPARSER_VERSION (read-only)
    # - ARGPARSER_VERSION_EXIT_CODE (read-only)
    # - ARGPARSER_VERSION_STYLE (read-only)

    # Define the local variables.
    local exit
    local message
    local write_target

    # Read the arguments.
    exit="$1"
    write_target="$2"

    # Colorize and print the version message, then exit, if requested.
    message="${ARGPARSER_SCRIPT_NAME} v${ARGPARSER_VERSION}"
    message="$(argparser_colorize "${ARGPARSER_VERSION_STYLE}" "${message}" \
        "${write_target}")"
    printf '%s\n' "${message}"

    if [[ "${exit}" == true ]]; then
        exit "${ARGPARSER_VERSION_EXIT_CODE}"
    fi
}

function argparser_print_error_or_warning_message() {
    # Colorize, sort, filter, and print all error or warning messages.
    #
    # Arguments:
    # - $1: the error type ("error" or "warning")
    # - $2: whether to filter the messages (by argparser_uniq)
    # - $3: whether to exit after printing
    # - $@: the error or warning messages
    #
    # Environment:
    # - ARGPARSER_ERROR_EXIT_CODE (read-only)
    # - ARGPARSER_ERROR_STYLE (read-only)
    # - ARGPARSER_SILENCE_ERRORS (read-only)
    # - ARGPARSER_SILENCE_WARNINGS (read-only)
    # - ARGPARSER_WARNING_STYLE (read-only)

    # Define the local variables.
    local exit
    local filter
    local message
    local -a messages
    local style
    local error_type
    local write_target

    # Read the arguments.
    error_type="$1"
    filter="$2"
    exit="$3"
    shift 3
    messages=("$@")

    # Set the colorization style.  If the error or warning message shall
    # not be emitted (output), return or exit, effectively silencing the
    # message.
    if [[ "${error_type}" == "error" ]]; then
        if [[ "${ARGPARSER_SILENCE_ERRORS}" == true ]]; then
            if [[ "${exit}" == true ]]; then
                exit "${ARGPARSER_ERROR_EXIT_CODE}"
            else
                return
            fi
        fi

        style="${ARGPARSER_ERROR_STYLE}"
    elif [[ "${error_type}" == "warning" ]]; then
        if [[ "${ARGPARSER_SILENCE_WARNINGS}" == true ]]; then
            return
        fi

        style="${ARGPARSER_WARNING_STYLE}"
    fi

    # Colorize, sort, filter, and print all error or warning messages,
    # then exit, if requested.
    if (( "${#messages[@]}" > 0 )); then
        if [[ -t 2 ]]; then
            write_target="tty"
        else
            write_target="file"
        fi

        for i in "${!messages[@]}"; do
            messages[i]="$(argparser_colorize "${style}" "${messages[i]}" \
                "${write_target}")"
        done

        mapfile -d "" -t messages < <(argparser_sort false "${messages[@]}")

        if [[ "${filter}" == true ]]; then
            mapfile -d "" -t messages < <(argparser_uniq "${messages[@]}")
        fi

        printf '%s\n' "${messages[@]}" >&2

        if [[ "${exit}" == true ]]; then
            exit "${ARGPARSER_ERROR_EXIT_CODE}"
        fi
    fi
}

# Define the main argparser function.
function argparser_main() {
    # Parse the script's given arguments and check if they accord to
    # their definition.  Give proper error messages for wrongly set
    # arguments and assign the values to the respective variables.
    # Possibly, create and print a help message.
    #
    # Arguments:
    # - $@: the arguments to parse
    #
    # Globals:
    # - ${ARGPARSER_ARG_ARRAY_NAME}: the parsed and checked arguments
    #   with key and value as associative array
    #
    # Environment:
    # - ARGPARSER_ARG_ARRAY_NAME (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_CHECK_ARG_DEFINITION (read-only)
    # - ARGPARSER_ERROR_EXIT_CODE (read-only)
    # - ARGPARSER_SILENCE_ERRORS (read-only)

    # Define the local variables.  If the variable that
    # ${ARGPARSER_ARG_ARRAY_NAME} refers to is undefined, all variables
    # prefixed with "arg" are searched, later.  In order to not shadow
    # them by local variables, all locals starting with "arg" are
    # defined later.
    local -A all_arg_groups
    local -A all_arg_numbers
    local -A all_choice_values
    local -A all_default_values
    local -A all_help_texts
    local -A all_long_options
    local -A all_notes
    local -a all_positional_args
    local -A all_short_options
    local -A all_types
    local -A all_value_names
    local error_message
    local -a error_messages
    local given_arg
    local -a given_args
    local -a given_positional_args
    local -A help_message_groups
    local i
    local is_extglob_set
    local is_help
    local is_positional
    local is_positional_only
    local is_usage
    local is_version
    local message
    local -a messages
    local name
    local names
    local prefix
    local -A prefixes
    local translated_error
    local translated_warning
    local -A usage_message_groups
    local value
    local values
    local warning_message
    local -a warning_messages
    local write_target

    # Read the arguments.
    read -r -a given_args <<< "$@"

    # Locally disable errexit and enable extglob.  Since all functions
    # relying on the latter being set are called from argparser_main,
    # they inherit the option.
    local -
    set +o errexit
    is_extglob_set="$(shopt -p extglob)"
    shopt -s extglob

    # Check if the variable that ${ARGPARSER_ARG_ARRAY_NAME} refers to
    # is defined.  If not, guess how it may be called by searching the
    # set variables (not functions, hence the set POSIX mode) for a
    # variable name starting with "arg" to give a clearer error message.
    # If no such variable name is found, skip that part of the message.
    if [[ ! -v "${ARGPARSER_ARG_ARRAY_NAME}" ]]; then
        mapfile -t names <<< "$(set -o posix; set)"
        for name in "${names[@]}"; do
            if [[ "${name}" == "arg"* ]]; then
                name="${name%%=*}"
                break
            else
                name=""
            fi
        done

        if [[ -n "${name}" ]]; then
            error_message="Error: The variable ARGPARSER_ARG_ARRAY_NAME "
            error_message+="refers to \"%s\", but this variable is not "
            error_message+="defined.  Either you have given your arguments "
            error_message+="array another name (maybe \"%s\" -- then change "
            error_message+="ARGPARSER_ARG_ARRAY_NAME accordingly) or you "
            error_message+="forgot defining the array at all (then define it)."
            error_message="$(argparser_translate "Error arg array 1" \
                "${error_message}" "${ARGPARSER_ARG_ARRAY_NAME}" "${name}")"
        else
            error_message="Error: The variable ARGPARSER_ARG_ARRAY_NAME "
            error_message+="refers to \"%s\", but this variable is not "
            error_message+="defined.  Either you have given your arguments "
            error_message+="array another name (then change "
            error_message+="ARGPARSER_ARG_ARRAY_NAME accordingly) or you "
            error_message+="forgot defining the array at all (then define it)."
            error_message="$(argparser_translate "Error arg array 2" \
                "${error_message}" "${ARGPARSER_ARG_ARRAY_NAME}")"
        fi
        argparser_print_error_or_warning_message "error" false true \
            "${error_message}"
    fi

    # Define the remaining local variables that start with "arg".
    local arg
    local arg_key
    local -a args_definition_file
    local -a args_definition_script

    # Read in the requested arguments.  ${ARGPARSER_ARG_ARRAY_NAME} is
    # set to the name of the indexed array holding the arguments in the
    # script.  If it is already "args" (the default name), nothing needs
    # to be done, but other variable names need to be mapped to "args"
    # to be able to refer to the variable by name.  Thus, declare prints
    # the array contents stored in the variable
    # ${ARGPARSER_ARG_ARRAY_NAME} refers to, which then gets stripped
    # from the leading assignment (before the equals sign ("=")) and set
    # to the new indexed array ${args}.  Since later, the variable
    # ${ARGPARSER_ARG_ARRAY_NAME} refers to is assigned an associative
    # array, while being an indexed array, unset it.
    if [[ "${ARGPARSER_ARG_ARRAY_NAME}" != "args" ]]; then
        local args
        args="$(declare -p "${ARGPARSER_ARG_ARRAY_NAME}")"
        local -a args="${args#*=}"

        unset "${ARGPARSER_ARG_ARRAY_NAME}"
    fi

    # Read the arguments definition.
    args_definition_file=( )
    args_definition_script=( )
    error_messages=( )
    translated_error="$(argparser_translate "Error" "Error")"
    translated_warning="$(argparser_translate "Warning" "Warning")"

    mapfile -d "" -t messages < <(argparser_read_args_definition "${args[@]}")
    for message in "${messages[@]}"; do
        # Append the arguments definition to those for the file or
        # script, respectively.
        case "${message}" in
            File*) args_definition_file+=("${message#File: }") ;;
            Script*) args_definition_script+=("${message#Script: }") ;;
            ${translated_error}*)
                error_messages+=("${message}")
            ;;
        esac
    done

    # If there are error messages, colorize, sort, and print them, then
    # exit, as parsing the arguments definition with missing parts is
    # useless.
    argparser_print_error_or_warning_message "error" false true \
        "${error_messages[@]}"

    # Parse the arguments definition.
    all_positional_args=( )
    if (( "${#args_definition_file[@]}" > 0 )); then
        argparser_parse_args_definition "file" "${args_definition_file[@]}"
    fi
    if (( "${#args_definition_script[@]}" > 0 )); then
        argparser_parse_args_definition "script" "${args_definition_script[@]}"
    fi

    # If ${ARGPARSER_CHECK_ARG_DEFINITION} is set to true, check the
    # consistency of the arguments definition.
    error_messages=( )
    if [[ "${ARGPARSER_CHECK_ARG_DEFINITION}" == true ]]; then
        # Check the arguments definition, first the short and long
        # option names, then the default and choice values.
        mapfile -d "" -t error_messages \
            < <(argparser_check_args_definition_names)
        mapfile -d "" -t -O "${#error_messages[@]}" error_messages \
            < <(argparser_check_args_definition_positional_values)
        mapfile -d "" -t -O "${#error_messages[@]}" error_messages \
            < <(argparser_check_args_definition_option_values)

        # If there are error messages, colorize, sort, filter, and print
        # them, then exit, as parsing the arguments with a faulty
        # definition is useless or even impossible.
        argparser_print_error_or_warning_message "error" true true \
            "${error_messages[@]}"
    fi

    # Parse the script's given arguments.
    is_help=false
    is_usage=false
    is_version=false
    is_positional=true
    is_positional_only=false
    error_messages=( )

    unset args
    local -A args

    mapfile -d "" -t given_args < <(argparser_split_args "${given_args[@]}")
    for given_arg in "${given_args[@]}"; do
        # Parse the argument.
        mapfile -d "" -t messages < <(argparser_parse_arg "${given_arg}")

        # Read the output message and either set the help, usage, or
        # version message for printing and stop parsing, append the
        # message to the previous error messages or set the argument's
        # value or prefix. In case of arguments given multiple times,
        # i.e., when the key already exists in ${!args[@]}, add the new
        # value or prefix to the previously given ones.
        for message in "${messages[@]}"; do
            case "${message}" in
                Help)
                    is_help=true
                    break 2
                    ;;
                Usage)
                    is_usage=true
                    break 2
                    ;;
                Version)
                    is_version=true
                    break 2
                    ;;
                ${translated_error}*)
                    error_messages+=("${message}")
                    ;;
                Positional_Start)
                    # Set the flag that the positional-only arguments
                    # delimiter "--" has been set, such that all
                    # following arguments are interpreted as positional.
                    is_positional=true
                    is_positional_only=true
                    ;;
                Positional_End)
                    # Set the flag that the positional-only arguments
                    # delimiter "++" has been set (and thus "--" has
                    # been unset), such that all following arguments are
                    # interpreted as usual.
                    is_positional=true
                    is_positional_only=false
                    ;;
                Argument*)
                    # Set the current argument name.
                    is_positional=false
                    arg_key="${message#Argument: }"
                    ;;
                Prefix*)
                    # Set the current argument's prefix ("-" or "+").
                    prefix="${message#Prefix: }"
                    if [[ "$(argparser_in_array "${arg_key}" \
                        "${!prefixes[@]}")" == false ]]
                    then
                        prefixes[${arg_key}]="${prefix}"
                    else
                        prefixes[${arg_key}]+="${ARGPARSER_ARG_DELIMITER_2}"
                        prefixes[${arg_key}]+="${prefix}"
                    fi
                    ;;
                Value*)
                    # Set the current argument's value.
                    value="${message#Value: }"
                    if [[ "${is_positional}" == true ]]; then
                        given_positional_args+=("${value}")
                    elif [[ "$(argparser_in_array "${arg_key}" \
                        "${!args[@]}")" == false ]]
                    then
                        args[${arg_key}]="${value}"
                    else
                        args[${arg_key}]+="${ARGPARSER_ARG_DELIMITER_2}"
                        args[${arg_key}]+="${value}"
                    fi
                    ;;
            esac
        done
    done

    # If the help message was requested, print it.  If the usage message
    # was requested, but not the help message, print the usage message.
    # Finally, if only the version message was requested, print that.
    if [[ -t 1 ]]; then
        write_target="tty"
    else
        write_target="file"
    fi

    if [[ "${is_help}" == true ]]; then
        argparser_print_help_or_usage_message "help" true "${write_target}"
    elif [[ "${is_usage}" == true ]]; then
        argparser_print_help_or_usage_message "usage" true "${write_target}"
    elif [[ "${is_version}" == true ]]; then
        argparser_print_version_message true "${write_target}"
    fi

    # Parse the script's given positional arguments, that are yet only
    # assigned to a single indexed array.
    mapfile -d "" -t messages \
        < <(argparser_parse_positional_args "${given_positional_args[@]}")

    # Read the output message and either append the message to the
    # previous error messages or set the argument's value.  Again, in
    # case of arguments given multiple times, i.e., when the key already
    # exists in ${!args[@]}, add the new value to the previously given
    # ones.
    for message in "${messages[@]}"; do
        case "${message}" in
            ${translated_error}*) error_messages+=("${message}") ;;
            Argument*) arg_key="${message#Argument: }" ;;
            Value*)
                # Set the current argument's value.
                value="${message#Value: }"
                if [[ "$(argparser_in_array "${arg_key}" \
                    "${!args[@]}")" == false ]]
                then
                    args[${arg_key}]="${value}"
                else
                    args[${arg_key}]+="${ARGPARSER_ARG_DELIMITER_2}"
                    args[${arg_key}]+="${value}"
                fi
                ;;
        esac
    done

    # Colorize, sort, filter, and print all error messages.
    argparser_print_error_or_warning_message "error" true false \
        "${error_messages[@]}"

    # If any argument was not or wrongly given (i.e., there were
    # errors), print a blank line and the usage message and abort the
    # script.
    if (( "${#error_messages[@]}" > 0 )); then
        if [[ -t 2 ]]; then
            write_target="tty"
        else
            write_target="file"
        fi

        if [[ "${ARGPARSER_SILENCE_ERRORS}" == false ]]; then
            printf '\n' >&2
            argparser_print_help_or_usage_message "usage" false \
                "${write_target}" >&2
        fi
        exit "${ARGPARSER_ERROR_EXIT_CODE}"
    fi

    # Check the arguments' values.
    error_messages=( )
    warning_messages=( )
    for arg_key in "${!all_short_options[@]}" "${all_positional_args[@]}"; do
        # Check which defined argument is given to the script.  Omitted
        # arguments or those without value are assigned the empty string
        # as prefix and/or value. This is then interpreted as hint for
        # the argument's or value's absence.
        if [[ "$(argparser_in_array "${arg_key}" "${!prefixes[@]}")" == true ]]
        then
            prefix="${prefixes[${arg_key}]}"
        else
            prefix=""
        fi

        if [[ "$(argparser_in_array "${arg_key}" "${!args[@]}")" == true ]]
        then
            values="${args[${arg_key}]}"
        else
            values=""
        fi

        # Check each argument's value.
        mapfile -d "" -t messages < <(argparser_check_arg_values \
            "${arg_key}" "${prefix}" "${values}")

        # Read the output message and either append the message to the
        # previous error or warning messages or set the argument's
        # values.
        values=""
        for message in "${messages[@]}"; do
            case "${message}" in
                ${translated_error}*) error_messages+=("${message}") ;;
                ${translated_warning}*) warning_messages+=("${message}") ;;
                Value*) values="${message#Value: }" ;;
            esac
        done

        # Assign the checked values to the argument.
        args[${arg_key}]="${values}"
    done

    # Colorize, sort, filter, and print all error and warning messages.
    argparser_print_error_or_warning_message "error" true false \
        "${error_messages[@]}"
    argparser_print_error_or_warning_message "warning" true false \
        "${warning_messages[@]}"

    # If any argument was not or wrongly given (i.e., there were errors
    # and not just warnings), print a blank line and the usage message
    # and abort the script.
    if (( "${#error_messages[@]}" > 0 )); then
        if [[ -t 2 ]]; then
            write_target="tty"
        else
            write_target="file"
        fi

        if [[ "${ARGPARSER_SILENCE_ERRORS}" == false ]]; then
            printf '\n' >&2
            argparser_print_help_or_usage_message "usage" false \
                "${write_target}" >&2
        fi
        exit "${ARGPARSER_ERROR_EXIT_CODE}"
    fi

    # Copy the values of the associative array ${args} to the variable
    # ${ARGPARSER_ARG_ARRAY_NAME} refers to.  Thereby, declare prints
    # the array contents stored in ${args}, which then gets stripped
    # from the leading assignment (before the equals sign ("=")) and set
    # to the new associative array with the name of
    # ${ARGPARSER_ARG_ARRAY_NAME}.

    # shellcheck disable=SC2178  # Intentional string, not array.
    args="$(declare -p args)"
    declare -g -A "${ARGPARSER_ARG_ARRAY_NAME}"="${args#*=}"

    # Depending on the value of ${is_extglob_set}, which uses shopt's
    # feature of storing the extglob state in a format reusable as
    # input, possibly disable extglob.
    eval "${is_extglob_set}"
}

# If ${ARGPARSER_TRANSLATION_FILE} isn't set to the empty string, read
# the translation file.  To be able to use the localized name of
# ${ARGPARSER_POSITIONAL_ARG_GROUP} in the arguments definition and help
# message, translate it.
if [[ -n "${ARGPARSER_TRANSLATION_FILE}" ]]; then
    argparser_read_translation

    ARGPARSER_POSITIONAL_ARG_GROUP="$(argparser_translate \
        "Positional arguments" "${ARGPARSER_POSITIONAL_ARG_GROUP}")"
fi

# If ${ARGPARSER_CHECK_ENV_VARS} isn't set to false, check if the
# environment variables accord to their definition.  Since
# ${ARGPARSER_CHECK_ENV_VARS} is, as any other environment variable, yet
# unchecked, its value may be different from the expected "true" or
# "false".  Hence, testing for "not false" is not the exact opposite of
# testing for "true".  Even more, if ${ARGPARSER_CHECK_ENV_VARS} is
# different from "true" and "false", the test would be mandatory as it
# shows the environment variables have been wrongly set.
if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
    argparser_check_env_vars
fi

# If ${ARGPARSER_READ_ARGS} is set to true, read and parse the
# arguments.
if [[ "${ARGPARSER_READ_ARGS}" == true ]]; then
    argparser_main "$@"
fi

# If ${ARGPARSER_UNSET_ARGS} is set to true, disable all arguments given
# to the calling script, effectively unsetting the command line.
if [[ "${ARGPARSER_UNSET_ARGS}" == true ]]; then
    set --
fi

# If ${ARGPARSER_SET_ARGS} is set to true, set the arguments as
# variables to the current environment.
if [[ "${ARGPARSER_SET_ARGS}" == true ]]; then
    argparser_set_args
fi

# If ${ARGPARSER_UNSET_FUNCTIONS} is set to true, unset all argparser
# functions.  The names are used instead of a glob to limit side effects
# with potentially same-named functions from the calling script that
# stand in no relation to the argparser.
if [[ "${ARGPARSER_UNSET_FUNCTIONS}" == true ]]; then
    unset -f argparser_check_arg_values
    unset -f argparser_check_args_definition_names
    unset -f argparser_check_args_definition_option_values
    unset -f argparser_check_args_definition_positional_values
    unset -f argparser_check_color_or_style
    unset -f argparser_check_env_vars
    unset -f argparser_check_file
    unset -f argparser_colorize
    unset -f argparser_count
    unset -f argparser_create_help_message
    unset -f argparser_create_usage_message
    unset -f argparser_fold
    unset -f argparser_get_arg_key
    unset -f argparser_get_option_names
    unset -f argparser_in_array
    unset -f argparser_is_variable_bool
    unset -f argparser_is_variable_char
    unset -f argparser_is_variable_identifier
    unset -f argparser_is_variable_int
    unset -f argparser_is_variable_uint
    unset -f argparser_main
    unset -f argparser_parse_arg
    unset -f argparser_parse_args_definition
    unset -f argparser_parse_long_option
    unset -f argparser_parse_positional_args
    unset -f argparser_parse_short_option
    unset -f argparser_print_error_or_warning_message
    unset -f argparser_print_help_or_usage_message
    unset -f argparser_print_version_message
    unset -f argparser_quicksort
    unset -f argparser_read_args_definition
    unset -f argparser_read_translation
    unset -f argparser_sort
    unset -f argparser_split_args
    unset -f argparser_translate
    unset -f argparser_trim
    unset -f argparser_uniq
fi

# If ${ARGPARSER_UNSET_ENV_VARS} is set to true, unset all argparser
# environment variables.  Again, the names are used instead of a glob to
# limit side effects with potentially same-named variables from the
# calling script that stand in no relation to the argparser.
if [[ "${ARGPARSER_UNSET_ENV_VARS}" == true ]]; then
    unset ARGPARSER_ADD_HELP
    unset ARGPARSER_ADD_USAGE
    unset ARGPARSER_ADD_VERSION
    unset ARGPARSER_ALLOW_OPTION_ABBREVIATION
    unset ARGPARSER_ALLOW_OPTION_MERGING
    unset ARGPARSER_ARG_ARRAY_NAME
    unset ARGPARSER_ARG_DEF_FILE
    unset ARGPARSER_ARG_DEF_FILE_HAS_HEADER
    unset ARGPARSER_ARG_DEF_HAS_HEADER
    unset ARGPARSER_ARG_DELIMITER_1
    unset ARGPARSER_ARG_DELIMITER_2
    unset ARGPARSER_CHECK_ARG_DEFINITION
    unset ARGPARSER_CHECK_ENV_VARS
    unset ARGPARSER_COUNT_FLAGS
    unset ARGPARSER_DICTIONARY
    unset ARGPARSER_ERROR_EXIT_CODE
    unset ARGPARSER_ERROR_STYLE
    unset ARGPARSER_HELP_EXIT_CODE
    unset ARGPARSER_HELP_FILE
    unset ARGPARSER_HELP_FILE_INCLUDE_CHAR
    unset ARGPARSER_HELP_FILE_KEEP_COMMENTS
    unset ARGPARSER_HELP_STYLE
    unset ARGPARSER_LANGUAGE
    unset ARGPARSER_MAX_COL_WIDTH_1
    unset ARGPARSER_MAX_COL_WIDTH_2
    unset ARGPARSER_MAX_COL_WIDTH_3
    unset ARGPARSER_POSITIONAL_ARG_GROUP
    unset ARGPARSER_READ_ARGS
    unset ARGPARSER_SCRIPT_NAME
    unset ARGPARSER_SET_ARGS
    unset ARGPARSER_SET_ARRAYS
    unset ARGPARSER_SILENCE_ERRORS
    unset ARGPARSER_SILENCE_WARNINGS
    unset ARGPARSER_TRANSLATION_FILE
    unset ARGPARSER_UNSET_ARGS
    unset ARGPARSER_UNSET_ENV_VARS
    unset ARGPARSER_UNSET_FUNCTIONS
    unset ARGPARSER_USAGE_EXIT_CODE
    unset ARGPARSER_USAGE_FILE
    unset ARGPARSER_USAGE_FILE_INCLUDE_CHAR
    unset ARGPARSER_USAGE_FILE_KEEP_COMMENTS
    unset ARGPARSER_USAGE_MESSAGE_OPTION_TYPE
    unset ARGPARSER_USAGE_MESSAGE_ORIENTATION
    unset ARGPARSER_USAGE_STYLE
    unset ARGPARSER_USE_STYLES_IN_FILES
    unset ARGPARSER_VERSION
    unset ARGPARSER_VERSION_EXIT_CODE
    unset ARGPARSER_VERSION_STYLE
    unset ARGPARSER_WARNING_STYLE
fi
