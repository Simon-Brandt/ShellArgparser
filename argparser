#!/bin/bash

# Author: Simon Brandt
# E-Mail: simon.brandt@uni-greifswald.de
# Last Modification: 2025-01-15

# TODO: Enable parsing of combined short option flags, i.e.
#       script.sh -ab instead of script.sh -a -b.
# TODO: Allow counting of flags, e.g., for -vv as doubled -v.
# TODO: Add type checking for arguments.
# TODO: Add support for names for keyword and positional arguments in
#       help messages.
# TODO: Add support for abbreviated long options, e.g., --verb for
#       --verbose, if no collision with e.g., --verbatim arises.
# TODO: Add ability to mark options as deprecated.
# TODO: Add support for a header in arguments defintion files to allow
#       changing their order.
# TODO: Add support for a specific number of positional arguments.

# Usage: Source this script with "source argparser" inside the script
# whose arguments need to be parsed.  If ${ARGPARSER_READ_ARGS} is set
# to true (the default), the arguments will be parsed upon sourcing.  If
# ${ARGPARSER_SET_ARGS} is set to true (the default), the arguments will
# be set to variables upon sourcing, else, the associative array ${args}
# needs to be accessed.  Refer to the README.md for details.

# Purpose: Parse a script's arguments, giving proper error messages for
# wrongly set arguments, assigning the values to the respective
# variables, as well as creating and printing a help message.  Refer to
# the README.md for details.

########################################################################

# Set the argparser environment variables, as long as they aren't
# already set by the calling script or environment (to prevent
# overriding them).  The no-op command ":" is used for its side effect
# to set the variables, if unset or null, as part of the parameter
# expansion.
if (( "$#" >= 2 )) && [[ "$2" == "--" ]]; then
    case "$1" in
        "--read")
            ARGPARSER_READ_ARGS=true
            ARGPARSER_SET_ARGS=false
            ;;
        "--set")
            ARGPARSER_READ_ARGS=false
            ARGPARSER_SET_ARGS=true
            ;;
        "--all")
            ARGPARSER_READ_ARGS=true
            ARGPARSER_SET_ARGS=true
            ;;
        *)
            printf 'Wrong action given: %s\n' "$1"
            exit 1
            ;;
    esac
    shift 2  # Get rid of the action specification.
fi
: "${ARGPARSER_ARG_ARRAY_NAME:="args"}"
: "${ARGPARSER_ARG_DEF_FILE:=""}"
: "${ARGPARSER_ARG_DEF_FILE_HAS_HEADER:=false}"
: "${ARGPARSER_ARG_DELIMITER_1:=":"}"
: "${ARGPARSER_ARG_DELIMITER_2:=","}"
: "${ARGPARSER_CHECK_ARG_DEFINITION:=false}"
: "${ARGPARSER_CHECK_ENV_VARS:=false}"
: "${ARGPARSER_ERROR_EXIT_CODE:=1}"
: "${ARGPARSER_ERROR_STYLE:="red,bold,reverse"}"
: "${ARGPARSER_HELP_EXIT_CODE:=0}"
: "${ARGPARSER_HELP_FILE:=""}"
: "${ARGPARSER_HELP_FILE_INCLUDE_CHAR:="@"}"
: "${ARGPARSER_HELP_FILE_KEEP_COMMENTS:=false}"
: "${ARGPARSER_HELP_STYLE:="italic"}"
: "${ARGPARSER_LANGUAGE:="en"}"
: "${ARGPARSER_MAX_COL_WIDTH_1:=5}"
: "${ARGPARSER_MAX_COL_WIDTH_2:=33}"
: "${ARGPARSER_MAX_COL_WIDTH_3:=39}"
: "${ARGPARSER_POSITIONAL_NAME:="positional"}"
: "${ARGPARSER_READ_ARGS:=true}"
: "${ARGPARSER_SCRIPT_NAME:="${0##*/}"}"
: "${ARGPARSER_SET_ARGS:=true}"
: "${ARGPARSER_SET_ARRAYS:=true}"
: "${ARGPARSER_TRANSLATION_FILE:=""}"
: "${ARGPARSER_UNSET_ARGS:=true}"
: "${ARGPARSER_UNSET_ENV_VARS:=true}"
: "${ARGPARSER_UNSET_FUNCTIONS:=true}"
: "${ARGPARSER_USAGE_EXIT_CODE:=0}"
: "${ARGPARSER_USAGE_FILE:=""}"
: "${ARGPARSER_USAGE_FILE_INCLUDE_CHAR:="@"}"
: "${ARGPARSER_USAGE_FILE_KEEP_COMMENTS:=false}"
: "${ARGPARSER_USAGE_STYLE:="italic"}"
: "${ARGPARSER_WARNING_STYLE:="red,bold"}"

# Define the argparser functions used for general tests.
function argparser_in_array() {
    # Check if an element occurs in an array.
    #
    # Arguments:
    # - $1: the element to search for
    # - $@: the array to search through
    #
    # Output:
    # - true, if the element exists in the array
    # - false, else

    # Define the local variables.
    local element
    local query

    # Read the query element and shift the arguments such that only the
    # array to search through remains.
    query="$1"
    shift

    # Iterate through the array and compare each element to the query.
    # Output 0 on success, else 1.
    for element in "$@"; do
        if [[ "${element}" == "${query}" ]]; then
            printf true
            return
        fi
    done

    printf false
}

function argparser_is_variable_boolean() {
    # Check if a variable's value is a boolean.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Output:
    # - true, if the variable's value is a boolean
    # - false, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == true || "${var}" == false ]]; then
        printf true
    else
        printf false
    fi
}

function argparser_is_variable_character() {
    # Check if a variable's value is a (printable) character.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Output:
    # - true, if the variable's value is a character
    # - false, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == [[:print:]] ]]; then
        printf true
    else
        printf false
    fi
}

function argparser_is_variable_identifier() {
    # Check if a variable's value is usable as Bash variable identifier.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Output:
    # - true, if the variable's value is usable as identifer
    # - false, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == [[:alpha:]_]+([[:word:]]) ]]; then
        printf true
    else
        printf false
    fi
}

function argparser_is_variable_integer() {
    # Check if a variable's value is an integer.
    #
    # Arguments:
    # - $1: the variable whose value to check
    #
    # Output:
    # - true, if the variable's value is an integer
    # - false, else

    # Define the local variable.
    local var

    # Read the argument.
    var="$1"

    # Check the variable's value.
    if [[ "${var}" == ?([+-])+([[:digit:]]) ]]; then
        printf true
    else
        printf false
    fi
}

# Define the general argparser util functions.
function argparser_fold() {
    # Limit the width of a help message's column to max_col_width by
    # inserting line breaks.
    #
    # Arguments:
    # - $1: the line in the column in which to insert line breaks
    # - $2: the maximum width a column may have
    # - $3: the maximum width a column has yet
    #
    # Output:
    # - the line with introduced line breaks and the width of the widest
    #   line part as null-character-separated string

    # Define the local variables.
    local col_width
    local joined_words
    local largest_col_width
    local len_joined_words
    local len_word
    local line
    local max_col_width
    local word
    local words

    # Read the arguments.
    line="$1"
    max_col_width="$2"
    largest_col_width="$3"

    # Split the column element word by word (on whitespace), such that
    # line breaks aren't inserted into entire words.
    joined_words=""
    col_width=0
    read -a words <<< "${line}"

    for word in "${words[@]}"; do
        len_word="${#word}"
        len_joined_words="${#joined_words}"
        if (( len_word > max_col_width && len_joined_words == 0 )); then
            # As the word is too long, print the word and introduce a
            # line break.  Then, reset the column width.
            joined_words+="$(printf '%s\n' "${word}")"
            col_width=0
        elif (( col_width + len_word > max_col_width )); then
            # As the line with the word appended would be too long,
            # introduce a line break and print the word.  Then, set the
            # column width.
            joined_words+="$(printf '\n%s' "${word}")"
            col_width="${len_word}"
        elif (( len_joined_words == 0 )); then
            # For the first word, add the word only.  Increase the
            # column width by the word's length.
            joined_words="${word}"
            (( col_width += len_word ))
        else
            # For any other word, add the word and a leading space
            # character, else, the words would be concatenated without
            # separation (the splitting removed any whitespace).
            # Increase the column width appropriately.
            joined_words+=" ${word}"
            (( col_width += len_word + 1 ))
        fi

        # If the current line is wider than the previous ones, set the
        # largest_col_width correspondingly.  Later, this value is used
        # to determine the amount of whitespace between the columns'
        # elements.
        if (( col_width > largest_col_width )); then
            largest_col_width="${col_width}"
        fi
    done

    printf '%s\0' "${joined_words}" "${largest_col_width}"
}

function argparser_count() {
    # Count the number of occurences of an element in an array.
    #
    # Arguments:
    # - $1: the element to count
    # - $@: the array where to count the element
    #
    # Output:
    # - the count of the element

    # Define the local variables.
    local count
    local element
    local query

    # Read the query element and shift the arguments such that only the
    # array to search through remains.
    query="$1"
    shift

    # Count the number of occurences.
    count=0
    for element in "$@"; do
        if [[ "${element}" == "${query}" ]]; then
            (( count++ ))
        fi
    done
    printf '%s' "${count}"
}

function argparser_uniq() {
    # Filter adjacent duplicate entries from an array.
    #
    # Arguments:
    # - $@: the array to filter
    #
    # Output:
    # - the filtered array as string concatenated with null characters

    # Define the local variables.
    local array
    local element
    local prev_element

    # Read the arguments.
    array=("$@")

    # Filter the array and output it.
    prev_element=""
    for element in "${array[@]}"; do
        if [[ "${element}" != "${prev_element}" ]]; then
            printf '%s\0' "${element}"
        fi
        prev_element="${element}"
    done
}

function argparser_quicksort() {
    # Sort an array using the recursive Quicksort algorithm with Tony
    # Hoare's partition scheme.
    #
    # Arguments:
    # - $1: the left boundary of the array bucket
    # - $2: the right boundary of the array bucket
    #
    # Nonlocals:
    # - array: the array to sort

    # Define the local variables.
    local i
    local j
    local left
    local pivot
    local pivot_point
    local right
    local swap

    # Read the arguments.
    left="$1"
    right="$2"

    # Sort the array by Quicksort.
    if (( left < right )); then
        # Set the start indices for the current bucket.  Take the
        # leftmost element as pivot.
        (( i = "${left}" - 1 ))
        (( j = "${right}" + 1 ))
        pivot="${array[left]}"

        while :; do
            # Traverse the array from the left, until a larger element
            # than the pivot has been found.
            (( i++ ))
            while [[ "${array[i]}" < "${pivot}" ]]; do
                (( i++ ))
            done

            # Traverse the array from the right, until a smaller element
            # than the pivot has been found.
            (( j-- ))
            while [[ "${array[j]}" > "${pivot}" ]]; do
                (( j-- ))
            done

            # If the indices have crossed each other, return.
            if (( i >= j )); then
                pivot_point="${j}"
                break
            fi

            # Swap the elements at the current indices.
            swap="${array[i]}"
            array[i]="${array[j]}"
            array[j]="${swap}"
        done

        # Recursively call the Quicksort algorithm to sort the buckets
        # individually.
        argparser_quicksort "${left}" "${pivot_point}"
        argparser_quicksort "$(( pivot_point + 1 ))" "${right}"
    fi
}

function argparser_sort() {
    # Sort an array, internally using the Quicksort algorithm.
    #
    # Arguments:
    # - $1: whether to reverse-sort the array
    # - $@: the array to sort
    #
    # Output:
    # - the sorted array as string concatenated with null characters

    # Define the local variables.
    local array
    local i
    local reverse

    # Read the arguments.
    reverse="$1"
    shift
    array=("$@")

    # Sort the array and output it, possibly after reversing it.
    argparser_quicksort 0 "$(( "${#array[@]}" - 1 ))"
    if [[ "${reverse}" == true ]]; then
        for (( i = "${#array[@]}" - 1; i >= 0; i-- )); do
            printf '%s\0' "${array[i]}"
        done
    else
        printf '%s\0' "${array[@]}"
    fi
}

function argparser_colorize() {
    # Colorize and format the string using ANSI escape sequences.
    #
    # Arguments:
    # - $1: the colors and/or styles to use as comma-separated list
    # - $2: the string to colorize
    #
    # Output:
    # - the colorized string

    # Define the local variables.
    local color
    local -A colors
    local request
    local requests
    local string
    local style
    local -A styles

    # Read the arguments.
    requests="$1"
    string="$2"

    # Define the associative arrays with colors or styles, respectively,
    # and their corresponding Select Graphic Rendition (SGR) ANSI escape
    # sequence codes.
    colors=(
        [black]=30
        [red]=31
        [green]=32
        [yellow]=33
        [blue]=34
        [magenta]=35
        [cyan]=36
        [white]=37
    )

    styles=(
        [normal]=22
        [bold]=1
        [faint]=2
        [italic]=3
        [underline]=4
        [double]=21
        [overline]=53
        [crossed-out]=9
        [blink]=5
        [reverse]=7
    )

    # Split the requested color and/or style on commas and print any.
    # Then, print the string and reset the color and style.
    IFS="," read -a requests <<< "${requests}"
    for request in "${requests[@]}"; do
        if [[ "$(argparser_in_array "${request}" "${!colors[@]}")" == true ]]
        then
            printf '\e[%sm' "${colors[${request}]}"
        elif [[ "$(argparser_in_array "${request}" "${!styles[@]}")" == true ]]
        then
            printf '\e[%sm' "${styles[${request}]}"
        fi
    done

    printf '%s\e[0m' "${string}"
}

# Define the argparser functions for checking the environment variables
# and the arguments definition.
function argparser_check_color_or_style() {
    # Check if the specified colors and/or styles are implemented for
    # argparser_colorize.
    #
    # Arguments:
    # - $1: the colors and/or styles to use as comma-separated list
    #
    # Output:
    # - true, if all colors and/or styles are implemented
    # - false, else

    # Define the local variables.
    local color
    local -a colors
    local request
    local requests
    local style
    local -a styles

    # Read the argument.
    requests="$1"

    # Define the arrays of implemented colors and styles.
    colors=(
        black
        red
        green
        yellow
        blue
        magenta
        cyan
        white
    )

    styles=(
        normal
        bold
        faint
        italic
        underline
        double
        overline
        crossed-out
        blink
        reverse
    )

    # Split the requested color and/or style on commas and print any.
    # Then, print the string and reset the color and style.  If a
    # non-existing color or style is requested, abort the script with
    # an error message.
    IFS="," read -a requests <<< "${requests}"
    for request in "${requests[@]}"; do
        if [[ "$(argparser_in_array "${request}" "${colors[@]}")" == false \
            && "$(argparser_in_array "${request}" "${styles[@]}")" == false ]]
        then
            printf false
            return
        fi
    done

    printf true
}

function argparser_check_file() {
    # Check if a file exists, is a regular file, is readable, and has a
    # size greater than 0 bytes.
    #
    # Arguments:
    # - $1: the file to check
    #
    # Output:
    # - a bit mask with four bits set to 0 (true) if the file exists
    #   (first bit), is a regular file (second bit), is readable (third
    #   bit), and/or has a size greater than 0 bytes (fourth bit), else
    #   set to 1 (false)

    # Define the local variable.
    local file

    # Read the argument.
    file="$1"

    # Check the variable's value.
    if [[ -e "${file}" ]]; then
        printf 0
    else
        printf 1
    fi

    if [[ -f "${file}" ]]; then
        printf 0
    else
        printf 1
    fi

    if [[ -r "${file}" ]]; then
        printf 0
    else
        printf 1
    fi

    if [[ -s "${file}" ]]; then
        printf 0
    else
        printf 1
    fi
}

function argparser_check_env_vars() {
    # Check if the argparser envirnoment variables accord to their
    # definition.  This should always be true for production scripts,
    # but maybe not while testing, and also not if the user is allowed
    # to set the variables himself.
    #
    # The following environment variables are unchecked:
    # - ARGPARSER_SCRIPT_NAME
    #
    # Environment:
    # - ARGPARSER_ARG_ARRAY_NAME (read-only)
    # - ARGPARSER_ARG_DEF_FILE (read-only)
    # - ARGPARSER_ARG_DEF_FILE_HAS_HEADER (read-only)
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_CHECK_ARG_DEFINITION (read-only)
    # - ARGPARSER_CHECK_ENV_VARS (read-only)
    # - ARGPARSER_ERROR_EXIT_CODE
    # - ARGPARSER_ERROR_STYLE
    # - ARGPARSER_HELP_EXIT_CODE (read-only)
    # - ARGPARSER_HELP_FILE (read-only)
    # - ARGPARSER_HELP_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_HELP_FILE_KEEP_COMMENTS (read-only)
    # - ARGPARSER_HELP_STYLE (read-only)
    # - ARGPARSER_LANGUAGE (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_1 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_2 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_3 (read-only)
    # - ARGPARSER_POSITIONAL_NAME (read-only)
    # - ARGPARSER_READ_ARGS (read-only)
    # - ARGPARSER_SET_ARGS (read-only)
    # - ARGPARSER_SET_ARRAYS (read-only)
    # - ARGPARSER_TRANSLATION_FILE (read-only)
    # - ARGPARSER_UNSET_ARGS (read-only)
    # - ARGPARSER_UNSET_ENV_VARS (read-only)
    # - ARGPARSER_UNSET_FUNCTIONS (read-only)
    # - ARGPARSER_USAGE_EXIT_CODE (read-only)
    # - ARGPARSER_USAGE_FILE (read-only)
    # - ARGPARSER_USAGE_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_USAGE_FILE_KEEP_COMMENTS (read-only)
    # - ARGPARSER_USAGE_STYLE (read-only)
    # - ARGPARSER_WARNING_STYLE (read-only)

    # Define the local variables.
    local attributes
    local error_message
    local -a error_messages
    local i
    local var
    local var_1
    local var_2
    local -a vars

    # Check if all environment variables expected to be booleans are
    # true or false.  Else, output an error message.
    error_messages=( )
    vars=(
        ARGPARSER_ARG_DEF_FILE_HAS_HEADER
        ARGPARSER_CHECK_ARG_DEFINITION
        ARGPARSER_CHECK_ENV_VARS
        ARGPARSER_HELP_FILE_KEEP_COMMENTS
        ARGPARSER_READ_ARGS
        ARGPARSER_SET_ARGS
        ARGPARSER_SET_ARRAYS
        ARGPARSER_UNSET_ARGS
        ARGPARSER_UNSET_ENV_VARS
        ARGPARSER_UNSET_FUNCTIONS
        ARGPARSER_USAGE_FILE_KEEP_COMMENTS
    )
    for var in "${vars[@]}"; do
        if [[ "$(argparser_is_variable_boolean "${!var}")" == false ]]; then
            error_message="Error: The environment variable \"${var}\" is "
            error_message+="set to \"${!var}\", but must be a boolean, i.e., "
            error_message+="true or false."
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables expected to be characters are
    # one-character strings.  Else, output an error message.
    vars=(
        ARGPARSER_ARG_DELIMITER_1
        ARGPARSER_ARG_DELIMITER_2
        ARGPARSER_HELP_FILE_INCLUDE_CHAR
        ARGPARSER_USAGE_FILE_INCLUDE_CHAR
    )
    for var in "${vars[@]}"; do
        if [[ "$(argparser_is_variable_character "${!var}")" == false ]]; then
            error_message="Error: The environment variable \"${var}\" is "
            error_message+="set to \"${!var}\", but must be a character, "
            error_message+="i.e., a string comprising one printable ASCII "
            error_message+="character."
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables to be used as Bash variable
    # identifiers start with a letter or underscore and contain only
    # letters, digits, and underscores.  Else, output an error message.
    vars=(
        ARGPARSER_ARG_ARRAY_NAME
        ARGPARSER_POSITIONAL_NAME
    )
    for var in "${vars[@]}"; do
        if [[ "$(argparser_is_variable_identifier "${!var}")" == false ]]; then
            error_message="Error: The environment variable \"${var}\" is "
            error_message+="set to \"${!var}\", but is designed to be used as "
            error_message+="Bash variable identifier, i.e., must start with a "
            error_message+="letter or underscore and contain only letters, "
            error_message+="digits, and underscores."
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables expected to be integers are
    # only digits, possibly with a leading sign.  Else, output an error
    # message.
    vars=(
        ARGPARSER_ERROR_EXIT_CODE
        ARGPARSER_HELP_EXIT_CODE
        ARGPARSER_MAX_COL_WIDTH_1
        ARGPARSER_MAX_COL_WIDTH_2
        ARGPARSER_MAX_COL_WIDTH_3
        ARGPARSER_USAGE_EXIT_CODE
    )
    for var in "${vars[@]}"; do
        if [[ "$(argparser_is_variable_integer "${!var}")" == false ]]; then
            error_message="Error: The environment variable \"${var}\" is "
            error_message+="set to \"${!var}\", but must be an integer, i.e., "
            error_message+="comprise only digits and possibly a leading sign."
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables expected to point to files has
    # the referenced file existing, readable, and with a size greater
    # than 0 bytes.  Else, output an error message.
    vars=(
        ARGPARSER_ARG_DEF_FILE
        ARGPARSER_HELP_FILE
        ARGPARSER_TRANSLATION_FILE
        ARGPARSER_USAGE_FILE
    )
    for var in "${vars[@]}"; do
        attributes="$(argparser_check_file "${!var}")"
        if [[ -n "${!var}" && "${attributes}" != 0000 ]]
        then
            error_message="Error: The environment variable \"${var}\" is set "
            error_message+="to \"${!var}\", but the referenced file "
            case "${attributes}" in
                0001) error_message+="is empty." ;;
                0010) error_message+="is not readable." ;;
                0011) error_message+="is not readable and empty." ;;
                0100) error_message+="is not a regular file." ;;
                0101) error_message+="is not a regular file and empty." ;;
                0110)
                    error_message+="is not a regular file and not readable."
                    ;;
                0111)
                    error_message+="is not a regular file, not readable and "
                    error_message+="empty."
                    ;;
                1*) error_message+="does not exist." ;;
            esac
            error_messages+=("${error_message}")
        fi
    done

    # Check if all environment variables for styles only have values
    # supported by argparser_colorize.  Else, output an error message.
    vars=(
        ARGPARSER_ERROR_STYLE
        ARGPARSER_HELP_STYLE
        ARGPARSER_USAGE_STYLE
        ARGPARSER_WARNING_STYLE
    )
    for var in "${vars[@]}"; do
        if [[ "$(argparser_check_color_or_style "${!var}")" == false ]]; then
            error_message="Error: The environment variable \"${var}\" is "
            error_message+="set to \"${!var}\", but the comma-separated "
            error_message+="values must lie in {black,red,green,yellow,blue,"
            error_message+="magenta,cyan,white} for colors and in {normal,"
            error_message+="bold,faint,italic,underline,double,overline,"
            error_message+="crossed-out,blink,reverse} for styles."
            error_messages+=("${error_message}")
        fi
    done

    # Check the environment variables with mutually exclusive values.
    # First, check that the argument definition delimiters are
    # different.
    if [[ "${ARGPARSER_ARG_DELIMITER_1}" == "${ARGPARSER_ARG_DELIMITER_2}" ]]
    then
        error_message="Error: The environment variables "
        error_message+="\"ARGPARSER_ARG_DELIMITER_1\" and "
        error_message+="\"ARGPARSER_ARG_DELIMITER_2\" must be different."
        error_messages+=("${error_message}")
    fi

    # Then, check that the language identifier is different from the
    # delimiter in the translation file.
    if [[ "${ARGPARSER_LANGUAGE}" == "${ARGPARSER_ARG_DELIMITER_1}" ]]; then
        error_message="Error: The environment variables "
        error_message+="\"ARGPARSER_LANGUAGE\" and "
        error_message+="\"ARGPARSER_ARG_DELIMITER_1\" must be different."
        error_messages+=("${error_message}")
    fi

    # Then, check that the variable names for the argument array and the
    # positional arguments are different.
    if [[ "${ARGPARSER_ARG_ARRAY_NAME}" == "${ARGPARSER_POSITIONAL_NAME}" ]]
    then
        error_message="Error: The environment variables "
        error_message+="\"ARGPARSER_ARG_ARRAY_NAME\" and "
        error_message+="\"ARGPARSER_POSITIONAL_NAME\" must be different."
        error_messages+=("${error_message}")
    fi

    # Then, check that the arguments definition file, the help file, the
    # translation file, and the usage file are different from each
    # other, if given.
    vars=(
        ARGPARSER_ARG_DEF_FILE
        ARGPARSER_HELP_FILE
        ARGPARSER_TRANSLATION_FILE
        ARGPARSER_USAGE_FILE
    )
    for i in "${!vars[@]}"; do
        var_1="${vars[i]}"
        for var_2 in "${vars[@]:$((i + 1))}"; do
            if [[ -n "${!var_1}" && "${!var_1}" == "${!var_2}" ]]; then
                error_message="Error: The environment variables \"${var_1}\" "
                error_message+="and \"${var_2}\" point to the same file."
                error_messages+=("${error_message}")
            fi
        done
    done

    # If there are error messages, colorize, sort, and print them, then
    # exit, as parsing the arguments with a faulty environment variable
    # configuration might be impossible.  If ${ARGPARSER_ERROR_STYLE} is
    # among the faulty variables, the error messages cannot be properly
    # colorized.  Thus, set the style to its default value.  The same
    # holds true for ${ARGPARSER_ERROR_EXIT_CODE}.
    if (( "${#error_messages[@]}" > 0 )); then
        # Possibly, set the ${ARGPARSER_ERROR_STYLE} to its default
        # value.
        for error_message in "${error_messages[@]}"; do
            if [[ "${error_messages}" == *"ARGPARSER_ERROR_STYLE"* ]]; then
                ARGPARSER_ERROR_STYLE="red,bold,reverse"
            elif [[ "${error_messages}" == *"ARGPARSER_ERROR_EXIT_CODE"* ]]
            then
                ARGPARSER_ERROR_EXIT_CODE=1
            fi
        done

        # Colorize, sort, and print the error messages.
        for i in "${!error_messages[@]}"; do
            error_messages[i]="$(argparser_colorize \
                "${ARGPARSER_ERROR_STYLE}" "${error_messages[i]}")"
        done

        mapfile -d "" -t error_messages \
            < <(argparser_sort false "${error_messages[@]}")
        printf '%s\n' "${error_messages[@]}" >&2
        exit "${ARGPARSER_ERROR_EXIT_CODE}"
    fi
}

function argparser_check_arg_definition_names() {
    # Check if the script's arguments' definition is consistent
    # regarding the short and long option names.  This should always be
    # true for production scripts, but maybe not while testing.
    #
    # Nonlocals:
    # - args_definition: the arguments definition (read-only)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    #
    # Output:
    # - the error messages, starting with "Error: ", possibly
    #   concatenated with null characters

    # Define the local variables.
    local -A all_long_options
    local -A all_short_options
    local -a arg_definition
    local arg_key
    local -a arg_keys
    local count
    local error_message
    local long_option
    local -a long_options
    local short_option
    local -a short_options

    # Get and sort all argument keys (identifiers), such that the
    # following loop is performed in alphabetical order of the
    # arguments, such that the error messages for duplicate option names
    # refer to the lexicographically earlier argument.
    mapfile -d "" -t arg_keys \
        < <(argparser_sort false "${!args_definition[@]}")

    # Check that no short or long option is given twice for the same
    # argument or among multiples.
    for arg_key in "${arg_keys[@]}"; do
        # Read the argument's definition.
        IFS="${ARGPARSER_ARG_DELIMITER_1}" read -a arg_definition \
            <<< "${args_definition[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a short_options \
            <<< "${arg_definition[0]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a long_options \
            <<< "${arg_definition[1]}"

        # If more than one short option name is given, check if any is a
        # hyphen, which must only once be used as placeholder for
        # missing short options.  Then, check if any short option name
        # is given multiple times in the current argument's definition
        # or accross all yet investigated arguments' definitions.  If
        # only one short option name is given, there can be no
        # duplicates for this argument and the hyphen is a legit value,
        # so check only for identical short option names in other
        # arguments' definitions.
        if (( "${#short_options[@]}" > 1 )); then
            # If a hyphen is included in the short option names, output
            # an error message .
            if [[ "$(argparser_in_array "-" "${short_options[@]}")" == true ]]
            then
                error_message="Error: The argument with the identifier "
                error_message+="\"${arg_key}\" has a placeholder \"-\" given "
                error_message+="as one of the ${#short_options[@]} short "
                error_message+="option names, instead of a legit name."
                printf '%s\0' "${error_message}"
            fi

            # Check how often a short option name is given.  If it was
            # given multiple times, output an error message.
            for short_option in "${short_options[@]}"; do
                if [[ "${short_option}" != "-" ]]; then
                    # Check if the short option name is given multiple
                    # times in the current argument's definition.
                    count="$(argparser_count "${short_option}" \
                        "${short_options[@]}")"
                    if (( count > 1 )); then
                        error_message="Error: The argument with the "
                        error_message+="identifier \"${arg_key}\" has the "
                        error_message+="short option \"${short_option}\" "
                        error_message+="given ${count} times."
                        printf '%s\0' "${error_message}"
                    fi

                    # Check if the short option name is already given in
                    # another argument's definition.
                    if [[ "$(argparser_in_array "${short_option}" \
                        "${!all_short_options[@]}")" == true \
                        && "${all_short_options[${short_option}]}" != \
                        "${arg_key}" ]]
                    then
                        error_message="Error: The argument with the "
                        error_message+="identifier \"${arg_key}\" has the "
                        error_message+="short option \"${short_option}\" "
                        error_message+="given, but that is already in use by "
                        error_message+="${all_short_options[${short_option}]}."
                        printf '%s\0' "${error_message}"
                    fi

                    # Add the short option name to the associative array
                    # of all short option names.
                    all_short_options[${short_option}]="${arg_key}"
                fi
            done
        else
            short_option="${short_options[0]}"
            if [[ "${short_option}" != "-" ]]; then
                # Check if the short option name is already given in
                # another argument's definition.
                if [[ "$(argparser_in_array "${short_option}" \
                    "${!all_short_options[@]}")" == true ]]
                then
                    error_message="Error: The argument with the identifier "
                    error_message+="\"${arg_key}\" has the short option "
                    error_message+="\"${short_option}\" given, but that is "
                    error_message+="already in use by "
                    error_message+="${all_short_options[${short_option}]}."
                    printf '%s\0' "${error_message}"
                fi

                # Add the short option name to the associative array of
                # all short option names.
                all_short_options[${short_option}]="${arg_key}"
            fi
        fi

        # Perform the same tests for the long option names for having a
        # hyphen among the long option names or if any long option name
        # is given multiple times in the current argument's definition
        # or accross all yet investigated arguments' definitions.
        # Again, if only one long option name is given, check only for
        # identical long option names in other arguments' definitions.
        if (( "${#long_options[@]}" > 1 )); then
            # If a hyphen is included in the long option names, output
            # an error message .
            if [[ "$(argparser_in_array "-" "${long_options[@]}")" == true ]]
            then
                error_message="Error: The argument with the identifier "
                error_message+="\"${arg_key}\" has a placeholder \"-\" given "
                error_message+="as one of the ${#long_options[@]} long option "
                error_message+="names, instead of a legit name."
                printf '%s\0' "${error_message}"
            fi

            # Check how often a long option name is given.  If it was
            # given multiple times, output an error message.
            for long_option in "${long_options[@]}"; do
                if [[ "${long_option}" != "-" ]]; then
                    # Check if the long option name is given multiple
                    # times in the current argument's definition.
                    count="$(argparser_count "${long_option}" \
                        "${long_options[@]}")"
                    if (( count > 1 )); then
                        error_message="Error: The argument with the "
                        error_message+="identifier \"${arg_key}\" has the "
                        error_message+="long option \"${long_option}\" "
                        error_message+="given ${count} times."
                        printf '%s\0' "${error_message}"
                    fi

                    # Check if the long option name is already given in
                    # another argument's definition.
                    if [[ "$(argparser_in_array "${long_option}" \
                        "${!all_long_options[@]}")" == true \
                        && "${all_long_options[${long_option}]}" != \
                        "${arg_key}" ]]
                    then
                        error_message="Error: The argument with the "
                        error_message+="identifier \"${arg_key}\" has the "
                        error_message+="long option \"${long_option}\" given, "
                        error_message+="but that is already in use by "
                        error_message+="${all_long_options[${long_option}]}."
                        printf '%s\0' "${error_message}"
                    fi

                    # Add the long option name to the associative array
                    # of all long option names.
                    all_long_options[${long_option}]="${arg_key}"
                fi
            done
        else
            long_option="${long_options[0]}"
            if [[ "${long_option}" != "-" ]]; then
                # Check if the long option name is already given in
                # another argument's definition.
                if [[ "$(argparser_in_array "${long_option}" \
                    "${!all_long_options[@]}")" == true ]]
                then
                    error_message="Error: The argument with the identifier "
                    error_message+="\"${arg_key}\" has the long option "
                    error_message+="\"${long_option}\" given, but that is "
                    error_message+="already in use by "
                    error_message+="${all_long_options[${long_option}]}."
                    printf '%s\0' "${error_message}"
                fi

                # Add the long option name to the associative array of
                # all long option names.
                all_long_options[${long_option}]="${arg_key}"
            fi
        fi

        # Check if at least one short or long option name is given.
        if [[ "${short_options[0]}" == "-" && "${long_options[0]}" == "-" ]]
        then
            # No option name is given, so output an error message.
            error_message="Error: The argument with the identifier "
            error_message+="\"${arg_key}\" must have at least one short or "
            error_message+="long option name."
            printf '%s\0' "${error_message}"
        fi
    done
}

function argparser_check_arg_definition_values() {
    # Check if the script's arguments' definition is consistent
    # regarding the default and choice values, as well as the number of
    # arguments.  This should always be true for production scripts, but
    # maybe not while testing.
    #
    # Nonlocals:
    # - args_definition: the arguments definition (read-only)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    #
    # Output:
    # - the error messages, starting with "Error: ", possibly
    #   concatenated with null characters

    # Define the local variables.
    local -a arg_definition
    local arg_key
    local arg_number
    local -a choice_values
    local default_value
    local -a default_values
    local error_message

    for arg_key in "${!args_definition[@]}"; do
        # Read the argument's definition.
        IFS="${ARGPARSER_ARG_DELIMITER_1}" read -a arg_definition \
            <<< "${args_definition[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a default_values \
            <<< "${arg_definition[2]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a choice_values \
            <<< "${arg_definition[3]}"
        arg_number="${arg_definition[4]}"

        # Check if the default value for flags is either true or false.
        if [[ "${arg_number}" == 0 && "${default_values[0]}" != true \
            && "${default_values[0]}" != false ]]
        then
            default_values="$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; printf '%s' \
                "${default_values[*]}")"
            error_message="Error: The argument with the identifier "
            error_message+="\"${arg_key}\" must be true or alse, but is "
            error_message+="{${default_values}} as default."
            printf '%s\0' "${error_message}"
        fi

        # Check if the number of default values equals the number of
        # required values.  If there are default values and their number
        # doesn't match, output an error message indicating the number of
        # required and default arguments.  Ignore flags as long as they have
        # the only default value of true or false, but a number of required
        # values of 0.
        if [[ "${arg_number}" != "+" \
            && "${default_values[0]}" != "-" \
            && "${#default_values[@]}" != "${arg_number}" \
            && "${arg_number}" != 0 \
            && "${#default_values[@]}" != 1 ]]
        then
            if [[ "${arg_number}" == 1 ]]; then
                error_message="Error: The argument with the identifier "
                error_message+="\"${arg_key}\" requires 1 value, but has "
                error_message+="${#default_values[@]} given per default."
                printf '%s\0' "${error_message}"
            else
                error_message="Error: The argument with the identifier "
                error_message+="\"${arg_key}\" requires ${arg_number} values, "
                error_message+="but has ${#default_values[@]} given as "
                error_message+="default."
                printf '%s\0' "${error_message}"
            fi
        fi

        # Check if the default values accord to the choice values, i.e., if
        # each default value lies within the array of choice values.  Else,
        # output an error message.
        if [[ "${choice_values[0]}" != "-" ]]; then
            # Check that flags have no choice values.
            if [[ "${arg_number}" == 0 ]]; then
                choice_values="$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; \
                    printf '%s' "${choice_values[*]}")"
                error_message="Error: The argument with the identifier "
                error_message+="\"${arg_key}\" accepts no choice values, but "
                error_message+="uses {${choice_values}} per default."
                printf '%s\0' "${error_message}"
            fi

            # Check the default values.
            for default_value in "${default_values[@]}"; do
                if [[ "${default_value}" != "-" \
                    && "$(argparser_in_array "${default_value}" \
                    "${choice_values[@]}")" == false ]]
                then
                    choice_values="$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; \
                        printf '%s' "${choice_values[*]}")"
                    default_values="$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; \
                        printf '%s' "${default_values[*]}")"
                    error_message="Error: The argument with the identifier "
                    error_message+="\"${arg_key}\" accepts only the choice "
                    error_message+="values {${choice_values}}, but has "
                    error_message+="{${default_values}} given as default."
                    printf '%s\0' "${error_message}"
                    break
                fi
            done
        fi
    done
}

# Define the argparser functions for the argument parsing.
function argparser_get_option_names() {
    # Concatenate the name of all short and long options for the error
    # and warning messages.
    #
    # Arguments:
    # - $1: the argument's name (key)
    # - $2: the order of the options ("short-long" or "long-short")
    #
    # Nonlocals:
    # - args_definition: the arguments definition (read-only)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_ERROR_STYLE (read-only)
    #
    # Output:
    # - the name of all short and long options as comma-separated string

    # Define the local variables.
    local arg_definition
    local arg_key
    local error_message
    local long_options
    local option_names
    local order
    local short_options

    # Read the arguments.
    arg_key="$1"
    order="$2"

    # Read the argument's definition.
    IFS="${ARGPARSER_ARG_DELIMITER_1}" read -a arg_definition \
        <<< "${args_definition[${arg_key}]}"
    IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a short_options \
        <<< "${arg_definition[0]}"
    IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a long_options \
        <<< "${arg_definition[1]}"

    # Concatenate the name of all short and long options.
    if [[ "${short_options[0]}" != "-" && "${long_options[0]}" != "-" ]]; then
        if [[ "${order}" == "short-long" ]]; then
            option_names="$(printf -- '-%s,' "${short_options[@]}")"
            option_names+="$(printf -- '--%s,' "${long_options[@]}")"
        elif [[ "${order}" == "long-short" ]]; then
            option_names="$(printf -- '--%s,' "${long_options[@]}")"
            option_names+="$(printf -- '-%s,' "${short_options[@]}")"
        else
            error_message="Error: Wrong order \"${order}\" specified."
            printf '%s\n' "$(argparser_colorize "${ARGPARSER_ERROR_STYLE}" \
                "${error_message}")" >&2
        fi
    elif [[ "${short_options[0]}" != "-" ]]; then
        option_names="$(printf -- '-%s,' "${short_options[@]}")"
    else
        option_names="$(printf -- '--%s,' "${long_options[@]}")"
    fi
    option_names="${option_names%,}"
    printf '%s' "${option_names}"
}

function argparser_parse_arg() {
    # Parse an argument given to the script.
    #
    # Arguments:
    # - $1: the argument to parse
    #
    # Nonlocals:
    # - args_definition: the arguments definition (read-only)
    # - is_positional: whether the positional arguments delimiter "--"
    #   has already been set and has not been unset by "++" (read-only)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    #
    # Output:
    # - the parsed argument as message or an error message, starting
    #   with "Help", "Usage", "Positional_Start", "Positional_End",
    #   "Error: ", "Argument: ", or "Value: ", in the latter three cases
    #   possibly concatenated with null characters

    # Define the local variables.
    local arg_definition
    local arg_key
    local given_arg
    local long_option
    local long_options
    local prefix
    local short_option
    local short_options
    local value
    local values

    # Read the argument.
    given_arg="$1"

    # If the argument doesn't start with a hyphen ("-") or plus sign
    # ("+"), it is considered a value to a previous argument.  Likewise,
    # if the positional arguments delimiter "--" has already been set
    # and has neither been unset by "++" not the current argument is
    # this "++", then any value is considered a positional argument.
    # Split the value on ${ARGPARSER_ARG_DELIMITER_2} characters and
    # output the respective message for each value.
    if [[ "${given_arg}" != "++"* \
        && ("${given_arg}" != [-+]* || "${is_positional}" == true) ]]
    then
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a values <<< "${given_arg}"
        for value in "${values[@]}"; do
            printf 'Value: %s\0' "${value}"
        done
        return
    fi

    # If the argument is the positional arguments delimiter "--" or "++"
    # or for help or usage, output the respective message.  If an "="
    # character follows, output an error message and the argument, such
    # that values following the unknown argument are assigned to this
    # argument, not the last known one that got parsed.
    if [[ "${given_arg}" == "--" ]]; then
        printf 'Positional_Start'
        return
    elif [[ "${given_arg}" == "--="* ]]; then
        printf 'Error: The special option "--" takes no value.\0'
        printf 'Argument: %s' "${given_arg}"
        return
    elif [[ "${given_arg}" == "++" ]]; then
        printf 'Positional_End'
        return
    elif [[ "${given_arg}" == "++="* ]]; then
        printf 'Error: The special option "++" takes no value.\0'
        printf 'Argument: %s' "${given_arg}"
        return
    elif [[ "${given_arg}" == "-h" || "${given_arg}" == "--help" ]]; then
        printf 'Help'
        return
    elif [[ "${given_arg}" == "-h="* || "${given_arg}" == "--help="* ]]; then
        printf 'Error: The option "-h,--help" takes no value.\0'
        printf 'Argument: %s' "${given_arg}"
        return
    elif [[ "${given_arg}" == "-u" || "${given_arg}" == "--usage" ]]; then
        printf 'Usage'
        return
    elif [[ "${given_arg}" == "-u="* || "${given_arg}" == "--usage="* ]]; then
        printf 'Error: The option "-u,--usage" takes no value.\0'
        printf 'Argument: %s' "${given_arg}"
        return
    fi

    # Read all defined arguments and check whether the given argument is
    # part of them.  If so, output the argument's name and possibly all
    # values following the "=" character.
    for arg_key in "${!args_definition[@]}"; do
        # Read the argument's definition.
        IFS="${ARGPARSER_ARG_DELIMITER_1}" read -a arg_definition \
            <<< "${args_definition[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a short_options \
            <<< "${arg_definition[0]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a long_options \
            <<< "${arg_definition[1]}"

        # Check the short options.
        for short_option in "${short_options[@]}"; do
            if [[ "${short_option}" == "-" ]]; then
                # Ignore arguments without short option name.
                break
            fi

            if [[ "${given_arg}" == [-+]"${short_option}" ]]; then
                # Output the argument and its prefix ("-" or "+").
                prefix="${given_arg::1}"
                printf 'Argument: %s%s' "${prefix}" "${arg_key}"
                return
            elif [[ "${given_arg}" == [-+]"${short_option}="* ]]; then
                # Output the argument, its prefix ("-" or "+"), and all
                # values split on ${ARGPARSER_ARG_DELIMITER_2}
                # characters.
                prefix="${given_arg::1}"
                printf 'Argument: %s%s\0' "${prefix}" "${arg_key}"

                IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a values \
                    <<< "${given_arg#*=}"
                for value in "${values[@]}"; do
                    printf 'Value: %s\0' "${value}"
                done
                return
            fi
        done

        # Check the long options.
        for long_option in "${long_options[@]}"; do
            if [[ "${long_option}" == "-" ]]; then
                # Ignore arguments without long option name.
                break
            fi

            if [[ "${given_arg}" == "--${long_option}" \
                || "${given_arg}" == "++${long_option}" ]]
            then
                # Output the argument and its prefix ("-" or "+").
                prefix="${given_arg::1}"
                printf 'Argument: %s%s' "${prefix}" "${arg_key}"
                return
            elif [[ "${given_arg}" == "--${long_option}="* \
                || "${given_arg}" == "++${long_option}="* ]]
            then
                # Output the argument, its prefix ("-" or "+"), and all
                # values split on ${ARGPARSER_ARG_DELIMITER_2}
                # characters.
                prefix="${given_arg::1}"
                printf 'Argument: %s%s\0' "${prefix}" "${arg_key}"

                IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a values \
                    <<< "${given_arg#*=}"
                for value in "${values[@]}"; do
                    printf 'Value: %s\0' "${value}"
                done
                return
            fi
        done
    done

    # If the argument hasn't been found in the definition, output an
    # error message and the argument, such that values following the
    # unknown argument are assigned to this argument, not the last known
    # one that got parsed.
    printf 'Error: The argument "%s" is unknown.\0' "${given_arg%%=*}"
    printf 'Argument: %s' "${given_arg}"
}

function argparser_check_arg_value() {
    # Check if a script's argument accords to its definition.
    #
    # Arguments:
    # - $1: the argument's name (key)
    # - $2: the argument's values, the first being the argument's prefix
    #       ("-" or "+")
    #
    # Nonlocals:
    # - args_definition: the arguments definition (read-only)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    #
    # Output:
    # - the parsed argument as message or an error message, starting
    #   with "Error: ", "Warning: ", or "Value: ", possibly concatenated
    #   with null characters

    # Define the local variables.
    local arg_definition
    local arg_key
    local arg_number
    local choice_values
    local default_values
    local error_message
    local option_names
    local prefix
    local value
    local values
    local warning_message

    # Read the arguments.
    arg_key="$1"
    prefix="${2::1}"
    IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a values <<< "${2:2}"

    # Read the argument's definition.
    IFS="${ARGPARSER_ARG_DELIMITER_1}" read -a arg_definition \
        <<< "${args_definition[${arg_key}]}"
    IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a default_values \
        <<< "${arg_definition[2]}"
    IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a choice_values \
        <<< "${arg_definition[3]}"
    arg_number="${arg_definition[4]}"

    # Concatenate the name of all short and long options for the error
    # and warning messages.
    option_names="$(argparser_get_option_names "${arg_key}" "short-long")"

    # Check the values.  If an argument hadn't been given, its value was
    # set to "-", but not, if it was given without value (then,
    # ${values} is empty).
    if (( "${#values[@]}" > 0 )) && [[ "${values[0]}" == "-" ]]; then
        # The argument is not given, but must have been since it doesn't
        # have a default value.  Hence, output an error message.  Else,
        # read the default values.  This is required for optional
        # arguments.
        if [[ "${default_values[0]}" == "-" ]]; then
            error_message="Error: The argument \"${option_names}\" is "
            error_message+="mandatory, but not given."
            printf '%s' "${error_message}"
            return
        else
            values=("${default_values[@]}")
        fi
    else
        if [[ "${arg_number}" != "+" && "${#values[@]}" != "${arg_number}" ]] \
            || [[ "${arg_number}" == "+" && "${#values[@]}" == 0 ]]
        then
            # If the number of values doesn't equal the number of
            # required values, check if some default values are given.
            if [[ "${default_values[0]}" == "-" ]]; then
                # If no default value is given, output an error message
                # indicating the number of required and given arguments.
                if [[ "${arg_number}" == 1 ]]; then
                    error_message="Error: The argument \"${option_names}\" "
                    error_message+="requires 1 value, but has ${#values[@]} "
                    error_message+="given."
                    printf '%s' "${error_message}"
                elif [[ "${arg_number}" == "+" ]]; then
                    error_message="Error: The argument \"${option_names}\" "
                    error_message+="requires at least 1 value, but has "
                    error_message+="${#values[@]} given."
                    printf '%s' "${error_message}"
                else
                    error_message="Error: The argument \"${option_names}\" "
                    error_message+="requires ${arg_number} values, but has "
                    error_message+="${#values[@]} given."
                    printf '%s' "${error_message}"
                fi
                return
            else
                # As some default values are given, print a similar
                # warning message as for the absence case, but set the
                # values to the default values and continue.
                default_values="$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; \
                    printf '%s' "${default_values[*]}")"
                if [[ "${arg_number}" == 1 ]]; then
                    warning_message="Warning: The argument "
                    warning_message+="\"${option_names}\" requires 1 value,"
                    warning_message+=" but has ${#values[@]} given.  For "
                    warning_message+="convenience, the default "
                    warning_message+="({${default_values[@]}}) is used."
                    printf '%s\0' "${warning_message}"
                elif [[ "${arg_number}" == "+" ]]; then
                    warning_message="Warning: The argument "
                    warning_message+="\"${option_names}\" requires at least 1 "
                    warning_message+="value, but has ${#values[@]} given.  "
                    warning_message+="For convenience, the default "
                    warning_message+="({${default_values[@]}}) is used."
                    printf '%s\0' "${warning_message}"
                else
                    warning_message="Warning: The argument "
                    warning_message+="\"${option_names}\" requires "
                    warning_message+="${arg_number} values, but has "
                    warning_message+="${#values[@]} given.  For convenience, "
                    warning_message+="the default ({${default_values[@]}}) is "
                    warning_message+="used."
                    printf '%s\0' "${warning_message}"
                fi
                IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a default_values \
                    <<< "${arg_definition[2]}"
                values=("${default_values[@]}")
            fi
        elif [[ "${arg_number}" == 0 && (! -v values || -z "${values[0]}") ]]
        then
            # If no value is required nor given, the argument is a flag.
            # As it is set (present), set the value to true for a "-"
            # prefix and to false for a "+" prefix.
            if [[ "${prefix}" == "-" ]]; then
                values=true
            else
                values=false
            fi
        fi
    fi

    # If a "+" prefix is given and the argument is no flag, output an
    # error message.
    if [[ "${prefix}" == "+" && "${arg_number}" != 0 ]]; then
        error_message="Error: The argument \"${option_names}\" is no flag and "
        error_message+="thus cannot be given with a \"+\" prefix."
        printf '%s' "${error_message}"
        return
    fi

    # Check if the given values accord to the choice values, i.e., if
    # each given value lies within the array of choice values.  Else,
    # output an error message.
    if [[ "${choice_values[0]}" != "-" ]]; then
        for value in "${values[@]}"; do
            if [[ "$(argparser_in_array "${value}" \
                "${choice_values[@]}")" == false ]]
            then
                choice_values="$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; \
                    printf '%s' "${choice_values[*]}")"
                error_message="Error: The argument \"${option_names}\" must "
                error_message+="be in {${choice_values}}."
                printf '%s' "${error_message}"
                return
            fi
        done
    fi

    # Output the checked values as
    # ${ARGPARSER_ARG_DELIMITER_2}-separated string.
    value="$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; printf '%s' "${values[*]}")"
    printf 'Value: %s' "${value}"
}

# Define the argparser functions for creating and printing the help and
# usage messages, including their translation.
function argparser_read_translation() {
    # Read the translation of the auto-generated text for help and usage
    # messages into an associative array.
    #
    # Nonlocals:
    # - dictionary: the associative array holding the translation text
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_ERROR_EXIT_CODE (read-only)
    # - ARGPARSER_ERROR_STYLE (read-only)
    # - ARGPARSER_LANGUAGE (read-only)
    # - ARGPARSER_TRANSLATION_FILE (read-only)
    # - ARGPARSER_WARNING_STYLE (read-only)

    # Define the local variables.
    local column
    local error_message
    local -a header
    local -a line
    local source_column
    local target_column
    local warning_message

    # Read the first line (the header) of ${ARGPARSER_TRANSLATION_FILE}
    # to get the column indices for the source ("en") and target
    # language (${ARGPARSER_LANGUAGE}).
    IFS="${ARGPARSER_ARG_DELIMITER_1}" read -a header \
        < "${ARGPARSER_TRANSLATION_FILE}"

    source_column=""
    target_column=""
    for column in "${!header[@]}"; do
        if [[ "${header[column]}" == "en" ]]; then
            source_column="${column}"
        fi
        if [[ "${header[column]}" == "${ARGPARSER_LANGUAGE}" ]]; then
            target_column="${column}"
        fi
    done

    # If the column for the source language isn't given, output an error
    # message and exit.
    if [[ -z "${source_column}" ]]; then
        error_message="Error: In the translation file "
        error_message+="\"${ARGPARSER_TRANSLATION_FILE}\", the column "
        error_message+="\"en\" is missing, but required as source for "
        error_message+="translation."

        error_message="$(argparser_colorize "${ARGPARSER_ERROR_STYLE}" \
            "${error_message}")"
        printf '%s\n' "${error_message}" >&2
        exit "${ARGPARSER_ERROR_EXIT_CODE}"
    fi

    # If the column for the target language isn't given, output a
    # warning message and set the target language to the source language
    # to be able to continue.
    if [[ -z "${target_column}" ]]; then
        warning_message="Warning: In the translation file "
        warning_message+="\"${ARGPARSER_TRANSLATION_FILE}\", the column "
        warning_message+="\"${ARGPARSER_LANGUAGE}\" is missing, but required "
        warning_message+="as target for translation.  For convenience, the "
        warning_message+="source language \"en\" is used, instead."

        warning_message="$(argparser_colorize "${ARGPARSER_WARNING_STYLE}" \
            "${warning_message}")"
        printf '%s\n' "${warning_message}" >&2

        target_column="${source_column}"
    fi

    # Read all lines of the translation file and save the translation in
    # the associative array ${dictionary}, using the source language as
    # key and the target language as value.  Then, remove the header
    # field from the array, which was also read.
    while IFS="${ARGPARSER_ARG_DELIMITER_1}" read -a line; do
        dictionary[${line[${source_column}]}]="${line[${target_column}]}"
    done < "${ARGPARSER_TRANSLATION_FILE}"

    unset dictionary[${header[${source_column}]}]
}

function argparser_translate() {
    # Translate the given string.
    #
    # Arguments:
    # - $@: the string to translate, possibly given as substrings to
    #       join
    #
    # Nonlocals:
    # - dictionary: the associative array holding the translation text
    #   (read-only)
    #
    # Environment:
    # - ARGPARSER_TRANSLATION_FILE (read-only)
    # - ARGPARSER_WARNING_STYLE (read-only)
    #
    # Output:
    # - the translated string

    # Define the local variable.
    local string
    local substring

    # Read the argument.
    string=""
    for substring in "$@"; do
        string+="${substring}"
    done

    # If an ${ARGPARSER_TRANSLATION_FILE} was given (and thus the
    # translation was requested), translate the string by fetching its
    # translation from the associative array ${dictionary}.  Else,
    # output the untranslated string.  If the string does not exist in
    # the dictionary, output a warning message and the untranslated
    # string.
    if [[ -n "${ARGPARSER_TRANSLATION_FILE}" ]]; then
        if [[ "$(argparser_in_array "${string}" \
            "${!dictionary[@]}")" == true ]]
        then
            printf '%s' "${dictionary[${string}]}"
        else
            warning_message="Warning: In the translation file "
            warning_message+="\"${ARGPARSER_TRANSLATION_FILE}\", the source "
            warning_message+="string \"${string}\" is missing. For "
            warning_message+="convenience, the untranslated string is used, "
            warning_message+="instead."

            warning_message="$(argparser_colorize \
                "${ARGPARSER_WARNING_STYLE}" "${warning_message}")"
            printf '%s\n' "${warning_message}" >&2

            printf '%s' "${string}"
        fi
    else
        printf '%s' "${string}"
    fi
}

function argparser_print_help_or_usage_file() {
    # Print a help or usage message from a file, possibly without
    # commented lines (i.e., lines starting with "#") and their trailing
    # blank lines inside the message.  Lines starting with
    # ${ARGPARSER_*_FILE_INCLUDE_CHAR} will be replaced by the
    # auto-generated help or usage message.
    #
    # Arguments:
    # - $1: the help type ("Help" or "Usage")
    #
    # Environment:
    # - ARGPARSER_HELP_FILE (read-only)
    # - ARGPARSER_HELP_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_HELP_FILE_KEEP_COMMENTS (read-only)
    # - ARGPARSER_USAGE_FILE (read-only)
    # - ARGPARSER_USAGE_FILE_INCLUDE_CHAR (read-only)
    # - ARGPARSER_USAGE_FILE_KEEP_COMMENTS (read-only)

    # Define the local variables.
    local file
    local help_type
    local include_char
    local include_directive
    local keep_comments
    local line
    local line_type

    # Read the argument.
    help_type="$1"
    if [[ "${help_type}" == "Help" ]]; then
        file="${ARGPARSER_HELP_FILE}"
        include_char="${ARGPARSER_HELP_FILE_INCLUDE_CHAR}"
        keep_comments="${ARGPARSER_HELP_FILE_KEEP_COMMENTS}"
    elif [[ "${help_type}" == "Usage" ]]; then
        file="${ARGPARSER_USAGE_FILE}"
        include_char="${ARGPARSER_USAGE_FILE_INCLUDE_CHAR}"
        keep_comments="${ARGPARSER_USAGE_FILE_KEEP_COMMENTS}"
    fi

    line_type="text"
    while IFS="" read line; do
        # Set the line_type to "include_directive" if the line contains
        # the "<ArgumentGroup>" directive, to "comment" if the line is
        # commented and ${keep_comments} is false, and to "text" if it
        # is not empty (but not commented).  Thus, empty lines following
        # comments still have line_type set to "comment".
        if [[ "${line}" == "${include_char}"* ]]; then
            line_type="include_directive"
            include_directive="${line:1}"
            if [[ "${help_type}" == "Help" ]]; then
                argparser_create_help_message "${include_directive}"
            elif [[ "${help_type}" == "Usage" ]]; then
                argparser_create_usage_message "${include_directive}"
            fi
        elif [[ "${line}" == \#* && "${keep_comments}" == false ]]; then
            line_type="comment"
        elif [[ -n "${line}" || "${keep_comments}" == true ]]; then
            line_type="text"
        fi

        # If the line_type has been set to "text", print the current
        # line.  If it is set to "include_directive", reset it to "text"
        # to (possibly) print the next line, and only not the current
        # "<ArgumentGroup>" line.
        if [[ "${line_type}" == "text" ]]; then
            printf '%s\n' "${line}"
        elif [[ "${line_type}" == "include_directive" ]]; then
            line_type="text"
        fi
    done < "${file}"
}

function argparser_create_help_message() {
    # Create a help message for the script's arguments.
    #
    # Arguments:
    # - $1: the include directive ("All", "Header", "Help", or any
    #       argument group)
    #
    # Nonlocals:
    # - args_definition: the arguments definition (read-only)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_1 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_2 (read-only)
    # - ARGPARSER_MAX_COL_WIDTH_3 (read-only)
    # - ARGPARSER_SCRIPT_NAME (read-only)

    # Define the local variables.
    local arg_definition
    local arg_group
    local -a arg_groups
    local arg_key
    local arg_number
    local choice_values
    local -a col_1
    local -a col_2
    local -a col_3
    local col_width_1
    local col_width_2
    local col_width_3
    local default_values
    local header
    local help_text
    local i
    local include_directive
    local index
    local j
    local -a line
    local line_count_1
    local line_count_2
    local line_count_3
    local lines_col_1
    local lines_col_2
    local lines_col_3
    local long_option
    local long_options
    local max_line_count
    local -a new_col_1
    local new_col_1_value
    local -a new_col_2
    local new_col_2_value
    local -a new_col_3
    local new_col_3_value
    local newline_count_1
    local newline_count_2
    local newline_count_3
    local newlines_1
    local newlines_2
    local newlines_3
    local note
    local -a option_names
    local short_options
    local -A sorted_col_1
    local -A sorted_col_2
    local -A sorted_col_3
    local -a whitespace_1
    local -a whitespace_2
    local whitespace_len_1
    local whitespace_len_2

    # Read the argument.
    include_directive="$1"

    # Read the arguments' groups to sort the arguments by group in the
    # help message.  To this end, sort the groups alphabetically and
    # compare each argument's group later upon iterating over them.
    arg_groups=( )
    for arg_key in "${!args_definition[@]}"; do
        IFS="${ARGPARSER_ARG_DELIMITER_1}" read -a arg_definition \
            <<< "${args_definition[${arg_key}]}"
        arg_group="${arg_definition[5]}"
        if [[ "$(argparser_in_array "${arg_group}" \
            "${arg_groups[@]}")" == false ]]
        then
            arg_groups+=("${arg_group}")
        fi
    done

    # Sort the argument groups.
    mapfile -d "" -t arg_groups < <(argparser_sort false "${arg_groups[@]}")

    # The help message is structured in three columns: short options,
    # long options and the help text.  Populate these columns with the
    # entries for each argument.
    col_1=( )
    col_2=( )
    col_3=( )
    for arg_group in "${arg_groups[@]}"; do
        # Only add the argument group that was requested by the include
        # directive.  Skip the "Header" and "Help" directive, but not
        # the "All" directive.
        if [[ "${include_directive}" == "Header" \
            || "${include_directive}" == "Help"  ]]
        then
            continue
        elif [[ "${include_directive}" != "All" \
            && "${include_directive}" != "${arg_group}" ]]
        then
            continue
        fi

        new_col_1=( )
        new_col_2=( )
        new_col_3=( )
        option_names=( )

        for arg_key in "${!args_definition[@]}"; do
            # Read the argument's group to check whether it belongs to
            # the current group.
            IFS="${ARGPARSER_ARG_DELIMITER_1}" read -a arg_definition \
                <<< "${args_definition[${arg_key}]}"
            if [[ "${arg_definition[5]}" != "${arg_group}" ]]; then
                continue
            fi

            # Read the argument's remaining definition.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a short_options \
                <<< "${arg_definition[0]}"
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a long_options \
                <<< "${arg_definition[1]}"
            default_values="${arg_definition[2]}"
            choice_values="${arg_definition[3]}"
            arg_number="${arg_definition[4]}"
            help_text="${arg_definition[6]}"

            # Concatenate the name of all short and long options for the
            # sorting of all arguments, later.
            option_names+=("$(argparser_get_option_names "${arg_key}" \
                "long-short")")

            # Define the columns' next line, for the current argument.
            # The argument may have some short and long options, some
            # default and some choice values or an argument number of 0
            # (i.e., it is a flag), with the existence of each changing
            # the look of the respective column.  If either no short or
            # no long option is given, use the empty string instead.
            # Set the first column's value.
            if [[ "${short_options[0]}" == "-" ]]; then  # No short option.
                new_col_1+=("")
            elif [[ "${arg_number}" == 0 ]]; then  # Flag.
                new_col_1_value="["
                new_col_1_value+="$(printf -- "-%s, " "${short_options[@]}")"
                new_col_1_value="${new_col_1_value%, }"
                new_col_1_value+="]"
                if [[ "${long_options[0]}" != "-" ]]; then  # Long option.
                    new_col_1_value+=","
                fi
                new_col_1+=("${new_col_1_value}")
            else  # Non-flag.
                if [[ "${long_options[0]}" == "-" ]]; then  # No long option.
                    new_col_1_value="$(printf -- "-%s, " \
                        "${short_options[@]}")"
                    new_col_1_value="${new_col_1_value%, }"
                    new_col_1+=("${new_col_1_value}")
                else  # Long option.
                    new_col_1+=("$(printf -- "-%s, " "${short_options[@]}")")
                fi
            fi

            # Set the second column's value.
            if [[ "${long_options[0]}" == "-" ]]; then  # No long option.
                new_col_2+=("")
            elif [[ "${arg_number}" == 0 ]]; then  # Flag.
                new_col_2_value="["
                new_col_2_value+="$(printf -- "--%s, " "${long_options[@]}")"
                new_col_2_value="${new_col_2_value%, }"
                new_col_2_value+="]"
                new_col_2+=("${new_col_2_value}")
            elif [[ "${choice_values}" != "-" && "${default_values}" != "-" ]]
            then  # Choice and default.
                new_col_2_value=""
                for long_option in "${long_options[@]}"; do
                    new_col_2_value+="$(printf -- "--%s[={%s}], " \
                        "${long_option}" "${choice_values}")"
                done
                new_col_2_value="${new_col_2_value%, }"
                new_col_2+=("${new_col_2_value}")
            elif [[ "${choice_values}" != "-" ]]; then  # Choice only.
                new_col_2_value=""
                for long_option in "${long_options[@]}"; do
                    new_col_2_value+="$(printf -- "--%s={%s}, " \
                        "${long_option}" "${choice_values}")"
                done
                new_col_2_value="${new_col_2_value%, }"
                new_col_2+=("${new_col_2_value}")
            elif [[ "${default_values}" != "-" ]]; then  # Default only.
                new_col_2_value=""
                for long_option in "${long_options[@]}"; do
                    new_col_2_value+="$(printf -- "--%s[=%s], " \
                        "${long_option}" "${long_option^^}")"
                done
                new_col_2_value="${new_col_2_value%, }"
                new_col_2+=("${new_col_2_value}")
            else  # No choice nor default.
                new_col_2_value=""
                for long_option in "${long_options[@]}"; do
                    new_col_2_value+="$(printf -- "--%s=%s, " \
                        "${long_option}" "${long_option^^}")"
                done
                new_col_2_value="${new_col_2_value%, }"
                new_col_2+=("${new_col_2_value}")
            fi

            # Set the third column's value.
            if [[ "${arg_number}" == 0 ]]; then  # Flag.
                new_col_3_value="${help_text} ("
                new_col_3_value+="$(argparser_translate "default"): "
                new_col_3_value+="$(argparser_translate "${default_values}"))"
                new_col_3+=("${new_col_3_value}")
            elif [[ "${default_values}" != "-" ]]; then  # Default.
                new_col_3_value="${help_text} ("
                new_col_3_value+="$(argparser_translate "default"): "
                new_col_3_value+="${default_values})"
                new_col_3+=("${new_col_3_value}")
            else  # No default.
                new_col_3+=("${help_text}")
            fi
        done

        # Sort the arguments by the option names.  To this end, three
        # associative arrays are defined that use the option names as
        # keys and the first, second, or third column's values as
        # values.  Then, the option names' indexed array gets sorted and
        # the indexed arrays for the first, second, and third columns
        # are re-populated using the values from the associative array,
        # such that the sorted option names define the order of the yet
        # unsorted columns.  As a consequence, all columns are sorted as
        # if they would have been sorted together (which appears not be
        # feasible).
        for i in "${!option_names[@]}"; do
            sorted_col_1[${option_names[i]}]="${new_col_1[i]}"
            sorted_col_2[${option_names[i]}]="${new_col_2[i]}"
            sorted_col_3[${option_names[i]}]="${new_col_3[i]}"
        done

        mapfile -d "" -t option_names \
            < <(argparser_sort false "${option_names[@]}")

        for i in "${!option_names[@]}"; do
            col_1+=("${sorted_col_1[${option_names[i]}]}")
            col_2+=("${sorted_col_2[${option_names[i]}]}")
            col_3+=("${sorted_col_3[${option_names[i]}]}")
        done

        # To mark the end of an argument group later upon printing, add
        # an empty line in all three columns.  This cannot appear by
        # chance, whereas empty lines for single columns emerge from the
        # line break insertion when they are differently long.  Thus, a
        # completely empty line can be used as safe argument group
        # delimiter.
        col_1+=("")
        col_2+=("")
        col_3+=("")
    done

    # Add the help and usage flags that always exist if the "All" or
    # "Help" include directive was requested.
    if [[ "${include_directive}" == "All" \
        || "${include_directive}" == "Help" ]]
    then
        col_1+=("-h,")
        col_2+=("--help")
        col_3+=("$(argparser_translate "display this help and exit")")
        col_1+=("-u,")
        col_2+=("--usage")
        col_3+=("$(argparser_translate "display the usage and exit")")
    fi

    # Limit the width of each column of the help message to
    # ${ARGPARSER_MAX_COL_WIDTH_*} by inserting line breaks.
    # Split the element of column 1.
    col_width_1=0
    for i in "${!col_1[@]}"; do
        mapfile -d "" -t line \
            < <(argparser_fold "${col_1[i]}" "${ARGPARSER_MAX_COL_WIDTH_1}" \
                "${col_width_1}")
        col_1[i]="${line[0]}"
        col_width_1="${line[1]}"
    done

    # Split the element of column 2.
    col_width_2=0
    for i in "${!col_2[@]}"; do
        mapfile -d "" -t line \
            < <(argparser_fold "${col_2[i]}" "${ARGPARSER_MAX_COL_WIDTH_2}" \
                "${col_width_2}")
        col_2[i]="${line[0]}"
        col_width_2="${line[1]}"
    done

    # Split the element of column 3.
    col_width_3=0
    for i in "${!col_3[@]}"; do
        mapfile -d "" -t line \
            < <(argparser_fold "${col_3[i]}" "${ARGPARSER_MAX_COL_WIDTH_3}" \
                "${col_width_3}")
        col_3[i]="${line[0]}"
        col_width_3="${line[1]}"
    done

    # Adjust the number of line breaks between each column's rows, such
    # that each element shares the same number of rows.
    for i in "${!col_1[@]}"; do
        # Count the number of rows for each element.
        mapfile -t lines_col_1 <<< "${col_1[i]}"
        line_count_1="${#lines_col_1[@]}"

        mapfile -t lines_col_2 <<< "${col_2[i]}"
        line_count_2="${#lines_col_2[@]}"

        mapfile -t lines_col_3 <<< "${col_3[i]}"
        line_count_3="${#lines_col_3[@]}"

        # Get the largest line count.
        if (( line_count_1 > line_count_2 )); then
            if (( line_count_1 > line_count_3 )); then
                max_line_count="${line_count_1}"
            else
                max_line_count="${line_count_3}"
            fi
        else
            if (( line_count_2 > line_count_3 )); then
                max_line_count="${line_count_2}"
            else
                max_line_count="${line_count_3}"
            fi
        fi

        # Set the number of required line breaks to align each line.  If
        # the line count is 0, 1 is subtracted from the maximum line
        # count, such that the last line does not end in a line break.
        # The same holds true for a line count of greater than 0, where
        # normally 1 would have to be added.  This trailing newline
        # character gets added by the here string upon re-reading the
        # arrays, below.
        if (( line_count_1 == 0 )); then
            (( newline_count_1 = max_line_count - 1 ))
        else
            (( newline_count_1 = max_line_count - line_count_1 ))
        fi

        if (( line_count_2 == 0 )); then
            (( newline_count_2 = max_line_count - 1 ))
        else
            (( newline_count_2 = max_line_count - line_count_2 ))
        fi

        if (( line_count_3 == 0 )); then
            (( newline_count_3 = max_line_count - 1 ))
        else
            (( newline_count_3 = max_line_count - line_count_3 ))
        fi

        # To each element, add as many line breaks as computed.
        newlines_1=""
        for (( j = 0; j < newline_count_1; j++ )); do
            newlines_1+=$'\n'
        done
        col_1[i]+="${newlines_1}"

        newlines_2=""
        for (( j = 0; j < newline_count_2; j++ )); do
            newlines_2+=$'\n'
        done
        col_2[i]+="${newlines_2}"

        newlines_3=""
        for (( j = 0; j < newline_count_3; j++ )); do
            newlines_3+=$'\n'
        done
        col_3[i]+="${newlines_3}"
    done

    # Re-read in the columns' lines, such that each line makes up one
    # element of the array.  To this end, split the lines on newline
    # characters (that get stripped off the lines).  The here string
    # adds a trailing newline that acts as additional delimiter.  Else,
    # a line without line break would give the same number of lines
    # (one) as a line with one line break as trailing newline, since
    # line breaks act as trailing delimiters for mapfile, not as inner
    # separators.
    new_col_1=( )
    new_col_2=( )
    new_col_3=( )
    for i in "${!col_1[@]}"; do
        mapfile -t -O "${#new_col_1[@]}" new_col_1 <<< "${col_1[i]}"
        mapfile -t -O "${#new_col_2[@]}" new_col_2 <<< "${col_2[i]}"
        mapfile -t -O "${#new_col_3[@]}" new_col_3 <<< "${col_3[i]}"
    done

    # Store the lines back in the original columns' variables.
    col_1=("${new_col_1[@]}")
    col_2=("${new_col_2[@]}")
    col_3=("${new_col_3[@]}")

    # For proper alignment of the columns, whitespace must be used as
    # separation between shorter elements.  Compute the width for both
    # the first and the second column.  If a line is wider, set the
    # width to the respective value, as long as the width doesn't exceed
    # the limit set by ${ARGPARSER_MAX_COL_WIDTH_*}.
    if [[ "${include_directive}" != "Header" ]]; then
        col_width_1=0
        col_width_2=0
        for i in "${!col_1[@]}"; do
            if (( "${#col_1[i]}" <= ARGPARSER_MAX_COL_WIDTH_1 \
                && "${#col_1[i]}" > col_width_1 ))
            then
                col_width_1="${#col_1[i]}"
            fi

            if (( "${#col_2[i]}" <= ARGPARSER_MAX_COL_WIDTH_2 \
                && "${#col_2[i]}" > col_width_2 ))
            then
                col_width_2="${#col_2[i]}"
            fi
        done
    fi

    # Compute the length of whitespace between column 1 and 2, as well
    # as between column 2 and 3.  This length equals the column's
    # maximum width minus the current line's element's length plus 1 to
    # have at least one space as separation.  If the column width
    # exceeds the limit set by ${ARGPARSER_MAX_COL_WIDTH_*}, insert a
    # line break instead to make the following column's content begin on
    # the next line.  Then, insert as much whitespace as needed to align
    # the column with the other elements.  For column 1, this equals the
    # column's maximum width plus 1 (the mandatory separation), for
    # column 2, both columns' maximum widths plus 2 (twice the mandatory
    # separation).
    whitespace_1=( )
    whitespace_2=( )
    for i in "${!col_1[@]}"; do
        if (( "${#col_1[i]}" <= ARGPARSER_MAX_COL_WIDTH_1 )); then
            (( whitespace_len_1 = col_width_1 - "${#col_1[i]}" + 1 ))
            whitespace_1+=("$(printf '%*s' "${whitespace_len_1}")")
        else
            (( whitespace_len_1 = col_width_1 + 1 ))
            whitespace_1+=("$(printf '\n%*s' "${whitespace_len_1}")")
        fi

        if (( "${#col_2[i]}" <= ARGPARSER_MAX_COL_WIDTH_2 )); then
            (( whitespace_len_2 = col_width_2 - "${#col_2[i]}" + 1 ))
            whitespace_2+=("$(printf '%*s' "${whitespace_len_2}")")
        else
            (( whitespace_len_2 = col_width_1 + col_width_2 + 2 ))
            whitespace_2+=("$(printf '\n%*s' "${whitespace_len_2}")")
        fi
    done

    # If the "All" or "Header" include directive was requested, print
    # the help message's header, giving the script's name and
    # instructions on how to interpret the arguments.  With "All", print
    # a trailing blank line to separate the block from the following
    # arguments.
    if [[ "${include_directive}" == "All" ]]; then
        header="$(argparser_translate "Usage"): ${ARGPARSER_SCRIPT_NAME} "
        header+="$(argparser_translate "ARGUMENTS")"
        printf '%s\n\n' "${header}"

        note="$(argparser_translate "Mandatory arguments to long options " \
            "are mandatory for short options too")."
        printf '%s\n\n' "${note}"
    elif [[ "${include_directive}" == "Header" ]]; then
        header="$(argparser_translate "Usage"): ${ARGPARSER_SCRIPT_NAME} "
        header+="$(argparser_translate "ARGUMENTS")"
        printf '%s\n\n' "${header}"

        note="$(argparser_translate "Mandatory arguments to long options " \
            "are mandatory for short options too")."
        printf '%s\n' "${note}"
    fi

    # For each argument group, print its arguments.
    index=0
    for arg_group in "${arg_groups[@]}"; do
        # Only print the argument group's arguments if it was requested
        # by the include directive.
        if [[ "${include_directive}" != "All" \
            && "${include_directive}" != "${arg_group}" ]]
        then
            continue
        fi

        # Print the argument group's name.
        printf '%s:\n' "${arg_group}"

        # For any argument line, print the three columns and their
        # delimiting whitespace.  If all three columns are empty, the
        # end of the current argument group has been reached.
        for (( i = index; i < "${#col_1[@]}"; i++ )); do
            if [[ -z "${col_1[i]}" && -z "${col_2[i]}" && -z "${col_3[i]}" ]]
            then
                break
            fi

            printf '%s%s%s%s%s\n' "${col_1[i]}" "${whitespace_1[i]}" \
                "${col_2[i]}" "${whitespace_2[i]}" "${col_3[i]}"
        done

        # If the "All" include directive was requested, print a trailing
        # blank line to separate the argument group blocks from each
        # other.
        if [[ "${include_directive}" == "All" ]]; then
            printf '\n'
        fi

        # Set the start index for the next argument group to the current
        # group's end index plus 1 (with the latter being the empty line
        # used as argument group delimiter).
        (( index = i + 1 ))
    done

    # If the "All" or "Help" include directive was requested, print the
    # help and usage lines, which are the last two lines and hence were
    # not used in the sorting process, before.
    if [[ "${include_directive}" == "All" \
        || "${include_directive}" == "Help" ]]
    then
        printf '%s%s%s%s%s\n' "${col_1[-2]}" "${whitespace_1[-2]}" \
            "${col_2[-2]}" "${whitespace_2[-2]}" "${col_3[-2]}"
        printf '%s%s%s%s%s\n' "${col_1[-1]}" "${whitespace_1[-1]}" \
            "${col_2[-1]}" "${whitespace_2[-1]}" "${col_3[-1]}"
    fi
}

function argparser_create_usage_message() {
    # Create a usage message for the script's arguments.
    #
    # Nonlocals:
    # - args_definition: the arguments definition (read-only)
    #
    # Environment:
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_SCRIPT_NAME (read-only)

    # Define the local variables.
    local arg_definition
    local arg_key
    local arg_number
    local choice_values
    local default_values
    local fallback_values
    local header
    local -a lines
    local -a long_option_args
    local long_options
    local -a short_option_args
    local short_options
    local whitespace
    local whitespace_len

    # Print the usage message's header, giving the script's name and
    # the existence of the --help and --usage arguments.  To keep all
    # arguments aligned, the length of the script name and the
    # (translated) leading "Usage: " determines the amount of whitespace
    # printed before them.
    header="$(argparser_translate "Usage"): ${ARGPARSER_SCRIPT_NAME}"
    printf '%s [--help] [--usage]\n' "${header}"
    whitespace_len="${#header}"
    (( whitespace_len++ ))
    whitespace="$(printf '%*s' "${whitespace_len}")"

    # Separate arguments with long options from those without to output
    # first the short option-only arguments, and afterwards those with
    # long options (no matter whether they also have short options as
    # these won't get printed).
    short_option_args=( )
    long_option_args=( )
    for arg_key in "${!args_definition[@]}"; do
        # Read the argument's definition.
        IFS="${ARGPARSER_ARG_DELIMITER_1}" read -a arg_definition \
            <<< "${args_definition[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a short_options \
            <<< "${arg_definition[0]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a long_options \
            <<< "${arg_definition[1]}"

        # Add the argument to the respective array.
        if [[ "${long_options[0]}" == "-" ]]; then  # No long option.
            short_option_args+=("${arg_key}")
        else  # Long option.
            long_option_args+=("${arg_key}")
        fi
    done

    # Print each argument having only short options with the short
    # options and possibly choice values and sort them alphabetically.
    lines=( )
    for arg_key in "${short_option_args[@]}"; do
        # Read the argument's definition.
        IFS="${ARGPARSER_ARG_DELIMITER_1}" read -a arg_definition \
            <<< "${args_definition[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a short_options \
            <<< "${arg_definition[0]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a default_values \
            <<< "${arg_definition[2]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a choice_values \
            <<< "${arg_definition[3]}"
        arg_number="${arg_definition[4]}"

        # Concatenate the short options and choice values for their
        # printing style.  If the argument has no default value, a set
        # of fallbacks are printed.  Set these as the short options'
        # names in capitalized form.
        fallback_values="$(printf -- "%s${ARGPARSER_ARG_DELIMITER_2}" \
            "${short_options[@]}")"
        fallback_values="${fallback_values%?}"
        fallback_values="${fallback_values^^}"
        short_options="$(printf -- "-%s${ARGPARSER_ARG_DELIMITER_2}" \
            "${short_options[@]}")"
        short_options="${short_options%?}"
        choice_values="$(printf -- "%s${ARGPARSER_ARG_DELIMITER_2}" \
            "${choice_values[@]}")"
        choice_values="${choice_values%?}"

        # Define the line for the current argument.  The argument may
        # have some short options, a default value and some choice
        # values or an argument number of 0 (i.e., it is a flag), with
        # the existence of each changing the look of the line.
        if [[ "${arg_number}" == 0 ]]; then  # Flag.
            lines+=("$(printf '%s[%s]' "${whitespace}" "${short_options}")")
        elif [[ "${choice_values[0]}" != "-" \
            && "${default_values[0]}" != "-" ]]
        then  # Choice and default.
            lines+=("$(printf '%s%s[={%s}]' "${whitespace}" \
                "${short_options}" "${choice_values}")")
        elif [[ "${choice_values[0]}" != "-" ]]; then  # Choice only.
            lines+=("$(printf '%s%s={%s}' "${whitespace}" "${short_options}" \
                "${choice_values}")")
        elif [[ "${default_values[0]}" != "-" ]]; then  # Default only.
            lines+=("$(printf '%s%s[=%s]' "${whitespace}" "${short_options}" \
                "${fallback_values}")")
        else  # No choice nor default.
            lines+=("$(printf '%s%s=%s' "${whitespace}" "${short_options}" \
                "${fallback_values}")")
        fi
    done

    mapfile -d "" -t lines < <(argparser_sort false "${lines[@]}")
    printf '%s\n' "${lines[@]}"

    # Print each argument having long options with the long options and
    # possibly choice values and sort them alphabetically.
    lines=( )
    for arg_key in "${long_option_args[@]}"; do
        # Read the argument's definition.
        IFS="${ARGPARSER_ARG_DELIMITER_1}" read -a arg_definition \
            <<< "${args_definition[${arg_key}]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a long_options \
            <<< "${arg_definition[1]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a default_values \
            <<< "${arg_definition[2]}"
        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a choice_values \
            <<< "${arg_definition[3]}"
        arg_number="${arg_definition[4]}"

        # Concatenate the long options and choice values for their
        # printing style.  If the argument has no default value, a set
        # of fallback s are printed.  Set these as the long options'
        # names in capitalized form.
        fallback_values="$(printf -- "%s${ARGPARSER_ARG_DELIMITER_2}" \
            "${long_options[@]}")"
        fallback_values="${fallback_values%?}"
        fallback_values="${fallback_values^^}"
        long_options="$(printf -- "--%s${ARGPARSER_ARG_DELIMITER_2}" \
            "${long_options[@]}")"
        long_options="${long_options%?}"
        choice_values="$(printf -- "%s${ARGPARSER_ARG_DELIMITER_2}" \
            "${choice_values[@]}")"
        choice_values="${choice_values%?}"

        # Define the line for the current argument.  The argument may
        # have some long options (short options aren't printed), a
        # default value and some choice values or an argument number of
        # 0 (i.e., it is a flag), with the existence of each changing
        # the look of the line.
        if [[ "${arg_number}" == 0 ]]; then  # Flag.
            lines+=("$(printf '%s[%s]' "${whitespace}" "${long_options}")")
        elif [[ "${choice_values[0]}" != "-" \
            && "${default_values[0]}" != "-" ]]
        then  # Choice and default.
            lines+=("$(printf '%s%s[={%s}]' "${whitespace}" "${long_options}" \
                "${choice_values}")")
        elif [[ "${choice_values[0]}" != "-" ]]; then  # Choice only.
            lines+=("$(printf '%s%s={%s}' "${whitespace}" "${long_options}" \
                "${choice_values}")")
        elif [[ "${default_values[0]}" != "-" ]]; then  # Default only.
            lines+=("$(printf '%s%s[=%s]' "${whitespace}" "${long_options}" \
                "${fallback_values}")")
        else  # No choice nor default.
            lines+=("$(printf '%s%s=%s' "${whitespace}" "${long_options}" \
                "${fallback_values}")")
        fi
    done

    mapfile -d "" -t lines < <(argparser_sort false "${lines[@]}")
    printf '%s\n' "${lines[@]}"
}

function argparser_print_help_or_usage_message() {
    # Print a help or usage message.  If a file with such is given,
    # print the file, else, create a message for the script's arguments.
    #
    # Arguments:
    # - $1: the help type ("Help" or "Usage")
    #
    # Environment:
    # - ARGPARSER_HELP_FILE (read-only)
    # - ARGPARSER_USAGE_FILE (read-only)

    # Define the local variable.
    local help_type

    # Read the argument.
    help_type="$1"

    # Decide which message type to print.
    if [[ "${help_type}" == "Help" ]]; then
        if [[ -n "${ARGPARSER_HELP_FILE}" ]]; then
            argparser_print_help_or_usage_file "Help"
        else
            argparser_create_help_message "All"
        fi
    elif [[ "${help_type}" == "Usage" ]]; then
        if [[ -n "${ARGPARSER_USAGE_FILE}" ]]; then
            argparser_print_help_or_usage_file "Usage"
        else
            argparser_create_usage_message
        fi
    fi
}

# Define the main argparser function.
function argparser_main() {
    # Parse the script's given arguments and check if they accord to
    # their definition.  Give proper error messages for wrongly set
    # arguments and assign the values to the respective variables.
    # Possibly, create and print a help message.
    #
    # Arguments:
    # - $@: the arguments to parse
    #
    # Globals:
    # - args: the parsed and checked arguments with key and value as
    #   associative array
    #
    # Environment:
    # - ARGPARSER_ARG_ARRAY_NAME (read-only)
    # - ARGPARSER_ARG_DEF_FILE (read-only)
    # - ARGPARSER_ARG_DELIMITER_1 (read-only)
    # - ARGPARSER_ARG_DELIMITER_2 (read-only)
    # - ARGPARSER_CHECK_ARG_DEFINITION (read-only)
    # - ARGPARSER_ERROR_EXIT_CODE (read-only)
    # - ARGPARSER_ERROR_STYLE (read-only)
    # - ARGPARSER_HELP_EXIT_CODE (read-only)
    # - ARGPARSER_HELP_STYLE (read-only)
    # - ARGPARSER_POSITIONAL_NAME (read-only)
    # - ARGPARSER_SCRIPT_NAME (read-only)
    # - ARGPARSER_TRANSLATION_FILE (read-only)
    # - ARGPARSER_USAGE_EXIT_CODE (read-only)
    # - ARGPARSER_USAGE_STYLE (read-only)
    # - ARGPARSER_WARNING_STYLE (read-only)

    # Define the local variables.  If the variable that
    # ${ARGPARSER_ARG_ARRAY_NAME} refers to is undefined, all variables
    # prefixed with "arg" are searched, later.  In order to not shadow
    # them by local variables, all locals starting with "arg" are set
    # later.
    local checked_arg
    local def_pattern
    local -A dictionary
    local error
    local error_message
    local -a error_messages
    local given_arg
    local -a given_args
    local help_message
    local i
    local is_positional
    local key_pattern
    local line
    local lines
    local message
    local name
    local names
    local parsed_arg
    local usage_message
    local value_pattern
    local warning_message
    local -a warning_messages

    # Read the arguments.
    read -a given_args <<< "$@"

    # Check if the variable that ${ARGPARSER_ARG_ARRAY_NAME} refers to
    # is defined.  If not, guess how it may be called by searching the
    # set variables (not functions, hence the set POSIX mode) for a
    # variable name starting with "arg" to give a clearer error message.
    # If no such variable name is found, skip that part of the message.
    if [[ ! -v "${ARGPARSER_ARG_ARRAY_NAME}" ]]; then
        mapfile -t names <<< "$(set -o posix; set)"
        for name in "${names[@]}"; do
            if [[ "${name}" == arg* ]]; then
                name="${name%%=*}"
                break
            else
                name=""
            fi
        done
        error_message="Error: The variable ARGPARSER_ARG_ARRAY_NAME refers to "
        error_message+="\"${ARGPARSER_ARG_ARRAY_NAME}\", but this variable is "
        error_message+="not defined.  Either you have given your arguments "
        error_message+="array another name ("
        if [[ -n "${name}" ]]; then  # Include the guessed variable name.
            error_message+="maybe \"${name}\" -- "
        fi
        error_message+="then change ARGPARSER_ARG_ARRAY_NAME accordingly) or "
        error_message+="you forgot defining the array at all (then define it)."

        error_message="$(argparser_colorize "${ARGPARSER_ERROR_STYLE}" \
            "${error_message}")"
        printf '%s\n' "${error_message}" >&2
        exit "${ARGPARSER_ERROR_EXIT_CODE}"
    fi

    # Define the remaining local variables that start with "arg".
    local arg
    local arg_key
    local -a arg_value
    local -A args_definition

    # Read in the requested arguments.  ${ARGPARSER_ARG_ARRAY_NAME} is
    # set to the name of the array holding the arguments in the script.
    # If it already is "args" (the default name), nothing needs to be
    # done, but other variable names need to be mapped to "args" to be
    # able to refer to the variable by name.  Thus, the array name
    # stored in ${ARGPARSER_ARG_ARRAY_NAME} gets concatenated with the
    # string "[@]" to form a construct Bash interprets as array index.
    # By using variable indirection, this then gets expanded to the
    # array's values and copied into the final ${args} array.
    if [[ "${ARGPARSER_ARG_ARRAY_NAME}" != "args" ]]; then
        args="${ARGPARSER_ARG_ARRAY_NAME}[@]"
        args=("${!args}")
    fi

    # Read the argument definition, if given as a file (i.e.,
    # ${ARGPARSER_ARG_DEF_FILE} isn't set to the empty string).
    if [[ -n "${ARGPARSER_ARG_DEF_FILE}" ]]; then
        if [[ "${ARGPARSER_ARG_DEF_FILE_HAS_HEADER}" == true ]]; then
            mapfile -s 1 -t lines < "${ARGPARSER_ARG_DEF_FILE}"
        else
            mapfile -t lines < "${ARGPARSER_ARG_DEF_FILE}"
        fi
    fi

    # Define the patterns how the arguments definition's keys and values
    # look like, as well as the pattern of both.  For the default value
    # of ${ARGPARSER_ARG_DELIMITER_1}, a colon, the value pattern
    # describes alternating sequences of seven non-colons ("+([^:])")
    # and six colons (":") in Bash's extglob syntax.  In PCRE syntax,
    # the non-colon pattern would be written as "[^:]+".  The key
    # pattern only consists of one non-colon pattern and the joined
    # definition pattern of the key pattern, a colon, and the value
    # pattern, i.e., of eight non-colons interspersed with seven colons.
    # This reflects the structure of the arguments definition.
    key_pattern="+([^${ARGPARSER_ARG_DELIMITER_1}])"

    value_pattern=""
    for i in {1..6}; do
        value_pattern+="+([^${ARGPARSER_ARG_DELIMITER_1}])"
        value_pattern+="${ARGPARSER_ARG_DELIMITER_1}"
    done
    value_pattern+="+([^${ARGPARSER_ARG_DELIMITER_1}])"

    def_pattern="${key_pattern}${ARGPARSER_ARG_DELIMITER_1}${value_pattern}"

    # Read all arguments for the script.  The arguments may either be
    # defined in the script, where they're given in the eight-column
    # argparser syntax, or in a separate arguments definition file,
    # where they're only given as their key.  If the structure differs,
    # an error is printed and the script is aborted.
    for arg in "${args[@]}"; do
        if [[ "${arg}" == ${def_pattern} ]]; then
            # The argument matches the entire definition pattern.
            # Separate its key and value from each other and store them.
            arg_key="${arg%%${ARGPARSER_ARG_DELIMITER_1}*}"
            arg_value="${arg#*${ARGPARSER_ARG_DELIMITER_1}}"
            args_definition[${arg_key}]="${arg_value}"
        elif [[ "${arg}" == ${key_pattern} && -n "${ARGPARSER_ARG_DEF_FILE}" ]]
        then
            # The argument matches the key pattern and an arguments
            # definition file is given. Iterate over all arguments
            # definition lines from the file. When the argument key in
            # one line matches the given key and the value matches the
            # value pattern, store the argument's definition and
            # continue the outer loop (with index 2).  If the inner loop
            # doesn't get aborted by the continuation, it means that no
            # fitting argument definition has been found.  Thus, print
            # an error message and abort.
            for line in "${lines[@]}"; do
                arg_key="${line%%${ARGPARSER_ARG_DELIMITER_1}*}"
                arg_value="${line#*${ARGPARSER_ARG_DELIMITER_1}}"
                if [[ "${arg_key}" == "${arg}" \
                    && "${arg_value}" == ${value_pattern} ]]
                then
                    args_definition[${arg_key}]="${arg_value}"
                    continue 2
                fi
            done
            error_message="Error: No argument definition for \"${arg}\""
            error_message="$(argparser_colorize "${ARGPARSER_ERROR_STYLE}" \
                "${error_message}")"
            printf '%s\n' "${error_message}" >&2
            exit "${ARGPARSER_ERROR_EXIT_CODE}"
        else
            # The argument doesn't match any pattern and is thus deemed
            # invalid.  Abort the script with an error message.
            error_message="Error: Invalid argument definition: \"${arg}\""
            error_message="$(argparser_colorize "${ARGPARSER_ERROR_STYLE}" \
                "${error_message}")"
            printf '%s\n' "${error_message}" >&2
            exit "${ARGPARSER_ERROR_EXIT_CODE}"
        fi
    done
    readonly -A args_definition

    # If ${ARGPARSER_CHECK_ARG_DEFINITION} is set to true, check the
    # consistency of the arguments definition.
    error_messages=( )
    warning_messages=( )
    if [[ "${ARGPARSER_CHECK_ARG_DEFINITION}" == true ]]; then
        # Check the arguments definition, first the short and long
        # option names, then the default and choice values.
        mapfile -d "" -t error_messages \
            < <(argparser_check_arg_definition_names)
        mapfile -d "" -t -O "${#error_messages[@]}" error_messages \
            < <(argparser_check_arg_definition_values)

        # If there are error messages, colorize, sort, filter, and print
        # them, then exit, as parsing the arguments with a faulty
        # definition is useless or even impossible.
        if (( "${#error_messages[@]}" > 0 )); then
            for i in "${!error_messages[@]}"; do
                error_messages[i]="$(argparser_colorize \
                    "${ARGPARSER_ERROR_STYLE}" "${error_messages[i]}")"
            done

            mapfile -d "" -t error_messages \
                < <(argparser_sort false "${error_messages[@]}")
            mapfile -d "" -t error_messages \
                < <(argparser_uniq "${error_messages[@]}")
            printf '%s\n' "${error_messages[@]}" >&2
            exit "${ARGPARSER_ERROR_EXIT_CODE}"
        fi
    fi

    # If ${ARGPARSER_TRANSLATION_FILE} isn't set to the empty string,
    # read the translation file.
    if [[ -n "${ARGPARSER_TRANSLATION_FILE}" ]]; then
        argparser_read_translation
    fi

    # Set the default argument key to ${ARGPARSER_POSITIONAL_NAME}, such
    # that initially, all arguments given before a keyword argument are
    # recognized as positional.
    arg_key="${ARGPARSER_POSITIONAL_NAME}"
    arg_value=( )

    # Parse the script's given arguments.
    is_positional=false
    error=false
    unset args
    declare -Ag args

    for given_arg in "${given_args[@]}"; do
        # Parse the argument.
        mapfile -d "" -t parsed_arg < <(argparser_parse_arg "${given_arg}")

        # Read the output message and either print the help or usage
        # message, append the message to the previous error messages or
        # set the argument's value.  In case of arguments given multiple
        # times, i.e., the key already exists in ${!args[@]}, add the
        # new values to the previously given by re-reading in the values
        # into ${arg_value}.
        for message in "${parsed_arg[@]}"; do
            case "${message}" in
                Help)
                    # Print the help message.
                    help_message="$(argparser_print_help_or_usage_message \
                        "Help")"
                    help_message="$(argparser_colorize \
                        "${ARGPARSER_HELP_STYLE}" "${help_message}")"
                    printf '%s\n' "${help_message}" >&2
                    exit "${ARGPARSER_HELP_EXIT_CODE}"
                    ;;
                Usage)
                    # Print the usage message.
                    usage_message="$(argparser_print_help_or_usage_message \
                        "Usage")"
                    usage_message="$(argparser_colorize \
                        "${ARGPARSER_USAGE_STYLE}" "${usage_message}")"
                    printf '%s\n' "${usage_message}" >&2
                    exit "${ARGPARSER_USAGE_EXIT_CODE}"
                    ;;
                Error*)
                    # Append the message to the previous error messages.
                    error=true
                    error_messages+=("${message}")
                    ;;
                Positional_Start)
                    # Set the current argument to the name
                    # ${ARGPARSER_POSITIONAL_NAME} refers to.  Set the
                    # flag that the positional arguments delimiter "--"
                    # has been set, such that all following arguments
                    # are interpreted as positional.
                    is_positional=true
                    arg_key="${ARGPARSER_POSITIONAL_NAME}"

                    if [[ "$(argparser_in_array "${arg_key}" \
                        "${!args[@]}")" == true ]]
                    then
                        # Read the previously given values.
                        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a arg_value \
                            <<< "${args[${arg_key}]}"
                    else
                        arg_value=( )
                    fi
                    ;;
                Positional_End)
                    # Set the current argument to the name
                    # ${ARGPARSER_POSITIONAL_NAME} refers to.  Set the
                    # flag that the positional arguments delimiter "++"
                    # has been set (and thus "--" has been unset), such
                    # that all following arguments are interpreted as
                    # usual.
                    is_positional=false
                    arg_key="${ARGPARSER_POSITIONAL_NAME}"

                    if [[ "$(argparser_in_array "${arg_key}" \
                        "${!args[@]}")" == true ]]
                    then
                        # Read the previously given values.
                        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a arg_value \
                            <<< "${args[${arg_key}]}"
                    else
                        arg_value=( )
                    fi
                    ;;
                Argument*)
                    # Set the current argument name.
                    arg_key="${message#Argument: ?}"

                    if [[ "$(argparser_in_array "${arg_key}" \
                        "${!args[@]}")" == true ]]
                    then
                        # Read the previously given values and set the
                        # argument's prefix ("-" or "+"), which is the
                        # first value.
                        IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a arg_value \
                            <<< "${args[${arg_key}]}"
                        arg_value[0]="${message#Argument: }"
                        arg_value[0]="${arg_value::1}"
                    else
                        arg_value=("${message#Argument: }")
                        arg_value[0]="${arg_value[0]::1}"
                    fi
                    ;;
                Value*)
                    # Set the current argument's value.
                    arg_value+=("${message#Value: }")
                    ;;
            esac
        done

        # If the argument had been set before, assign the new value to
        # it (as ${ARGPARSER_ARG_DELIMITER_2}-separated list).
        if [[ -v arg_key ]]; then
            args[${arg_key}]="$(IFS="${ARGPARSER_ARG_DELIMITER_2}"; \
                printf '%s' "${arg_value[*]}")"
        fi
    done

    # Check the arguments' values.
    for arg_key in "${!args_definition[@]}"; do
        # Check which defined argument is given to the script.  Omitted
        # arguments are assigned two hyphens ("-") as value, separated
        # by an ${ARGPARSER_ARG_DELIMITER_2} character.  The first
        # hyphen is then interpreted as prefix, the second as hint for
        # the argument's absence.  Check each argument's value.
        if [[ "$(argparser_in_array "${arg_key}" "${!args[@]}")" == true ]]
        then
            arg_value="${args[${arg_key}]}"
        else
            arg_value="-${ARGPARSER_ARG_DELIMITER_2}-"
        fi
        mapfile -d "" -t checked_arg < <(argparser_check_arg_value \
            "${arg_key}" "${arg_value}")

        # Read the output message and either append the message to the
        # previous error messages or set the argument's value.
        arg_value=""
        for message in "${checked_arg[@]}"; do
            case "${message}" in
                Error*)
                    # Append the message to the previous error messages.
                    error=true
                    error_messages+=("${message}")
                    ;;
                Warning*)
                    # Append the message to the previous warning
                    # messages.
                    warning_messages+=("${message}")
                    ;;
                Value*)
                    # Set the current argument's value.
                    arg_value="${message#Value: }"
                    ;;
            esac
        done

        # Assign the checked value to the argument.
        args[${arg_key}]="${arg_value}"
    done

    # Colorize, sort, filter, and print all error and warning messages.
    if (( "${#error_messages[@]}" > 0 )); then
        for i in "${!error_messages[@]}"; do
            error_messages[i]="$(argparser_colorize \
                "${ARGPARSER_ERROR_STYLE}" "${error_messages[i]}")"
        done

        mapfile -d "" -t error_messages \
            < <(argparser_sort false "${error_messages[@]}")
        mapfile -d "" -t error_messages \
            < <(argparser_uniq "${error_messages[@]}")
        printf '%s\n' "${error_messages[@]}" >&2
    fi

    if (( "${#warning_messages[@]}" > 0 )); then
        for i in "${!warning_messages[@]}"; do
            warning_messages[i]="$(argparser_colorize \
                "${ARGPARSER_WARNING_STYLE}" "${warning_messages[i]}")"
        done

        mapfile -d "" -t warning_messages \
            < <(argparser_sort false "${warning_messages[@]}")
        mapfile -d "" -t warning_messages \
            < <(argparser_uniq "${warning_messages[@]}")
        printf '%s\n' "${warning_messages[@]}" >&2
    fi

    # If any argument was not or wrongly given, ${error} is set to true,
    # then print a blank line and the usage message, then exit.
    if [[ "${error}" == true ]]; then
        usage_message="$(argparser_print_help_or_usage_message "Usage")"
        usage_message="$(argparser_colorize "${ARGPARSER_USAGE_STYLE}" \
            "${usage_message}")"
        printf '\n%s\n' "${usage_message}" >&2
        exit "${ARGPARSER_ERROR_EXIT_CODE}"
    fi
}

# If ${ARGPARSER_CHECK_ENV_VARS} isn't set to false, check if the
# environment variables accord to their definition.  Since
# ${ARGPARSER_CHECK_ENV_VARS} is, as any other environment variable, yet
# unchecked, its value may be different from the expected "true" or
# "false".  Hence, testing for "not false" is not the exact opposite of
# testing for "true".  Even more, if ${ARGPARSER_CHECK_ENV_VARS} is
# different from "true" and "false", the test would be mandatory as it
# shows the environment variables have been wrongly set.
if [[ "${ARGPARSER_CHECK_ENV_VARS}" != false ]]; then
    argparser_check_env_vars
fi

# If ${ARGPARSER_READ_ARGS} is set to true, read and parse the
# arguments.
if [[ "${ARGPARSER_READ_ARGS}" == true ]]; then
    argparser_main "$@"
fi

# If ${ARGPARSER_SET_ARGS} is set to true, set the arguments as
# variables to the current environment.  Set the positional arguments.
# If ${ARGPARSER_UNSET_ARGS} is set to true, all positional arguments
# given to the calling script are disabled to prevent the keyword
# arguments from being included into the environment as positional-like
# arguments.
# As setting positional variables inside a function makes them local to
# the function, not the calling script, this part is not encapsulated
# inside a function.
if [[ "${ARGPARSER_SET_ARGS}" == true ]]; then
    # Unset all positional arguments.
    if [[ "${ARGPARSER_UNSET_ARGS}" == true ]]; then
        set --
    fi

    # Set all arguments.
    for arg in "${!args[@]}"; do
        if [[ "${arg}" == "${ARGPARSER_POSITIONAL_NAME}" ]]; then
            # Set all positional arguments and remove the respective key
            # from ${args}.  In order to use the name
            # ${ARGPARSER_POSITIONAL_NAME%% *} (only the characters til
            # the first space) refers to as name for a variable to store
            # the positional arguments in, upon setting the values, eval
            # is used to access the values.  First, eval reads its
            # arguments and expands them.  Thereby, the variable name
            # ${ARGPARSER_POSITIONAL_NAME%% *} refers to is concatenated
            # with an "[@]" as array subscript.  Then, this string is
            # interpreted as second argument to printf, which expands
            # the array and prints its values, separated with spaces.
            # Then, the unquoted command substitution lets set expand
            # these values as whitespace-delimited arguments, which are
            # then set as positional arguments to the script.  This
            # allows accessing the positional arguments from ${args}
            # without needing to introduce another variable name, which
            # could collide with the user script for being on the global
            # scope, here.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a \
                "${ARGPARSER_POSITIONAL_NAME%% *}" \
                <<< "${args[${arg}]}"
            set -- $(eval printf "'%s '" \
                "\${${ARGPARSER_POSITIONAL_NAME%% *}[@]}")
            unset "${ARGPARSER_POSITIONAL_NAME%% *}"
            unset "args[${ARGPARSER_POSITIONAL_NAME}]"
        elif [[ "${args[${arg}]}" == *"${ARGPARSER_ARG_DELIMITER_2}"*
            && "${ARGPARSER_SET_ARRAYS}" == true ]]
        then
            # Set the keyword argument, which includes the
            # ${ARGPARSER_ARG_DELIMITER_2} and hence is a sequence of
            # elements, as indexed array variable, while keeping it in
            # ${args} for usage by the calling script.
            IFS="${ARGPARSER_ARG_DELIMITER_2}" read -a "${arg}" \
                <<< "${args[${arg}]}"
        else
            # Set the keyword argument as variable, while keeping it in
            # ${args} for potential usage by the calling script.
            declare "${arg}"="${args[${arg}]}"
        fi
    done
    unset arg
fi

# If ${ARGPARSER_UNSET_FUNCTIONS} is set to true, unset all argparser
# functions.  The names are used instead of a glob to limit side effects
# with potentially same-named functions from the calling script that
# stand in no relation to the argparser.
if [[ "${ARGPARSER_UNSET_FUNCTIONS}" == true ]]; then
    unset -f argparser_check_arg_definition_names
    unset -f argparser_check_arg_definition_values
    unset -f argparser_check_arg_value
    unset -f argparser_check_color_or_style
    unset -f argparser_check_env_vars
    unset -f argparser_check_file
    unset -f argparser_colorize
    unset -f argparser_count
    unset -f argparser_create_help_message
    unset -f argparser_create_usage_message
    unset -f argparser_get_option_names
    unset -f argparser_in_array
    unset -f argparser_fold
    unset -f argparser_is_variable_boolean
    unset -f argparser_is_variable_character
    unset -f argparser_is_variable_identifier
    unset -f argparser_is_variable_integer
    unset -f argparser_main
    unset -f argparser_parse_arg
    unset -f argparser_print_help_or_usage_file
    unset -f argparser_print_help_or_usage_message
    unset -f argparser_quicksort
    unset -f argparser_read_translation
    unset -f argparser_sort
    unset -f argparser_translate
    unset -f argparser_uniq
fi

# If ${ARGPARSER_UNSET_ENV_VARS} is set to true, unset all argparser
# environment variables.  Again, the names are used instead of a glob to
# limit side effects with potentially same-named variables from the
# calling script that stand in no relation to the argparser.
if [[ "${ARGPARSER_UNSET_ENV_VARS}" == true ]]; then
    unset ARGPARSER_ARG_ARRAY_NAME
    unset ARGPARSER_ARG_DEF_FILE
    unset ARGPARSER_ARG_DEF_FILE_HAS_HEADER
    unset ARGPARSER_ARG_DELIMITER_1
    unset ARGPARSER_ARG_DELIMITER_2
    unset ARGPARSER_CHECK_ARG_DEFINITION
    unset ARGPARSER_CHECK_ENV_VARS
    unset ARGPARSER_ERROR_EXIT_CODE
    unset ARGPARSER_ERROR_STYLE
    unset ARGPARSER_HELP_EXIT_CODE
    unset ARGPARSER_HELP_FILE
    unset ARGPARSER_HELP_FILE_INCLUDE_CHAR
    unset ARGPARSER_HELP_FILE_KEEP_COMMENTS
    unset ARGPARSER_HELP_STYLE
    unset ARGPARSER_LANGUAGE
    unset ARGPARSER_MAX_COL_WIDTH_1
    unset ARGPARSER_MAX_COL_WIDTH_2
    unset ARGPARSER_MAX_COL_WIDTH_3
    unset ARGPARSER_POSITIONAL_NAME
    unset ARGPARSER_READ_ARGS
    unset ARGPARSER_SCRIPT_NAME
    unset ARGPARSER_SET_ARGS
    unset ARGPARSER_SET_ARRAYS
    unset ARGPARSER_TRANSLATION_FILE
    unset ARGPARSER_UNSET_ARGS
    unset ARGPARSER_UNSET_ENV_VARS
    unset ARGPARSER_UNSET_FUNCTIONS
    unset ARGPARSER_USAGE_EXIT_CODE
    unset ARGPARSER_USAGE_FILE
    unset ARGPARSER_USAGE_FILE_INCLUDE_CHAR
    unset ARGPARSER_USAGE_FILE_KEEP_COMMENTS
    unset ARGPARSER_USAGE_STYLE
    unset ARGPARSER_WARNING_STYLE
fi
